   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"AeroQuadMain.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.systick_get_count,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	systick_get_count:
  25              	.LFB53:
  26              		.file 1 "../Libmaple/libmaple/libmaple/systick.h"
   1:../Libmaple/libmaple/libmaple/systick.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/systick.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/systick.h ****  *
   4:../Libmaple/libmaple/libmaple/systick.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/systick.h ****  *
   6:../Libmaple/libmaple/libmaple/systick.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/systick.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/systick.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/systick.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/systick.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/systick.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/systick.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/systick.h ****  *
  14:../Libmaple/libmaple/libmaple/systick.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/systick.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/systick.h ****  *
  17:../Libmaple/libmaple/libmaple/systick.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/systick.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/systick.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/systick.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/systick.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/systick.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/systick.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/systick.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/systick.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/systick.h **** 
  27:../Libmaple/libmaple/libmaple/systick.h **** /**
  28:../Libmaple/libmaple/libmaple/systick.h ****  * @file systick.h
  29:../Libmaple/libmaple/libmaple/systick.h ****  *
  30:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Various system timer definitions
  31:../Libmaple/libmaple/libmaple/systick.h ****  */
  32:../Libmaple/libmaple/libmaple/systick.h **** 
  33:../Libmaple/libmaple/libmaple/systick.h **** #ifndef _SYSTICK_H_
  34:../Libmaple/libmaple/libmaple/systick.h **** #define _SYSTICK_H_
  35:../Libmaple/libmaple/libmaple/systick.h **** 
  36:../Libmaple/libmaple/libmaple/systick.h **** #include "libmaple_types.h"
  37:../Libmaple/libmaple/libmaple/systick.h **** #include "util.h"
  38:../Libmaple/libmaple/libmaple/systick.h **** 
  39:../Libmaple/libmaple/libmaple/systick.h **** #ifdef __cplusplus
  40:../Libmaple/libmaple/libmaple/systick.h **** extern "C"{
  41:../Libmaple/libmaple/libmaple/systick.h **** #endif
  42:../Libmaple/libmaple/libmaple/systick.h **** 
  43:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map type */
  44:../Libmaple/libmaple/libmaple/systick.h **** typedef struct systick_reg_map {
  45:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CSR;            /**< Control and status register */
  46:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 RVR;            /**< Reload value register */
  47:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CNT;            /**< Current value register ("count") */
  48:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CVR;            /**< Calibration value register */
  49:../Libmaple/libmaple/libmaple/systick.h **** } systick_reg_map;
  50:../Libmaple/libmaple/libmaple/systick.h **** 
  51:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map base pointer */
  52:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_BASE                    ((struct systick_reg_map*)0xE000E010)
  53:../Libmaple/libmaple/libmaple/systick.h **** 
  54:../Libmaple/libmaple/libmaple/systick.h **** /*
  55:../Libmaple/libmaple/libmaple/systick.h ****  * Register bit definitions.
  56:../Libmaple/libmaple/libmaple/systick.h ****  */
  57:../Libmaple/libmaple/libmaple/systick.h **** 
  58:../Libmaple/libmaple/libmaple/systick.h **** /* Control and status register */
  59:../Libmaple/libmaple/libmaple/systick.h **** 
  60:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_COUNTFLAG           BIT(16)
  61:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE           BIT(2)
  62:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_EXTERNAL  0
  63:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_CORE      BIT(2)
  64:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT             BIT(1)
  65:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_PEND        BIT(1)
  66:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_NO_PEND     0
  67:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE              BIT(0)
  68:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_MULTISHOT    BIT(0)
  69:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_DISABLED     0
  70:../Libmaple/libmaple/libmaple/systick.h **** 
  71:../Libmaple/libmaple/libmaple/systick.h **** /* Calibration value register */
  72:../Libmaple/libmaple/libmaple/systick.h **** 
  73:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_NOREF               BIT(31)
  74:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_SKEW                BIT(30)
  75:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_TENMS               0xFFFFFF
  76:../Libmaple/libmaple/libmaple/systick.h **** 
  77:../Libmaple/libmaple/libmaple/systick.h **** /** System elapsed time, in milliseconds */
  78:../Libmaple/libmaple/libmaple/systick.h **** extern volatile uint32 systick_uptime_millis;
  79:../Libmaple/libmaple/libmaple/systick.h **** 
  80:../Libmaple/libmaple/libmaple/systick.h **** /**
  81:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the system uptime, in milliseconds.
  82:../Libmaple/libmaple/libmaple/systick.h ****  */
  83:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_uptime(void) {
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  85:../Libmaple/libmaple/libmaple/systick.h **** }
  86:../Libmaple/libmaple/libmaple/systick.h **** 
  87:../Libmaple/libmaple/libmaple/systick.h **** 
  88:../Libmaple/libmaple/libmaple/systick.h **** void systick_init(uint32 reload_val);
  89:../Libmaple/libmaple/libmaple/systick.h **** void systick_disable();
  90:../Libmaple/libmaple/libmaple/systick.h **** void systick_enable();
  91:../Libmaple/libmaple/libmaple/systick.h **** 
  92:../Libmaple/libmaple/libmaple/systick.h **** /**
  93:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the current value of the SysTick counter.
  94:../Libmaple/libmaple/libmaple/systick.h ****  */
  95:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_get_count(void) {
  27              		.loc 1 95 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  96:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CNT;
  32              		.loc 1 96 0
  33 0000 014B     		ldr	r3, .L2
  34 0002 9868     		ldr	r0, [r3, #8]
  97:../Libmaple/libmaple/libmaple/systick.h **** }
  35              		.loc 1 97 0
  36 0004 7047     		bx	lr
  37              	.L3:
  38 0006 00BF     		.align	2
  39              	.L2:
  40 0008 10E000E0 		.word	-536813552
  41              		.cfi_endproc
  42              	.LFE53:
  44              		.section	.text._ZL6millisv,"ax",%progbits
  45              		.align	1
  46              		.thumb
  47              		.thumb_func
  49              	_ZL6millisv:
  50              	.LFB55:
  51              		.file 2 "../Libmaple/libmaple/wirish/wirish_time.h"
   1:../Libmaple/libmaple/wirish/wirish_time.h **** /******************************************************************************
   2:../Libmaple/libmaple/wirish/wirish_time.h ****  * The MIT License
   3:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   4:../Libmaple/libmaple/wirish/wirish_time.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   6:../Libmaple/libmaple/wirish/wirish_time.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/wirish/wirish_time.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/wirish/wirish_time.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/wirish/wirish_time.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/wirish/wirish_time.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/wirish/wirish_time.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/wirish/wirish_time.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  14:../Libmaple/libmaple/wirish/wirish_time.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/wirish/wirish_time.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  17:../Libmaple/libmaple/wirish/wirish_time.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/wirish/wirish_time.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/wirish/wirish_time.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/wirish/wirish_time.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/wirish/wirish_time.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/wirish/wirish_time.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/wirish/wirish_time.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/wirish/wirish_time.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/wirish/wirish_time.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/wirish/wirish_time.h **** 
  27:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  28:../Libmaple/libmaple/wirish/wirish_time.h ****  * @file wirish_time.h
  29:../Libmaple/libmaple/wirish/wirish_time.h ****  * @brief Timing and delay functions.
  30:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  31:../Libmaple/libmaple/wirish/wirish_time.h **** 
  32:../Libmaple/libmaple/wirish/wirish_time.h **** #ifndef __WIRISH_TIME_H_
  33:../Libmaple/libmaple/wirish/wirish_time.h **** #define __WIRISH_TIME_H_
  34:../Libmaple/libmaple/wirish/wirish_time.h **** 
  35:../Libmaple/libmaple/wirish/wirish_time.h **** #include "libmaple.h"
  36:../Libmaple/libmaple/wirish/wirish_time.h **** #include "nvic.h"
  37:../Libmaple/libmaple/wirish/wirish_time.h **** #include "systick.h"
  38:../Libmaple/libmaple/wirish/wirish_time.h **** #include "boards.h"
  39:../Libmaple/libmaple/wirish/wirish_time.h **** 
  40:../Libmaple/libmaple/wirish/wirish_time.h **** #define US_PER_MS               1000
  41:../Libmaple/libmaple/wirish/wirish_time.h **** 
  42:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  43:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in milliseconds) since the beginning of program
  44:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution. On overflow, restarts at 0.
  45:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see micros()
  46:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  47:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 millis(void) {
  52              		.loc 2 47 0
  53              		.cfi_startproc
  54              		@ args = 0, pretend = 0, frame = 0
  55              		@ frame_needed = 0, uses_anonymous_args = 0
  56              		@ link register save eliminated.
  57              	.LBB5:
  58              	.LBB6:
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  59              		.loc 1 84 0
  60 0000 014B     		ldr	r3, .L5
  61 0002 1868     		ldr	r0, [r3, #0]
  62              	.LBE6:
  63              	.LBE5:
  48:../Libmaple/libmaple/wirish/wirish_time.h ****     return systick_uptime();
  49:../Libmaple/libmaple/wirish/wirish_time.h **** }
  64              		.loc 2 49 0
  65 0004 7047     		bx	lr
  66              	.L6:
  67 0006 00BF     		.align	2
  68              	.L5:
  69 0008 00000000 		.word	systick_uptime_millis
  70              		.cfi_endproc
  71              	.LFE55:
  73              		.section	.text._ZL6microsv,"ax",%progbits
  74              		.align	1
  75              		.thumb
  76              		.thumb_func
  78              	_ZL6microsv:
  79              	.LFB56:
  50:../Libmaple/libmaple/wirish/wirish_time.h **** 
  51:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  52:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in microseconds) since the beginning of program
  53:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution.  On overflow, restarts at 0.
  54:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see millis()
  55:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  56:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 micros(void) {
  80              		.loc 2 56 0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  84 0000 38B5     		push	{r3, r4, r5, lr}
  85              	.LCFI0:
  86              		.cfi_def_cfa_offset 16
  87              		.cfi_offset 14, -4
  88              		.cfi_offset 5, -8
  89              		.cfi_offset 4, -12
  90              		.cfi_offset 3, -16
  91              	.L8:
  92              	.LBB10:
  57:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 ms;
  58:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 cycle_cnt;
  59:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 res;
  60:../Libmaple/libmaple/wirish/wirish_time.h **** 
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
  62:../Libmaple/libmaple/wirish/wirish_time.h ****         ms = millis();
  93              		.loc 2 62 0 discriminator 1
  94 0002 FFF7FEFF 		bl	_ZL6millisv
  95 0006 0446     		mov	r4, r0
  96              	.LVL0:
  63:../Libmaple/libmaple/wirish/wirish_time.h ****         cycle_cnt = systick_get_count();
  97              		.loc 2 63 0 discriminator 1
  98 0008 FFF7FEFF 		bl	systick_get_count
  99              	.LVL1:
 100 000c 0546     		mov	r5, r0
  64:../Libmaple/libmaple/wirish/wirish_time.h ****         asm volatile("nop"); //allow interrupt to fire
 101              		.loc 2 64 0 discriminator 1
 102              	@ 64 "../Libmaple/libmaple/wirish/wirish_time.h" 1
 103 000e 00BF     		nop
 104              	@ 0 "" 2
  65:../Libmaple/libmaple/wirish/wirish_time.h ****         asm volatile("nop");
 105              		.loc 2 65 0 discriminator 1
 106              	@ 65 "../Libmaple/libmaple/wirish/wirish_time.h" 1
 107 0010 00BF     		nop
 108              	@ 0 "" 2
  66:../Libmaple/libmaple/wirish/wirish_time.h ****     } while (ms != millis());
 109              		.loc 2 66 0 discriminator 1
 110              		.thumb
 111 0012 FFF7FEFF 		bl	_ZL6millisv
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
 112              		.loc 2 61 0 discriminator 1
 113 0016 8442     		cmp	r4, r0
 114 0018 F3D1     		bne	.L8
 115              	.LBB11:
 116              	.LBB12:
  98:../Libmaple/libmaple/libmaple/systick.h **** 
  99:../Libmaple/libmaple/libmaple/systick.h **** /**
 100:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Check for underflow.
 101:../Libmaple/libmaple/libmaple/systick.h ****  *
 102:../Libmaple/libmaple/libmaple/systick.h ****  * This function returns 1 if the SysTick timer has counted to 0 since
 103:../Libmaple/libmaple/libmaple/systick.h ****  * the last time it was called.  However, any reads of any part of the
 104:../Libmaple/libmaple/libmaple/systick.h ****  * SysTick Control and Status Register SYSTICK_BASE->CSR will
 105:../Libmaple/libmaple/libmaple/systick.h ****  * interfere with this functionality.  See the ARM Cortex M3 Technical
 106:../Libmaple/libmaple/libmaple/systick.h ****  * Reference Manual for more details (e.g. Table 8-3 in revision r1p1).
 107:../Libmaple/libmaple/libmaple/systick.h ****  */
 108:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_check_underflow(void) {
 109:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CSR & SYSTICK_CSR_COUNTFLAG;
 117              		.loc 1 109 0
 118 001a 0948     		ldr	r0, .L11
 119 001c 0368     		ldr	r3, [r0, #0]
 120              	.LBE12:
 121              	.LBE11:
  67:../Libmaple/libmaple/wirish/wirish_time.h **** 
  68:../Libmaple/libmaple/wirish/wirish_time.h ****     if(systick_check_underflow()) {
 122              		.loc 2 68 0
 123 001e DB03     		lsls	r3, r3, #15
 124 0020 03D5     		bpl	.L9
  69:../Libmaple/libmaple/wirish/wirish_time.h ****     	ms++;
  70:../Libmaple/libmaple/wirish/wirish_time.h ****     	cycle_cnt = systick_get_count();
 125              		.loc 2 70 0
 126 0022 FFF7FEFF 		bl	systick_get_count
  69:../Libmaple/libmaple/wirish/wirish_time.h ****     	ms++;
 127              		.loc 2 69 0
 128 0026 0134     		adds	r4, r4, #1
 129              	.LVL2:
 130              		.loc 2 70 0
 131 0028 0546     		mov	r5, r0
 132              	.LVL3:
 133              	.L9:
  71:../Libmaple/libmaple/wirish/wirish_time.h ****     }
  72:../Libmaple/libmaple/wirish/wirish_time.h **** 
  73:../Libmaple/libmaple/wirish/wirish_time.h ****     /* SYSTICK_RELOAD_VAL is 1 less than the number of cycles it
  74:../Libmaple/libmaple/wirish/wirish_time.h ****        actually takes to complete a SysTick reload */
  75:../Libmaple/libmaple/wirish/wirish_time.h ****     res = (ms * US_PER_MS) +
  76:../Libmaple/libmaple/wirish/wirish_time.h ****         (SYSTICK_RELOAD_VAL + 1 - cycle_cnt) / CYCLES_PER_MICROSECOND;
 134              		.loc 2 76 0
 135 002a C5F52435 		rsb	r5, r5, #167936
 136              	.LVL4:
 137 002e 4035     		adds	r5, r5, #64
 138 0030 A822     		movs	r2, #168
 139 0032 B5FBF2F5 		udiv	r5, r5, r2
 140              	.LBE10:
  77:../Libmaple/libmaple/wirish/wirish_time.h **** 
  78:../Libmaple/libmaple/wirish/wirish_time.h ****     return res;
  79:../Libmaple/libmaple/wirish/wirish_time.h **** }
 141              		.loc 2 79 0
 142 0036 4FF47A71 		mov	r1, #1000
 143 003a 01FB0450 		mla	r0, r1, r4, r5
 144 003e 38BD     		pop	{r3, r4, r5, pc}
 145              	.L12:
 146              		.align	2
 147              	.L11:
 148 0040 10E000E0 		.word	-536813552
 149              		.cfi_endproc
 150              	.LFE56:
 152              		.section	.text.timer_set_compare.isra.2,"ax",%progbits
 153              		.align	1
 154              		.thumb
 155              		.thumb_func
 157              	timer_set_compare.isra.2:
 158              	.LFB286:
 159              		.file 3 "../Libmaple/libmaple/libmaple/timer.h"
   1:../Libmaple/libmaple/libmaple/timer.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/timer.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/timer.h ****  *
   4:../Libmaple/libmaple/libmaple/timer.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/timer.h ****  *
   6:../Libmaple/libmaple/libmaple/timer.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/timer.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/timer.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/timer.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/timer.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/timer.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/timer.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/timer.h ****  *
  14:../Libmaple/libmaple/libmaple/timer.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/timer.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/timer.h ****  *
  17:../Libmaple/libmaple/libmaple/timer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/timer.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/timer.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/timer.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/timer.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/timer.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/timer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/timer.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/timer.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/timer.h **** 
  27:../Libmaple/libmaple/libmaple/timer.h **** /**
  28:../Libmaple/libmaple/libmaple/timer.h ****  * @file   timer.h
  29:../Libmaple/libmaple/libmaple/timer.h ****  * @author Marti Bolivar <mbolivar@leaflabs.com>
  30:../Libmaple/libmaple/libmaple/timer.h ****  * @brief  New-style timer interface.
  31:../Libmaple/libmaple/libmaple/timer.h ****  *
  32:../Libmaple/libmaple/libmaple/timer.h ****  * Replaces old timers.h implementation.
  33:../Libmaple/libmaple/libmaple/timer.h ****  */
  34:../Libmaple/libmaple/libmaple/timer.h **** 
  35:../Libmaple/libmaple/libmaple/timer.h **** #ifndef _TIMERS_H_
  36:../Libmaple/libmaple/libmaple/timer.h **** #define _TIMERS_H_
  37:../Libmaple/libmaple/libmaple/timer.h **** 
  38:../Libmaple/libmaple/libmaple/timer.h **** #include "libmaple.h"
  39:../Libmaple/libmaple/libmaple/timer.h **** #include "rcc.h"
  40:../Libmaple/libmaple/libmaple/timer.h **** #include "nvic.h"
  41:../Libmaple/libmaple/libmaple/timer.h **** #include "bitband.h"
  42:../Libmaple/libmaple/libmaple/timer.h **** 
  43:../Libmaple/libmaple/libmaple/timer.h **** #ifdef __cplusplus
  44:../Libmaple/libmaple/libmaple/timer.h **** extern "C"{
  45:../Libmaple/libmaple/libmaple/timer.h **** #endif
  46:../Libmaple/libmaple/libmaple/timer.h **** 
  47:../Libmaple/libmaple/libmaple/timer.h **** /*
  48:../Libmaple/libmaple/libmaple/timer.h ****  * Register maps and devices
  49:../Libmaple/libmaple/libmaple/timer.h ****  */
  50:../Libmaple/libmaple/libmaple/timer.h **** 
  51:../Libmaple/libmaple/libmaple/timer.h **** /** Advanced control timer register map type */
  52:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_adv_reg_map {
  53:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  54:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  55:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  56:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  57:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  58:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  59:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  60:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  61:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  62:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  63:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  64:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  65:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 RCR;            /**< Repetition counter register */
  66:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  67:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  68:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  69:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  70:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 BDTR;           /**< Break and dead-time register */
  71:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  72:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  73:../Libmaple/libmaple/libmaple/timer.h **** } timer_adv_reg_map;
  74:../Libmaple/libmaple/libmaple/timer.h **** 
  75:../Libmaple/libmaple/libmaple/timer.h **** /** General purpose timer register map type */
  76:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_gen_reg_map {
  77:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  78:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  79:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  80:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  81:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  82:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  83:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  84:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  85:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  86:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  87:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  88:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  89:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
  90:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  91:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  92:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  93:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  94:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
  95:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  96:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  97:../Libmaple/libmaple/libmaple/timer.h **** } timer_gen_reg_map;
  98:../Libmaple/libmaple/libmaple/timer.h **** 
  99:../Libmaple/libmaple/libmaple/timer.h **** /** Basic timer register map type */
 100:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_bas_reg_map {
 101:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
 102:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
 103:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
 104:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
 105:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
 106:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
 107:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
 108:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED3;     /**< Reserved */
 109:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED4;     /**< Reserved */
 110:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
 111:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
 112:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
 113:../Libmaple/libmaple/libmaple/timer.h **** } timer_bas_reg_map;
 114:../Libmaple/libmaple/libmaple/timer.h **** 
 115:../Libmaple/libmaple/libmaple/timer.h **** 
 116:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 117:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 118:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40010000)
 119:../Libmaple/libmaple/libmaple/timer.h **** #else
 120:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 121:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40012C00)
 122:../Libmaple/libmaple/libmaple/timer.h **** #endif
 123:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 2 register map base pointer */
 124:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER2_BASE        ((struct timer_gen_reg_map*)0x40000000)
 125:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 3 register map base pointer */
 126:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER3_BASE        ((struct timer_gen_reg_map*)0x40000400)
 127:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 4 register map base pointer */
 128:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER4_BASE        ((struct timer_gen_reg_map*)0x40000800)
 129:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 130:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 5 register map base pointer */
 131:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER5_BASE        ((struct timer_gen_reg_map*)0x40000C00)
 132:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 6 register map base pointer */
 133:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER6_BASE        ((struct timer_bas_reg_map*)0x40001000)
 134:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 7 register map base pointer */
 135:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER7_BASE        ((struct timer_bas_reg_map*)0x40001400)
 136:../Libmaple/libmaple/libmaple/timer.h **** 
 137:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 138:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 139:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40010400)
 140:../Libmaple/libmaple/libmaple/timer.h **** #else
 141:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 142:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40013400)
 143:../Libmaple/libmaple/libmaple/timer.h **** #endif
 144:../Libmaple/libmaple/libmaple/timer.h **** #endif
 145:../Libmaple/libmaple/libmaple/timer.h **** 
 146:../Libmaple/libmaple/libmaple/timer.h **** /*
 147:../Libmaple/libmaple/libmaple/timer.h ****  * Timer devices
 148:../Libmaple/libmaple/libmaple/timer.h ****  */
 149:../Libmaple/libmaple/libmaple/timer.h **** 
 150:../Libmaple/libmaple/libmaple/timer.h **** /**
 151:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer register map type.
 152:../Libmaple/libmaple/libmaple/timer.h ****  *
 153:../Libmaple/libmaple/libmaple/timer.h ****  * Just holds a pointer to the correct type of register map, based on
 154:../Libmaple/libmaple/libmaple/timer.h ****  * the timer's type.
 155:../Libmaple/libmaple/libmaple/timer.h ****  */
 156:../Libmaple/libmaple/libmaple/timer.h **** typedef union timer_reg_map {
 157:../Libmaple/libmaple/libmaple/timer.h ****     timer_adv_reg_map *adv;     /**< Advanced register map */
 158:../Libmaple/libmaple/libmaple/timer.h ****     timer_gen_reg_map *gen;     /**< General purpose register map */
 159:../Libmaple/libmaple/libmaple/timer.h ****     timer_bas_reg_map *bas;     /**< Basic register map */
 160:../Libmaple/libmaple/libmaple/timer.h **** } timer_reg_map;
 161:../Libmaple/libmaple/libmaple/timer.h **** 
 162:../Libmaple/libmaple/libmaple/timer.h **** /**
 163:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer type
 164:../Libmaple/libmaple/libmaple/timer.h ****  *
 165:../Libmaple/libmaple/libmaple/timer.h ****  * Type marker for timer_dev.
 166:../Libmaple/libmaple/libmaple/timer.h ****  *
 167:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_dev
 168:../Libmaple/libmaple/libmaple/timer.h ****  */
 169:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_type {
 170:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_ADVANCED,             /**< Advanced type */
 171:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_GENERAL,              /**< General purpose type */
 172:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BASIC                 /**< Basic type */
 173:../Libmaple/libmaple/libmaple/timer.h **** } timer_type;
 174:../Libmaple/libmaple/libmaple/timer.h **** 
 175:../Libmaple/libmaple/libmaple/timer.h **** /** Timer device type */
 176:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_dev {
 177:../Libmaple/libmaple/libmaple/timer.h ****     timer_reg_map regs;         /**< Register map */
 178:../Libmaple/libmaple/libmaple/timer.h ****     rcc_clk_id clk_id;          /**< RCC clock information */
 179:../Libmaple/libmaple/libmaple/timer.h ****     timer_type type;            /**< Timer's type */
 180:../Libmaple/libmaple/libmaple/timer.h ****     voidFuncPtr handlers[];     /**< User IRQ handlers */
 181:../Libmaple/libmaple/libmaple/timer.h **** } timer_dev;
 182:../Libmaple/libmaple/libmaple/timer.h **** 
 183:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER1;
 184:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER2;
 185:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER3;
 186:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER4;
 187:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 188:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER5;
 189:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER6;
 190:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER7;
 191:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER8;
 192:../Libmaple/libmaple/libmaple/timer.h **** #endif
 193:../Libmaple/libmaple/libmaple/timer.h **** 
 194:../Libmaple/libmaple/libmaple/timer.h **** /*
 195:../Libmaple/libmaple/libmaple/timer.h ****  * Register bit definitions
 196:../Libmaple/libmaple/libmaple/timer.h ****  */
 197:../Libmaple/libmaple/libmaple/timer.h **** 
 198:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 1 (CR1) */
 199:../Libmaple/libmaple/libmaple/timer.h **** 
 200:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE_BIT              7
 201:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR_BIT               4
 202:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM_BIT               3
 203:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS_BIT               2
 204:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS_BIT              1
 205:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN_BIT               0
 206:../Libmaple/libmaple/libmaple/timer.h **** 
 207:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD                   (0x3 << 8)
 208:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_1TCKINT           (0x0 << 8)
 209:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_2TCKINT           (0x1 << 8)
 210:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_4TICKINT          (0x2 << 8)
 211:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE                  BIT(TIMER_CR1_ARPE_BIT)
 212:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS               (0x3 << 5)
 213:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_EDGE          (0x0 << 5)
 214:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER1       (0x1 << 5)
 215:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER2       (0x2 << 5)
 216:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER3       (0x3 << 5)
 217:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR                   BIT(TIMER_CR1_DIR_BIT)
 218:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM                   BIT(TIMER_CR1_OPM_BIT)
 219:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS                   BIT(TIMER_CR1_URS_BIT)
 220:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS                  BIT(TIMER_CR1_UDIS_BIT)
 221:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN                   BIT(TIMER_CR1_CEN_BIT)
 222:../Libmaple/libmaple/libmaple/timer.h **** 
 223:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 2 (CR2) */
 224:../Libmaple/libmaple/libmaple/timer.h **** 
 225:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4_BIT              14
 226:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N_BIT             13
 227:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3_BIT              12
 228:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N_BIT             11
 229:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2_BIT              10
 230:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N_BIT             9
 231:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1_BIT              8
 232:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S_BIT              7 /* tills? yikes */
 233:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS_BIT              3
 234:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS_BIT              2
 235:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC_BIT              0
 236:../Libmaple/libmaple/libmaple/timer.h **** 
 237:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4                  BIT(TIMER_CR2_OIS4_BIT)
 238:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N                 BIT(TIMER_CR2_OIS3N_BIT)
 239:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3                  BIT(TIMER_CR2_OIS3_BIT)
 240:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N                 BIT(TIMER_CR2_OIS2N_BIT)
 241:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2                  BIT(TIMER_CR2_OIS2_BIT)
 242:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N                 BIT(TIMER_CR2_OIS1N_BIT)
 243:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1                  BIT(TIMER_CR2_OIS1_BIT)
 244:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S                  BIT(TIMER_CR2_TI1S_BIT)
 245:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS                   (0x7 << 4)
 246:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_RESET             (0x0 << 4)
 247:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_ENABLE            (0x1 << 4)
 248:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_UPDATE            (0x2 << 4)
 249:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_PULSE     (0x3 << 4)
 250:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC1REF    (0x4 << 4)
 251:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC2REF    (0x5 << 4)
 252:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC3REF    (0x6 << 4)
 253:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC4REF    (0x7 << 4)
 254:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS                  BIT(TIMER_CR2_CCDS_BIT)
 255:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS                  BIT(TIMER_CR2_CCUS_BIT)
 256:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC                  BIT(TIMER_CR2_CCPC_BIT)
 257:../Libmaple/libmaple/libmaple/timer.h **** 
 258:../Libmaple/libmaple/libmaple/timer.h **** /* Slave mode control register (SMCR) */
 259:../Libmaple/libmaple/libmaple/timer.h **** 
 260:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP_BIT              15
 261:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE_BIT              14
 262:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM_BIT              7
 263:../Libmaple/libmaple/libmaple/timer.h **** 
 264:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP                  BIT(TIMER_SMCR_ETP_BIT)
 265:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE                  BIT(TIMER_SMCR_ECE_BIT)
 266:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS                 (0x3 << 12)
 267:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_OFF             (0x0 << 12)
 268:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV2            (0x1 << 12)
 269:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV4            (0x2 << 12)
 270:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV8            (0x3 << 12)
 271:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETF                  (0xF << 12)
 272:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM                  BIT(TIMER_SMCR_MSM_BIT)
 273:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS                   (0x3 << 4)
 274:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR0              (0x0 << 4)
 275:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR1              (0x1 << 4)
 276:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR2              (0x2 << 4)
 277:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR3              (0x3 << 4)
 278:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1F_ED           (0x4 << 4)
 279:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1FP1            (0x5 << 4)
 280:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI2FP2            (0x6 << 4)
 281:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ETRF              (0x7 << 4)
 282:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS                  0x3
 283:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_DISABLED         0x0
 284:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER1         0x1
 285:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER2         0x2
 286:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER3         0x3
 287:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_RESET            0x4
 288:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_GATED            0x5
 289:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_TRIGGER          0x6
 290:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_EXTERNAL         0x7
 291:../Libmaple/libmaple/libmaple/timer.h **** 
 292:../Libmaple/libmaple/libmaple/timer.h **** /* DMA/Interrupt enable register (DIER) */
 293:../Libmaple/libmaple/libmaple/timer.h **** 
 294:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE_BIT              14
 295:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE_BIT            12
 296:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE_BIT            11
 297:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE_BIT            10
 298:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE_BIT            9
 299:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE_BIT              8
 300:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE_BIT              6
 301:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE_BIT            4
 302:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE_BIT            3
 303:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE_BIT            2
 304:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE_BIT            1
 305:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE_BIT              0
 306:../Libmaple/libmaple/libmaple/timer.h **** 
 307:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE                  BIT(TIMER_DIER_TDE_BIT)
 308:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE                BIT(TIMER_DIER_CC4DE_BIT)
 309:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE                BIT(TIMER_DIER_CC3DE_BIT)
 310:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE                BIT(TIMER_DIER_CC2DE_BIT)
 311:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE                BIT(TIMER_DIER_CC1DE_BIT)
 312:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE                  BIT(TIMER_DIER_UDE_BIT)
 313:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE                  BIT(TIMER_DIER_TIE_BIT)
 314:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE                BIT(TIMER_DIER_CC4IE_BIT)
 315:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE                BIT(TIMER_DIER_CC3IE_BIT)
 316:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE                BIT(TIMER_DIER_CC2IE_BIT)
 317:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE                BIT(TIMER_DIER_CC1IE_BIT)
 318:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE                  BIT(TIMER_DIER_UIE_BIT)
 319:../Libmaple/libmaple/libmaple/timer.h **** 
 320:../Libmaple/libmaple/libmaple/timer.h **** /* Status register (SR) */
 321:../Libmaple/libmaple/libmaple/timer.h **** 
 322:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF_BIT              12
 323:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF_BIT              11
 324:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF_BIT              10
 325:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF_BIT              9
 326:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF_BIT                7
 327:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF_BIT                6
 328:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF_BIT              5
 329:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF_BIT              4
 330:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF_BIT              3
 331:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF_BIT              2
 332:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF_BIT              1
 333:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF_BIT                0
 334:../Libmaple/libmaple/libmaple/timer.h **** 
 335:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF                  BIT(TIMER_SR_CC4OF_BIT)
 336:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF                  BIT(TIMER_SR_CC3OF_BIT)
 337:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF                  BIT(TIMER_SR_CC2OF_BIT)
 338:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF                  BIT(TIMER_SR_CC1OF_BIT)
 339:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF                    BIT(TIMER_SR_BIF_BIT)
 340:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF                    BIT(TIMER_SR_TIF_BIT)
 341:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF                  BIT(TIMER_SR_COMIF_BIT)
 342:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF                  BIT(TIMER_SR_CC4IF_BIT)
 343:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF                  BIT(TIMER_SR_CC3IF_BIT)
 344:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF                  BIT(TIMER_SR_CC2IF_BIT)
 345:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF                  BIT(TIMER_SR_CC1IF_BIT)
 346:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF                    BIT(TIMER_SR_UIF_BIT)
 347:../Libmaple/libmaple/libmaple/timer.h **** 
 348:../Libmaple/libmaple/libmaple/timer.h **** /* Event generation register (EGR) */
 349:../Libmaple/libmaple/libmaple/timer.h **** 
 350:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG_BIT                6
 351:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G_BIT              4
 352:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G_BIT              3
 353:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G_BIT              2
 354:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G_BIT              1
 355:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG_BIT                0
 356:../Libmaple/libmaple/libmaple/timer.h **** 
 357:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG                    BIT(TIMER_EGR_TG_BIT)
 358:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G                  BIT(TIMER_EGR_CC4G_BIT)
 359:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G                  BIT(TIMER_EGR_CC3G_BIT)
 360:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G                  BIT(TIMER_EGR_CC2G_BIT)
 361:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G                  BIT(TIMER_EGR_CC1G_BIT)
 362:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG                    BIT(TIMER_EGR_UG_BIT)
 363:../Libmaple/libmaple/libmaple/timer.h **** 
 364:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode registers, common values */
 365:../Libmaple/libmaple/libmaple/timer.h **** 
 366:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_OUTPUT           0x0
 367:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI1        0x1
 368:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI2        0x2
 369:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TRC        0x3
 370:../Libmaple/libmaple/libmaple/timer.h **** 
 371:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 1 (CCMR1) */
 372:../Libmaple/libmaple/libmaple/timer.h **** 
 373:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE_BIT           15
 374:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE_BIT           11
 375:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE_BIT           10
 376:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE_BIT           7
 377:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE_BIT           3
 378:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE_BIT           2
 379:../Libmaple/libmaple/libmaple/timer.h **** 
 380:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE               BIT(TIMER_CCMR1_OC2CE_BIT)
 381:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2M                (0x3 << 12)
 382:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2F                (0xF << 12)
 383:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE               BIT(TIMER_CCMR1_OC2PE_BIT)
 384:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE               BIT(TIMER_CCMR1_OC2FE_BIT)
 385:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2PSC              (0x3 << 10)
 386:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S                (0x3 << 8)
 387:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 388:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 389:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 390:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 391:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE               BIT(TIMER_CCMR1_OC1CE_BIT)
 392:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1M                (0x3 << 4)
 393:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1F                (0xF << 4)
 394:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE               BIT(TIMER_CCMR1_OC1PE_BIT)
 395:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE               BIT(TIMER_CCMR1_OC1FE_BIT)
 396:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1PSC              (0x3 << 2)
 397:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S                0x3
 398:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 399:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 400:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 401:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 402:../Libmaple/libmaple/libmaple/timer.h **** 
 403:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 2 (CCMR2) */
 404:../Libmaple/libmaple/libmaple/timer.h **** 
 405:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE_BIT           15
 406:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE_BIT           11
 407:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE_BIT           10
 408:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE_BIT           7
 409:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE_BIT           3
 410:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE_BIT           2
 411:../Libmaple/libmaple/libmaple/timer.h **** 
 412:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE               BIT(TIMER_CCMR2_OC4CE_BIT)
 413:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4M                (0x3 << 12)
 414:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2F                (0xF << 12)
 415:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE               BIT(TIMER_CCMR2_OC4PE_BIT)
 416:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE               BIT(TIMER_CCMR2_OC4FE_BIT)
 417:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2PSC              (0x3 << 10)
 418:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC4S                (0x3 << 8)
 419:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 420:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 421:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 422:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 423:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE               BIT(TIMER_CCMR2_OC3CE_BIT)
 424:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3M                (0x3 << 4)
 425:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1F                (0xF << 4)
 426:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE               BIT(TIMER_CCMR2_OC3PE_BIT)
 427:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE               BIT(TIMER_CCMR2_OC3FE_BIT)
 428:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1PSC              (0x3 << 2)
 429:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC3S                0x3
 430:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 431:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 432:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 433:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 434:../Libmaple/libmaple/libmaple/timer.h **** 
 435:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare enable register (CCER) */
 436:../Libmaple/libmaple/libmaple/timer.h **** 
 437:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P_BIT             13
 438:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E_BIT             12
 439:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P_BIT             9
 440:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E_BIT             8
 441:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P_BIT             5
 442:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E_BIT             4
 443:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P_BIT             1
 444:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E_BIT             0
 445:../Libmaple/libmaple/libmaple/timer.h **** 
 446:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P                 BIT(TIMER_CCER_CC4P_BIT)
 447:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E                 BIT(TIMER_CCER_CC4E_BIT)
 448:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P                 BIT(TIMER_CCER_CC3P_BIT)
 449:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E                 BIT(TIMER_CCER_CC3E_BIT)
 450:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P                 BIT(TIMER_CCER_CC2P_BIT)
 451:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E                 BIT(TIMER_CCER_CC2E_BIT)
 452:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P                 BIT(TIMER_CCER_CC1P_BIT)
 453:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E                 BIT(TIMER_CCER_CC1E_BIT)
 454:../Libmaple/libmaple/libmaple/timer.h **** 
 455:../Libmaple/libmaple/libmaple/timer.h **** /* Break and dead-time register (BDTR) */
 456:../Libmaple/libmaple/libmaple/timer.h **** 
 457:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE_BIT              15
 458:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE_BIT              14
 459:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP_BIT              13
 460:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE_BIT              12
 461:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR_BIT             11
 462:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI_BIT             10
 463:../Libmaple/libmaple/libmaple/timer.h **** 
 464:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE                  BIT(TIMER_BDTR_MOE_BIT)
 465:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE                  BIT(TIMER_BDTR_AOE_BIT)
 466:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP                  BIT(TIMER_BDTR_BKP_BIT)
 467:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE                  BIT(TIMER_BDTR_BKE_BIT)
 468:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR                 BIT(TIMER_BDTR_OSSR_BIT)
 469:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI                 BIT(TIMER_BDTR_OSSI_BIT)
 470:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK                 (0x3 << 8)
 471:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_OFF             (0x0 << 8)
 472:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL1          (0x1 << 8)
 473:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL2          (0x2 << 8)
 474:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL3          (0x3 << 8)
 475:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_DTG                  0xFF
 476:../Libmaple/libmaple/libmaple/timer.h **** 
 477:../Libmaple/libmaple/libmaple/timer.h **** /* DMA control register (DCR) */
 478:../Libmaple/libmaple/libmaple/timer.h **** 
 479:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL                   (0x1F << 8)
 480:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_1BYTE             (0x0 << 8)
 481:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_2BYTE             (0x1 << 8)
 482:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_3BYTE             (0x2 << 8)
 483:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_4BYTE             (0x3 << 8)
 484:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_5BYTE             (0x4 << 8)
 485:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_6BYTE             (0x5 << 8)
 486:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_7BYTE             (0x6 << 8)
 487:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_8BYTE             (0x7 << 8)
 488:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_9BYTE             (0x8 << 8)
 489:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_10BYTE            (0x9 << 8)
 490:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_11BYTE            (0xA << 8)
 491:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_12BYTE            (0xB << 8)
 492:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_13BYTE            (0xC << 8)
 493:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_14BYTE            (0xD << 8)
 494:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_15BYTE            (0xE << 8)
 495:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_16BYTE            (0xF << 8)
 496:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_17BYTE            (0x10 << 8)
 497:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_18BYTE            (0x11 << 8)
 498:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA                   0x1F
 499:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR1               0x0
 500:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR2               0x1
 501:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SMCR              0x2
 502:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DIER              0x3
 503:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SR                0x4
 504:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_EGR               0x5
 505:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR1             0x6
 506:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR2             0x7
 507:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCER              0x8
 508:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CNT               0x9
 509:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_PSC               0xA
 510:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_ARR               0xB
 511:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_RCR               0xC
 512:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR1              0xD
 513:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR2              0xE
 514:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR3              0xF
 515:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR4              0x10
 516:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_BDTR              0x11
 517:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DCR               0x12
 518:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DMAR              0x13
 519:../Libmaple/libmaple/libmaple/timer.h **** 
 520:../Libmaple/libmaple/libmaple/timer.h **** /*
 521:../Libmaple/libmaple/libmaple/timer.h ****  * Convenience routines
 522:../Libmaple/libmaple/libmaple/timer.h ****  */
 523:../Libmaple/libmaple/libmaple/timer.h **** 
 524:../Libmaple/libmaple/libmaple/timer.h **** /**
 525:../Libmaple/libmaple/libmaple/timer.h ****  * Used to configure the behavior of a timer channel.  Note that not
 526:../Libmaple/libmaple/libmaple/timer.h ****  * all timers can be configured in every mode.
 527:../Libmaple/libmaple/libmaple/timer.h ****  */
 528:../Libmaple/libmaple/libmaple/timer.h **** /* TODO TIMER_PWM_CENTER_ALIGNED, TIMER_INPUT_CAPTURE, TIMER_ONE_PULSE */
 529:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_mode {
 530:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_DISABLED, /**< In this mode, the timer stops counting,
 531:../Libmaple/libmaple/libmaple/timer.h ****                          channel interrupts are detached, and no state
 532:../Libmaple/libmaple/libmaple/timer.h ****                          changes are output. */
 533:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_PWM, /**< PWM output mode. This is the default mode for pins
 534:../Libmaple/libmaple/libmaple/timer.h ****                     after initialization. */
 535:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_PWM_CENTER_ALIGNED, /\**< Center-aligned PWM output mode. *\/ */
 536:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_OUTPUT_COMPARE, /**< In this mode, the timer counts from 0
 537:../Libmaple/libmaple/libmaple/timer.h ****                                to its reload value repeatedly; every
 538:../Libmaple/libmaple/libmaple/timer.h ****                                time the counter value reaches one of
 539:../Libmaple/libmaple/libmaple/timer.h ****                                the channel compare values, the
 540:../Libmaple/libmaple/libmaple/timer.h ****                                corresponding interrupt is fired. */
 541:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_INPUT_CAPTURE, /\**< In this mode, the timer can measure the */
 542:../Libmaple/libmaple/libmaple/timer.h ****     /*                           pulse lengths of input signals. *\/ */
 543:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_ONE_PULSE /\**< In this mode, the timer can generate a single */
 544:../Libmaple/libmaple/libmaple/timer.h ****     /*                      pulse on a GPIO pin for a specified amount of */
 545:../Libmaple/libmaple/libmaple/timer.h ****     /*                      time. *\/ */
 546:../Libmaple/libmaple/libmaple/timer.h **** } timer_mode;
 547:../Libmaple/libmaple/libmaple/timer.h **** 
 548:../Libmaple/libmaple/libmaple/timer.h **** /** Timer channel numbers */
 549:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_channel {
 550:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH1 = 1, /**< Channel 1 */
 551:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH2 = 2, /**< Channel 2 */
 552:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH3 = 3, /**< Channel 3 */
 553:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH4 = 4  /**< Channel 4 */
 554:../Libmaple/libmaple/libmaple/timer.h **** } timer_channel;
 555:../Libmaple/libmaple/libmaple/timer.h **** 
 556:../Libmaple/libmaple/libmaple/timer.h **** /*
 557:../Libmaple/libmaple/libmaple/timer.h ****  * Note: Don't require timer_channel arguments! We want to be able to say
 558:../Libmaple/libmaple/libmaple/timer.h ****  *
 559:../Libmaple/libmaple/libmaple/timer.h ****  * for (int channel = 1; channel <= 4; channel++) {
 560:../Libmaple/libmaple/libmaple/timer.h ****  *    ...
 561:../Libmaple/libmaple/libmaple/timer.h ****  * }
 562:../Libmaple/libmaple/libmaple/timer.h ****  *
 563:../Libmaple/libmaple/libmaple/timer.h ****  * without the compiler yelling at us.
 564:../Libmaple/libmaple/libmaple/timer.h ****  */
 565:../Libmaple/libmaple/libmaple/timer.h **** 
 566:../Libmaple/libmaple/libmaple/timer.h **** void timer_init(timer_dev *dev);
 567:../Libmaple/libmaple/libmaple/timer.h **** void timer_disable(timer_dev *dev);
 568:../Libmaple/libmaple/libmaple/timer.h **** void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode);
 569:../Libmaple/libmaple/libmaple/timer.h **** void timer_foreach(void (*fn)(timer_dev*));
 570:../Libmaple/libmaple/libmaple/timer.h **** 
 571:../Libmaple/libmaple/libmaple/timer.h **** /**
 572:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer interrupt number.
 573:../Libmaple/libmaple/libmaple/timer.h ****  *
 574:../Libmaple/libmaple/libmaple/timer.h ****  * Not all timers support all of these values; see the descriptions
 575:../Libmaple/libmaple/libmaple/timer.h ****  * for each value.
 576:../Libmaple/libmaple/libmaple/timer.h ****  */
 577:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_interrupt_id {
 578:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_UPDATE_INTERRUPT, /**< Update interrupt, available on all timers. */
 579:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC1_INTERRUPT, /**< Capture/compare 1 interrupt, available
 580:../Libmaple/libmaple/libmaple/timer.h ****                               on general and advanced timers only. */
 581:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC2_INTERRUPT, /**< Capture/compare 2 interrupt, general and
 582:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 583:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC3_INTERRUPT, /**< Capture/compare 3 interrupt, general and
 584:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 585:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC4_INTERRUPT, /**< Capture/compare 4 interrupt, general and
 586:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 587:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_COM_INTERRUPT, /**< COM interrupt, advanced timers only */
 588:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_TRG_INTERRUPT, /**< Trigger interrupt, general and advanced
 589:../Libmaple/libmaple/libmaple/timer.h ****                               timers only */
 590:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BREAK_INTERRUPT /**< Break interrupt, advanced timers only. */
 591:../Libmaple/libmaple/libmaple/timer.h **** } timer_interrupt_id;
 592:../Libmaple/libmaple/libmaple/timer.h **** 
 593:../Libmaple/libmaple/libmaple/timer.h **** void timer_attach_interrupt(timer_dev *dev,
 594:../Libmaple/libmaple/libmaple/timer.h ****                             uint8 interrupt,
 595:../Libmaple/libmaple/libmaple/timer.h ****                             voidFuncPtr handler);
 596:../Libmaple/libmaple/libmaple/timer.h **** void timer_detach_interrupt(timer_dev *dev, uint8 interrupt);
 597:../Libmaple/libmaple/libmaple/timer.h **** 
 598:../Libmaple/libmaple/libmaple/timer.h **** /**
 599:../Libmaple/libmaple/libmaple/timer.h ****  * Initialize all timer devices on the chip.
 600:../Libmaple/libmaple/libmaple/timer.h ****  */
 601:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_init_all(void) {
 602:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_init);
 603:../Libmaple/libmaple/libmaple/timer.h **** }
 604:../Libmaple/libmaple/libmaple/timer.h **** 
 605:../Libmaple/libmaple/libmaple/timer.h **** /**
 606:../Libmaple/libmaple/libmaple/timer.h ****  * Disables all timers on the device.
 607:../Libmaple/libmaple/libmaple/timer.h ****  */
 608:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_disable_all(void) {
 609:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_disable);
 610:../Libmaple/libmaple/libmaple/timer.h **** }
 611:../Libmaple/libmaple/libmaple/timer.h **** 
 612:../Libmaple/libmaple/libmaple/timer.h **** /**
 613:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Stop a timer's counter from changing.
 614:../Libmaple/libmaple/libmaple/timer.h ****  *
 615:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 616:../Libmaple/libmaple/libmaple/timer.h ****  *
 617:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to pause.
 618:../Libmaple/libmaple/libmaple/timer.h ****  */
 619:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_pause(timer_dev *dev) {
 620:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 0;
 621:../Libmaple/libmaple/libmaple/timer.h **** }
 622:../Libmaple/libmaple/libmaple/timer.h **** 
 623:../Libmaple/libmaple/libmaple/timer.h **** /**
 624:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Start a timer's counter.
 625:../Libmaple/libmaple/libmaple/timer.h ****  *
 626:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 627:../Libmaple/libmaple/libmaple/timer.h ****  *
 628:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to resume
 629:../Libmaple/libmaple/libmaple/timer.h ****  */
 630:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_resume(timer_dev *dev) {
 631:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 1;
 632:../Libmaple/libmaple/libmaple/timer.h **** }
 633:../Libmaple/libmaple/libmaple/timer.h **** 
 634:../Libmaple/libmaple/libmaple/timer.h **** /**
 635:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the timer's counter value.
 636:../Libmaple/libmaple/libmaple/timer.h ****  *
 637:../Libmaple/libmaple/libmaple/timer.h ****  * This value is likely to be inaccurate if the counter is running
 638:../Libmaple/libmaple/libmaple/timer.h ****  * with a low prescaler.
 639:../Libmaple/libmaple/libmaple/timer.h ****  *
 640:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to return
 641:../Libmaple/libmaple/libmaple/timer.h ****  */
 642:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_count(timer_dev *dev) {
 643:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->CNT;
 644:../Libmaple/libmaple/libmaple/timer.h **** }
 645:../Libmaple/libmaple/libmaple/timer.h **** 
 646:../Libmaple/libmaple/libmaple/timer.h **** /**
 647:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Sets the counter value for the given timer.
 648:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to set
 649:../Libmaple/libmaple/libmaple/timer.h ****  * @param value New counter value
 650:../Libmaple/libmaple/libmaple/timer.h ****  */
 651:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_count(timer_dev *dev, uint16 value) {
 652:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->CNT = value;
 653:../Libmaple/libmaple/libmaple/timer.h **** }
 654:../Libmaple/libmaple/libmaple/timer.h **** 
 655:../Libmaple/libmaple/libmaple/timer.h **** /**
 656:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the given timer's prescaler.
 657:../Libmaple/libmaple/libmaple/timer.h ****  *
 658:../Libmaple/libmaple/libmaple/timer.h ****  * Note that if the timer's prescaler is set (e.g. via
 659:../Libmaple/libmaple/libmaple/timer.h ****  * timer_set_prescaler() or accessing a TIMx_PSC register), the value
 660:../Libmaple/libmaple/libmaple/timer.h ****  * returned by this function will reflect the new setting, but the
 661:../Libmaple/libmaple/libmaple/timer.h ****  * timer's counter will only reflect the new prescaler at the next
 662:../Libmaple/libmaple/libmaple/timer.h ****  * update event.
 663:../Libmaple/libmaple/libmaple/timer.h ****  *
 664:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to return
 665:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 666:../Libmaple/libmaple/libmaple/timer.h ****  */
 667:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_prescaler(timer_dev *dev) {
 668:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->PSC;
 669:../Libmaple/libmaple/libmaple/timer.h **** }
 670:../Libmaple/libmaple/libmaple/timer.h **** 
 671:../Libmaple/libmaple/libmaple/timer.h **** /**
 672:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's prescale value.
 673:../Libmaple/libmaple/libmaple/timer.h ****  *
 674:../Libmaple/libmaple/libmaple/timer.h ****  * Divides the input clock by (PSC+1).  The new value will not take
 675:../Libmaple/libmaple/libmaple/timer.h ****  * effect until the next update event.
 676:../Libmaple/libmaple/libmaple/timer.h ****  *
 677:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to set
 678:../Libmaple/libmaple/libmaple/timer.h ****  * @param psc New prescaler value
 679:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 680:../Libmaple/libmaple/libmaple/timer.h ****  */
 681:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_prescaler(timer_dev *dev, uint16 psc) {
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 683:../Libmaple/libmaple/libmaple/timer.h **** }
 684:../Libmaple/libmaple/libmaple/timer.h **** 
 685:../Libmaple/libmaple/libmaple/timer.h **** /**
 686:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns a timer's reload value.
 687:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to return
 688:../Libmaple/libmaple/libmaple/timer.h ****  */
 689:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_reload(timer_dev *dev) {
 690:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->ARR;
 691:../Libmaple/libmaple/libmaple/timer.h **** }
 692:../Libmaple/libmaple/libmaple/timer.h **** 
 693:../Libmaple/libmaple/libmaple/timer.h **** /**
 694:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's reload value.
 695:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to set
 696:../Libmaple/libmaple/libmaple/timer.h ****  * @param arr New reload value to use.  Takes effect at next update event.
 697:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 698:../Libmaple/libmaple/libmaple/timer.h ****  */
 699:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_reload(timer_dev *dev, uint16 arr) {
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 701:../Libmaple/libmaple/libmaple/timer.h **** }
 702:../Libmaple/libmaple/libmaple/timer.h **** 
 703:../Libmaple/libmaple/libmaple/timer.h **** /**
 704:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Get the compare value for the given timer channel.
 705:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 706:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to get.
 707:../Libmaple/libmaple/libmaple/timer.h ****  */
 708:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_compare(timer_dev *dev, uint8 channel) {
 709:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 710:../Libmaple/libmaple/libmaple/timer.h ****     return *ccr;
 711:../Libmaple/libmaple/libmaple/timer.h **** }
 712:../Libmaple/libmaple/libmaple/timer.h **** 
 713:../Libmaple/libmaple/libmaple/timer.h **** /**
 714:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set the compare value for the given timer channel.
 715:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 716:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to set.
 717:../Libmaple/libmaple/libmaple/timer.h ****  * @param value   New compare value.
 718:../Libmaple/libmaple/libmaple/timer.h ****  */
 719:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_compare(timer_dev *dev,
 160              		.loc 3 719 0
 161              		.cfi_startproc
 162              		@ args = 0, pretend = 0, frame = 0
 163              		@ frame_needed = 0, uses_anonymous_args = 0
 164              		@ link register save eliminated.
 165              	.LVL5:
 166              	.LBB13:
 720:../Libmaple/libmaple/libmaple/timer.h ****                                      uint8 channel,
 721:../Libmaple/libmaple/libmaple/timer.h ****                                      uint16 value) {
 722:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 167              		.loc 3 722 0
 168 0000 3430     		adds	r0, r0, #52
 169 0002 0139     		subs	r1, r1, #1
 170              	.LVL6:
 723:../Libmaple/libmaple/libmaple/timer.h ****     *ccr = value;
 171              		.loc 3 723 0
 172 0004 40F82120 		str	r2, [r0, r1, lsl #2]
 173              	.LBE13:
 724:../Libmaple/libmaple/libmaple/timer.h **** }
 174              		.loc 3 724 0
 175 0008 7047     		bx	lr
 176              		.cfi_endproc
 177              	.LFE286:
 179              		.section	.text.startup._Z7premainv,"ax",%progbits
 180              		.align	1
 181              		.global	_Z7premainv
 182              		.thumb
 183              		.thumb_func
 185              	_Z7premainv:
 186              	.LFB114:
 187              		.file 4 "/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp"
   1:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** #include <../AeroQuad/UserConfiguration.h>
   2:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** #include <SerialMapping.h>
   3:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** #include <WProgram.h>
   4:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
   5:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** __attribute__(( constructor )) void premain() {
 188              		.loc 4 5 0
 189              		.cfi_startproc
 190              		@ args = 0, pretend = 0, frame = 0
 191              		@ frame_needed = 0, uses_anonymous_args = 0
 192              		@ link register save eliminated.
   6:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****     init();
   7:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** }
 193              		.loc 4 7 0
   6:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****     init();
 194              		.loc 4 6 0
 195 0000 FFF7FEBF 		b	_Z4initv
 196              		.cfi_endproc
 197              	.LFE114:
 199              		.section	.init_array,"aw",%init_array
 200              		.align	2
 201 0000 00000000 		.word	_Z7premainv(target1)
 202              		.section	.text._init,"ax",%progbits
 203              		.align	1
 204              		.global	_init
 205              		.thumb
 206              		.thumb_func
 208              	_init:
 209              	.LFB115:
   8:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
   9:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** extern "C"{
  10:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****         void _init(){};
 210              		.loc 4 10 0
 211              		.cfi_startproc
 212              		@ args = 0, pretend = 0, frame = 0
 213              		@ frame_needed = 0, uses_anonymous_args = 0
 214              		@ link register save eliminated.
 215              		.loc 4 10 0
 216 0000 7047     		bx	lr
 217              		.cfi_endproc
 218              	.LFE115:
 220              		.section	.text._ZN7TwoWire4readEv,"axG",%progbits,_ZN7TwoWire4readEv,comdat
 221              		.align	1
 222              		.weak	_ZN7TwoWire4readEv
 223              		.thumb
 224              		.thumb_func
 226              	_ZN7TwoWire4readEv:
 227              	.LFB117:
 228              		.file 5 "../Libmaple/libmaple/libraries/Wire/Wire.h"
   1:../Libmaple/libmaple/libraries/Wire/Wire.h **** /* *****************************************************************************
   2:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * The MIT License
   3:../Libmaple/libmaple/libraries/Wire/Wire.h ****  *
   4:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * Copyright (c) 2010 LeafLabs LLC.
   5:../Libmaple/libmaple/libraries/Wire/Wire.h ****  *
   6:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * of this software and associated documentation files (the "Software"), to deal
   8:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * in the Software without restriction, including without limitation the rights
   9:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * copies of the Software, and to permit persons to whom the Software is
  11:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * furnished to do so, subject to the following conditions:
  12:../Libmaple/libmaple/libraries/Wire/Wire.h ****  *
  13:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * The above copyright notice and this permission notice shall be included in
  14:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * all copies or substantial portions of the Software.
  15:../Libmaple/libmaple/libraries/Wire/Wire.h ****  *
  16:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * THE SOFTWARE.
  23:../Libmaple/libmaple/libraries/Wire/Wire.h ****  * ****************************************************************************/
  24:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  25:../Libmaple/libmaple/libraries/Wire/Wire.h **** /**
  26:../Libmaple/libmaple/libraries/Wire/Wire.h ****  *  @brief Wire library, ported from Arduino. Provides a lean
  27:../Libmaple/libmaple/libraries/Wire/Wire.h ****  *  interface to I2C (two-wire) communication.
  28:../Libmaple/libmaple/libraries/Wire/Wire.h ****  */
  29:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  30:../Libmaple/libmaple/libraries/Wire/Wire.h **** #include "wirish.h"
  31:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  32:../Libmaple/libmaple/libraries/Wire/Wire.h **** #ifndef _WIRE_H_
  33:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define _WIRE_H_
  34:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  35:../Libmaple/libmaple/libraries/Wire/Wire.h **** typedef struct {
  36:../Libmaple/libmaple/libraries/Wire/Wire.h ****   uint8 scl;
  37:../Libmaple/libmaple/libraries/Wire/Wire.h ****   uint8 sda;
  38:../Libmaple/libmaple/libraries/Wire/Wire.h **** } Port;
  39:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  40:../Libmaple/libmaple/libraries/Wire/Wire.h **** /* You must update the online docs if you change this value. */
  41:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define WIRE_BUFSIZ 32
  42:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  43:../Libmaple/libmaple/libraries/Wire/Wire.h **** /* return codes from endTransmission() */
  44:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define SUCCESS   0        /* transmission was successful */
  45:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define EDATA     1        /* too much data */
  46:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define ENACKADDR 2        /* received nack on transmit of address */
  47:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define ENACKTRNS 3        /* received nack on transmit of data */
  48:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define EOTHER    4        /* other error */
  49:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  50:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define SDA 20
  51:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define SCL 21
  52:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  53:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define I2C_WRITE 0
  54:../Libmaple/libmaple/libraries/Wire/Wire.h **** #define I2C_READ  1
  55:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  56:../Libmaple/libmaple/libraries/Wire/Wire.h **** #if (F_CPU == 168000000)
  57:../Libmaple/libmaple/libraries/Wire/Wire.h **** 	#define I2C_DELAY_SCL delay_ns100(6) 
  58:../Libmaple/libmaple/libraries/Wire/Wire.h **** 	#define I2C_DELAY_SDA delay_ns100(2)
  59:../Libmaple/libmaple/libraries/Wire/Wire.h **** #else
  60:../Libmaple/libmaple/libraries/Wire/Wire.h **** 	#define I2C_DELAY_SCL
  61:../Libmaple/libmaple/libraries/Wire/Wire.h **** 	#define I2C_DELAY_SDA
  62:../Libmaple/libmaple/libraries/Wire/Wire.h **** #endif
  63:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  64:../Libmaple/libmaple/libraries/Wire/Wire.h **** class TwoWire {
  65:../Libmaple/libmaple/libraries/Wire/Wire.h ****  private:
  66:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 rx_buf[WIRE_BUFSIZ];      /* receive buffer */
  67:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 rx_buf_idx;               /* first unread idx in rx_buf */
  68:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 rx_buf_len;               /* number of bytes read */
  69:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  70:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 tx_addr;                  /* address transmitting to */
  71:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 tx_buf[WIRE_BUFSIZ];      /* transmit buffer */
  72:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 tx_buf_idx;               /* next idx available in tx_buf, -1 overflow */
  73:../Libmaple/libmaple/libraries/Wire/Wire.h ****     boolean tx_buf_overflow;
  74:../Libmaple/libmaple/libraries/Wire/Wire.h ****     Port port;
  75:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 writeOneByte(uint8);
  76:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 readOneByte(uint8, uint8*);
  77:../Libmaple/libmaple/libraries/Wire/Wire.h ****  public:
  78:../Libmaple/libmaple/libraries/Wire/Wire.h ****     TwoWire();
  79:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void begin();
  80:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void begin(uint8, uint8);
  81:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void beginTransmission(uint8);
  82:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void beginTransmission(int);
  83:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 endTransmission(void);
  84:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 requestFrom(uint8, int);
  85:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 requestFrom(int, int);
  86:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void send(uint8);
  87:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void send(uint8*, int);
  88:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void send(int);
  89:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void send(int*, int);
  90:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void send(char*);
  91:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 available();
  92:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 receive();
  93:../Libmaple/libmaple/libraries/Wire/Wire.h **** 
  94:../Libmaple/libmaple/libraries/Wire/Wire.h ****     uint8 read() { return receive(); };
 229              		.loc 5 94 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              		@ link register save eliminated.
 234              	.LVL7:
 235              		.loc 5 94 0
 236 0000 FFF7FEBF 		b	_ZN7TwoWire7receiveEv
 237              	.LVL8:
 238              		.cfi_endproc
 239              	.LFE117:
 241              		.section	.text._ZN7TwoWire5writeEi,"axG",%progbits,_ZN7TwoWire5writeEi,comdat
 242              		.align	1
 243              		.weak	_ZN7TwoWire5writeEi
 244              		.thumb
 245              		.thumb_func
 247              	_ZN7TwoWire5writeEi:
 248              	.LFB120:
  95:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void write(uint8 data) { send(data); };
  96:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void write(uint8* buf, int len) { send(buf, len); };
  97:../Libmaple/libmaple/libraries/Wire/Wire.h ****     void write(int data) { send(data); };
 249              		.loc 5 97 0
 250              		.cfi_startproc
 251              		@ args = 0, pretend = 0, frame = 0
 252              		@ frame_needed = 0, uses_anonymous_args = 0
 253              		@ link register save eliminated.
 254              	.LVL9:
 255              		.loc 5 97 0
 256 0000 FFF7FEBF 		b	_ZN7TwoWire4sendEi
 257              	.LVL10:
 258              	.LVL11:
 259              		.cfi_endproc
 260              	.LFE120:
 262              		.section	.text._Z23initializeReceiverParami,"ax",%progbits
 263              		.align	1
 264              		.global	_Z23initializeReceiverParami
 265              		.thumb
 266              		.thumb_func
 268              	_Z23initializeReceiverParami:
 269              	.LFB123:
 270              		.file 6 "../Libraries/AQ_Receiver/Receiver.h"
   1:../Libraries/AQ_Receiver/Receiver.h **** /*
   2:../Libraries/AQ_Receiver/Receiver.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Receiver/Receiver.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Receiver/Receiver.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Receiver/Receiver.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Receiver/Receiver.h ****  
   7:../Libraries/AQ_Receiver/Receiver.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Receiver/Receiver.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Receiver/Receiver.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Receiver/Receiver.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Receiver/Receiver.h **** 
  12:../Libraries/AQ_Receiver/Receiver.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Receiver/Receiver.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Receiver/Receiver.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Receiver/Receiver.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Receiver/Receiver.h **** 
  17:../Libraries/AQ_Receiver/Receiver.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Receiver/Receiver.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Receiver/Receiver.h **** */
  20:../Libraries/AQ_Receiver/Receiver.h **** 
  21:../Libraries/AQ_Receiver/Receiver.h **** #ifndef _AEROQUAD_RECEIVER_H_
  22:../Libraries/AQ_Receiver/Receiver.h **** #define _AEROQUAD_RECEIVER_H_
  23:../Libraries/AQ_Receiver/Receiver.h **** 
  24:../Libraries/AQ_Receiver/Receiver.h **** #include "Arduino.h"
  25:../Libraries/AQ_Receiver/Receiver.h **** 
  26:../Libraries/AQ_Receiver/Receiver.h **** #define PWM2RAD 0.002 //  Based upon 5RAD for full stick movement, you take this times the RAD to g
  27:../Libraries/AQ_Receiver/Receiver.h **** 
  28:../Libraries/AQ_Receiver/Receiver.h **** // Receiver variables
  29:../Libraries/AQ_Receiver/Receiver.h **** #define TIMEOUT 25000
  30:../Libraries/AQ_Receiver/Receiver.h **** #define MINCOMMAND 1000
  31:../Libraries/AQ_Receiver/Receiver.h **** #define MIDCOMMAND 1500
  32:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCOMMAND 2000
  33:../Libraries/AQ_Receiver/Receiver.h **** #define MINDELTA 200
  34:../Libraries/AQ_Receiver/Receiver.h **** #define MINCHECK (MINCOMMAND + 100)
  35:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCHECK (MAXCOMMAND - 100)
  36:../Libraries/AQ_Receiver/Receiver.h **** #define MINTHROTTLE (MINCOMMAND + 100)
  37:../Libraries/AQ_Receiver/Receiver.h **** #define LEVELOFF 100
  38:../Libraries/AQ_Receiver/Receiver.h **** #define MAX_NB_CHANNEL 10
  39:../Libraries/AQ_Receiver/Receiver.h **** 
  40:../Libraries/AQ_Receiver/Receiver.h **** int lastReceiverChannel = 0;
  41:../Libraries/AQ_Receiver/Receiver.h **** 
  42:../Libraries/AQ_Receiver/Receiver.h **** float receiverXmitFactor = 0.0;
  43:../Libraries/AQ_Receiver/Receiver.h **** int receiverData[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0};
  44:../Libraries/AQ_Receiver/Receiver.h **** int receiverZero[3] = {0,0,0};
  45:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommand[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0};
  46:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommandSmooth[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0,};
  47:../Libraries/AQ_Receiver/Receiver.h **** float receiverSlope[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  48:../Libraries/AQ_Receiver/Receiver.h **** float receiverOffset[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  49:../Libraries/AQ_Receiver/Receiver.h **** float receiverSmoothFactor[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  50:../Libraries/AQ_Receiver/Receiver.h **** int channelCal;
  51:../Libraries/AQ_Receiver/Receiver.h **** 
  52:../Libraries/AQ_Receiver/Receiver.h **** void initializeReceiverParam(int nbChannel = 6) {
 271              		.loc 6 52 0
 272              		.cfi_startproc
 273              		@ args = 0, pretend = 0, frame = 0
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              		@ link register save eliminated.
 276              	.LVL12:
 277              	.LBB14:
  53:../Libraries/AQ_Receiver/Receiver.h ****   
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 278              		.loc 6 54 0
 279 0000 254A     		ldr	r2, .L27
  55:../Libraries/AQ_Receiver/Receiver.h **** 
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 280              		.loc 6 56 0
 281 0002 264B     		ldr	r3, .L27+4
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 282              		.loc 6 54 0
 283 0004 1060     		str	r0, [r2, #0]
 284              		.loc 6 56 0
 285 0006 40F2DC51 		movw	r1, #1500
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
  59:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[THROTTLE] = 1000;
 286              		.loc 6 59 0
 287 000a 4FF47A72 		mov	r2, #1000
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 288              		.loc 6 56 0
 289 000e 1960     		str	r1, [r3, #0]
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
 290              		.loc 6 57 0
 291 0010 5960     		str	r1, [r3, #4]
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
 292              		.loc 6 58 0
 293 0012 9960     		str	r1, [r3, #8]
 294              		.loc 6 59 0
 295 0014 DA60     		str	r2, [r3, #12]
  60:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[MODE] = 1000;
 296              		.loc 6 60 0
 297 0016 1A61     		str	r2, [r3, #16]
  61:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX1] = 1000;
 298              		.loc 6 61 0
 299 0018 5A61     		str	r2, [r3, #20]
  62:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX2] = 1000;
 300              		.loc 6 62 0
 301 001a 9A61     		str	r2, [r3, #24]
  63:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX3] = 1000;
 302              		.loc 6 63 0
 303 001c DA61     		str	r2, [r3, #28]
  64:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX4] = 1000;
 304              		.loc 6 64 0
 305 001e 1A62     		str	r2, [r3, #32]
  65:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX5] = 1000;
 306              		.loc 6 65 0
 307 0020 5A62     		str	r2, [r3, #36]
 308              	.LVL13:
 309              	.LBB15:
  66:../Libraries/AQ_Receiver/Receiver.h ****   
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 310              		.loc 6 67 0
 311 0022 0023     		movs	r3, #0
 312 0024 07E0     		b	.L19
 313              	.LVL14:
 314              	.L20:
  68:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = 1.0;
 315              		.loc 6 68 0 discriminator 2
 316 0026 0121     		movs	r1, #1
 317 0028 1D4A     		ldr	r2, .L27+8
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 318              		.loc 6 67 0 discriminator 2
 319 002a 03EB010C 		add	ip, r3, r1
 320              		.loc 6 68 0 discriminator 2
 321 002e 42F82310 		str	r1, [r2, r3, lsl #2]
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 322              		.loc 6 67 0 discriminator 2
 323 0032 5FFA8CF3 		uxtb	r3, ip
 324              	.LVL15:
 325              	.L19:
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 326              		.loc 6 67 0 is_stmt 0 discriminator 1
 327 0036 8342     		cmp	r3, r0
 328 0038 F5DB     		blt	.L20
 329              	.LVL16:
 330              	.LBE15:
 331              	.LBB16:
  69:../Libraries/AQ_Receiver/Receiver.h ****   }
  70:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  71:../Libraries/AQ_Receiver/Receiver.h ****     receiverZero[channel] = 1500;
 332              		.loc 6 71 0 is_stmt 1 discriminator 1
 333 003a 1A4B     		ldr	r3, .L27+12
 334              	.LVL17:
 335 003c 40F2DC51 		movw	r1, #1500
 336 0040 1960     		str	r1, [r3, #0]
 337              	.LVL18:
 338 0042 5960     		str	r1, [r3, #4]
 339              	.LVL19:
 340 0044 9960     		str	r1, [r3, #8]
 341              	.LVL20:
 342 0046 0023     		movs	r3, #0
 343 0048 08E0     		b	.L21
 344              	.LVL21:
 345              	.L22:
 346              	.LBE16:
 347              	.LBB17:
  72:../Libraries/AQ_Receiver/Receiver.h ****   }
  73:../Libraries/AQ_Receiver/Receiver.h **** 	
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  75:../Libraries/AQ_Receiver/Receiver.h ****     receiverSlope[channel] = 1;
 348              		.loc 6 75 0 discriminator 2
 349 004a 174A     		ldr	r2, .L27+16
 350 004c 02EB8301 		add	r1, r2, r3, lsl #2
 351 0050 4FF07E5C 		mov	ip, #1065353216
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 352              		.loc 6 74 0 discriminator 2
 353 0054 5A1C     		adds	r2, r3, #1
 354              		.loc 6 75 0 discriminator 2
 355 0056 C1F800C0 		str	ip, [r1, #0]	@ float
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 356              		.loc 6 74 0 discriminator 2
 357 005a D3B2     		uxtb	r3, r2
 358              	.LVL22:
 359              	.L21:
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 360              		.loc 6 74 0 is_stmt 0 discriminator 1
 361 005c 8342     		cmp	r3, r0
 362 005e F4DB     		blt	.L22
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 363              		.loc 6 74 0
 364 0060 0023     		movs	r3, #0
 365              	.LVL23:
 366 0062 08E0     		b	.L23
 367              	.LVL24:
 368              	.L24:
 369              	.LBE17:
 370              	.LBB18:
  76:../Libraries/AQ_Receiver/Receiver.h ****   }	
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  78:../Libraries/AQ_Receiver/Receiver.h ****     receiverOffset[channel] = 1;
 371              		.loc 6 78 0 is_stmt 1 discriminator 2
 372 0064 114A     		ldr	r2, .L27+20
 373 0066 02EB8301 		add	r1, r2, r3, lsl #2
 374 006a 4FF07E5C 		mov	ip, #1065353216
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 375              		.loc 6 77 0 discriminator 2
 376 006e 0133     		adds	r3, r3, #1
 377              	.LVL25:
 378              		.loc 6 78 0 discriminator 2
 379 0070 C1F800C0 		str	ip, [r1, #0]	@ float
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 380              		.loc 6 77 0 discriminator 2
 381 0074 DBB2     		uxtb	r3, r3
 382              	.LVL26:
 383              	.L23:
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 384              		.loc 6 77 0 is_stmt 0 discriminator 1
 385 0076 8342     		cmp	r3, r0
 386 0078 F4DB     		blt	.L24
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 387              		.loc 6 77 0
 388 007a 0023     		movs	r3, #0
 389              	.LVL27:
 390 007c 08E0     		b	.L25
 391              	.LVL28:
 392              	.L26:
 393              	.LBE18:
 394              	.LBB19:
  79:../Libraries/AQ_Receiver/Receiver.h ****   }
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  81:../Libraries/AQ_Receiver/Receiver.h ****     receiverSmoothFactor[channel] = 1; 
 395              		.loc 6 81 0 is_stmt 1 discriminator 2
 396 007e 0C4A     		ldr	r2, .L27+24
 397 0080 02EB8301 		add	r1, r2, r3, lsl #2
 398 0084 4FF07E5C 		mov	ip, #1065353216
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 399              		.loc 6 80 0 discriminator 2
 400 0088 0133     		adds	r3, r3, #1
 401              	.LVL29:
 402              		.loc 6 81 0 discriminator 2
 403 008a C1F800C0 		str	ip, [r1, #0]	@ float
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 404              		.loc 6 80 0 discriminator 2
 405 008e DBB2     		uxtb	r3, r3
 406              	.LVL30:
 407              	.L25:
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 408              		.loc 6 80 0 is_stmt 0 discriminator 1
 409 0090 8342     		cmp	r3, r0
 410 0092 F4DB     		blt	.L26
 411              	.LBE19:
 412              	.LBE14:
  82:../Libraries/AQ_Receiver/Receiver.h ****   }
  83:../Libraries/AQ_Receiver/Receiver.h **** }
 413              		.loc 6 83 0 is_stmt 1
 414 0094 7047     		bx	lr
 415              	.L28:
 416 0096 00BF     		.align	2
 417              	.L27:
 418 0098 00000000 		.word	.LANCHOR0
 419 009c 00000000 		.word	.LANCHOR1
 420 00a0 00000000 		.word	.LANCHOR2
 421 00a4 00000000 		.word	.LANCHOR3
 422 00a8 00000000 		.word	.LANCHOR4
 423 00ac 00000000 		.word	.LANCHOR5
 424 00b0 00000000 		.word	.LANCHOR6
 425              		.cfi_endproc
 426              	.LFE123:
 428              		.section	.text._Z17getReceiverSIDatah,"ax",%progbits
 429              		.align	1
 430              		.global	_Z17getReceiverSIDatah
 431              		.thumb
 432              		.thumb_func
 434              	_Z17getReceiverSIDatah:
 435              	.LFB125:
  84:../Libraries/AQ_Receiver/Receiver.h ****   
  85:../Libraries/AQ_Receiver/Receiver.h **** int getRawChannelValue(byte channel);  
  86:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver();
  87:../Libraries/AQ_Receiver/Receiver.h ****   
  88:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver()
  89:../Libraries/AQ_Receiver/Receiver.h **** {
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  91:../Libraries/AQ_Receiver/Receiver.h **** 
  92:../Libraries/AQ_Receiver/Receiver.h ****     // Apply receiver calibration adjustment
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
  94:../Libraries/AQ_Receiver/Receiver.h ****     // Smooth the flight control receiver inputs
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
  96:../Libraries/AQ_Receiver/Receiver.h ****   }
  97:../Libraries/AQ_Receiver/Receiver.h ****   
  98:../Libraries/AQ_Receiver/Receiver.h ****   // Reduce receiver commands using receiverXmitFactor and center around 1500
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 101:../Libraries/AQ_Receiver/Receiver.h ****   }	
 102:../Libraries/AQ_Receiver/Receiver.h ****   // No xmitFactor reduction applied for throttle, mode and AUX
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 104:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 105:../Libraries/AQ_Receiver/Receiver.h ****   }
 106:../Libraries/AQ_Receiver/Receiver.h **** }
 107:../Libraries/AQ_Receiver/Receiver.h **** 
 108:../Libraries/AQ_Receiver/Receiver.h **** 
 109:../Libraries/AQ_Receiver/Receiver.h **** void setChannelValue(byte channel,int value);
 110:../Libraries/AQ_Receiver/Receiver.h ****   
 111:../Libraries/AQ_Receiver/Receiver.h **** // return the smoothed & scaled number of radians/sec in stick movement - zero centered
 112:../Libraries/AQ_Receiver/Receiver.h **** const float getReceiverSIData(byte channel) {
 436              		.loc 6 112 0
 437              		.cfi_startproc
 438              		@ args = 0, pretend = 0, frame = 0
 439              		@ frame_needed = 0, uses_anonymous_args = 0
 440              		@ link register save eliminated.
 441              	.LVL31:
 113:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 442              		.loc 6 113 0
 443 0000 0849     		ldr	r1, .L30
 444 0002 094B     		ldr	r3, .L30+4
 445 0004 51F82020 		ldr	r2, [r1, r0, lsl #2]
 446 0008 53F82010 		ldr	r1, [r3, r0, lsl #2]
 447 000c 531A     		subs	r3, r2, r1
 448 000e 00EE103A 		fmsr	s0, r3	@ int
 114:../Libraries/AQ_Receiver/Receiver.h **** }
 449              		.loc 6 114 0
 450 0012 DFED067A 		flds	s15, .L30+8
 113:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 451              		.loc 6 113 0
 452 0016 B8EEC07A 		fsitos	s14, s0
 453              		.loc 6 114 0
 454 001a 67EE276A 		fmuls	s13, s14, s15
 455 001e 16EE900A 		fmrs	r0, s13
 456              	.LVL32:
 457 0022 7047     		bx	lr
 458              	.L31:
 459              		.align	2
 460              	.L30:
 461 0024 00000000 		.word	.LANCHOR1
 462 0028 00000000 		.word	.LANCHOR3
 463 002c 0BD7A33B 		.word	1000593163
 464              		.cfi_endproc
 465              	.LFE125:
 467              		.section	.text._Z9updatePIDffP7PIDdata,"ax",%progbits
 468              		.align	1
 469              		.global	_Z9updatePIDffP7PIDdata
 470              		.thumb
 471              		.thumb_func
 473              	_Z9updatePIDffP7PIDdata:
 474              	.LFB126:
 475              		.file 7 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** #ifndef _AQ_PID_H_
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** #define _AQ_PID_H_
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** enum {
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   RATE_XAXIS_PID_IDX = 0,
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   RATE_YAXIS_PID_IDX,
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ZAXIS_PID_IDX,
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_XAXIS_PID_IDX,
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_YAXIS_PID_IDX,
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   HEADING_HOLD_PID_IDX,
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_GYRO_XAXIS_PID_IDX,
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   ATTITUDE_GYRO_YAXIS_PID_IDX,
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     BARO_ALTITUDE_HOLD_PID_IDX,
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     ZDAMPENING_PID_IDX,
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     THROTTLE_ALTITUDE_HOLD_PID_IDX,
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #endif
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #if defined AltitudeHoldRangeFinder
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     SONAR_ALTITUDE_HOLD_PID_IDX,
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   #endif
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   //#if defined UseGPSNavigator
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     GPSPITCH_PID_IDX,
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     GPSROLL_PID_IDX,
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     GPSYAW_PID_IDX,
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****  // #endif
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   LAST_PID_IDX  // keep this definition at the end of this enum
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** };
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** //// PID Variables
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** struct PIDdata {
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float P, I, D;
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float lastError;
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   // AKA experiments with PID
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float previousPIDTime;
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float integratedError;
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float windupGuard; // Thinking about having individual wind up guards for each PID
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** } PID[LAST_PID_IDX];
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // This struct above declares the variable PID[] to hold each of the PID values for various functio
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // The following constants are declared in AeroQuad.h
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ROLL = 0, PITCH = 1, YAW = 2 (used for Arcobatic Mode, gyros only)
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ROLLLEVEL = 3, PITCHLEVEL = 4, LEVELGYROROLL = 6, LEVELGYROPITCH = 7 (used for Stable Mode, acce
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // HEADING = 5 (used for heading hold)
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ALTITUDE = 8 (used for altitude hold)
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** // ZDAMPENING = 9 (used in altitude hold to dampen vertical accelerations)
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** float windupGuard; // Read in from EEPROM
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** //// Modified from http://www.arduino.cc/playground/Main/BarebonesPIDForEspresso
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 476              		.loc 7 68 0
 477              		.cfi_startproc
 478              		@ args = 0, pretend = 0, frame = 0
 479              		@ frame_needed = 0, uses_anonymous_args = 0
 480              		@ link register save eliminated.
 481              	.LVL33:
 482              	.LBB20:
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   // AKA PID experiments
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 483              		.loc 7 71 0
 484 0000 2A4B     		ldr	r3, .L39
 485              	.LBE20:
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 486              		.loc 7 68 0
 487 0002 07EE101A 		fmsr	s14, r1
 488              	.LBB21:
 489              		.loc 7 71 0
 490 0006 1968     		ldr	r1, [r3, #0]
 491              	.LVL34:
 492 0008 01EE101A 		fmsr	s2, r1	@ int
 493 000c D2ED040A 		flds	s1, [r2, #16]
 494 0010 B8EE410A 		fuitos	s0, s2
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float error = targetPosition - currentPosition;
 495              		.loc 7 74 0
 496 0014 07EE900A 		fmsr	s15, r0
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   if (inFlight) {
 497              		.loc 7 76 0
 498 0018 2548     		ldr	r0, .L39+4
 499              	.LVL35:
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 500              		.loc 7 71 0
 501 001a 30EE606A 		fsubs	s12, s0, s1
 502 001e DFED256A 		flds	s13, .L39+8
 503              		.loc 7 76 0
 504 0022 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 505              		.loc 7 71 0
 506 0024 86EE265A 		fdivs	s10, s12, s13
 507              	.LVL36:
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
 508              		.loc 7 73 0
 509 0028 82ED040A 		fsts	s0, [r2, #16]
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float error = targetPosition - currentPosition;
 510              		.loc 7 74 0
 511 002c 77EEC75A 		fsubs	s11, s15, s14
 512              	.LVL37:
 513              		.loc 7 76 0
 514 0030 33B1     		cbz	r3, .L33
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PIDparameters->integratedError += error * deltaPIDTime;
 515              		.loc 7 77 0
 516 0032 D2ED051A 		flds	s3, [r2, #20]
 517 0036 45EE851A 		fmacs	s3, s11, s10
 518 003a C2ED051A 		fsts	s3, [r2, #20]
 519 003e 01E0     		b	.L34
 520              	.L33:
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   }
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   else {
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PIDparameters->integratedError = 0.0;
 521              		.loc 7 80 0
 522 0040 0020     		movs	r0, #0
 523 0042 5061     		str	r0, [r2, #20]	@ float
 524              	.L34:
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   }
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 525              		.loc 7 82 0
 526 0044 D2ED066A 		flds	s13, [r2, #24]
 527 0048 92ED056A 		flds	s12, [r2, #20]
 528 004c F1EE667A 		fnegs	s15, s13
 529              	.LVL38:
 530 0050 B4EEE76A 		fcmpes	s12, s15
 531 0054 F1EE10FA 		fmstat
 532 0058 08D4     		bmi	.L35
 533              		.loc 7 82 0 is_stmt 0 discriminator 2
 534 005a B4EE666A 		fcmps	s12, s13
 535 005e F1EE10FA 		fmstat
 536 0062 CCBF     		ite	gt
 537 0064 F0EE667A 		fcpysgt	s15, s13
 538 0068 F0EE467A 		fcpysle	s15, s12
 539              	.L35:
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 540              		.loc 7 83 0 is_stmt 1 discriminator 6
 541 006c D2ED034A 		flds	s9, [r2, #12]
 542 0070 92ED024A 		flds	s8, [r2, #8]
 543 0074 77EE643A 		fsubs	s7, s14, s9
 544 0078 DFED0F2A 		flds	s5, .L39+12
 545 007c 63EE843A 		fmuls	s7, s7, s8
 546 0080 65EE222A 		fmuls	s5, s10, s5
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->lastError = currentPosition;
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   return (PIDparameters->P * error) + (PIDparameters->I * PIDparameters->integratedError) + dTerm;
 547              		.loc 7 86 0 discriminator 6
 548 0084 92ED013A 		flds	s6, [r2, #4]
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 549              		.loc 7 83 0 discriminator 6
 550 0088 C3EEA22A 		fdivs	s5, s7, s5
 551              	.LVL39:
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->lastError = currentPosition;
 552              		.loc 7 84 0 discriminator 6
 553 008c 82ED037A 		fsts	s14, [r2, #12]
 554              		.loc 7 86 0 discriminator 6
 555 0090 92ED007A 		flds	s14, [r2, #0]
 556              	.LVL40:
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   PIDparameters->integratedError = constrain(PIDparameters->integratedError, -PIDparameters->windup
 557              		.loc 7 82 0 discriminator 6
 558 0094 C2ED057A 		fsts	s15, [r2, #20]
 559              		.loc 7 86 0 discriminator 6
 560 0098 67EE837A 		fmuls	s15, s15, s6
 561 009c 45EE877A 		fmacs	s15, s11, s14
 562              	.LBE21:
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** }
 563              		.loc 7 87 0 discriminator 6
 564 00a0 37EEA22A 		fadds	s4, s15, s5
 565 00a4 12EE100A 		fmrs	r0, s4
 566 00a8 7047     		bx	lr
 567              	.L40:
 568 00aa 00BF     		.align	2
 569              	.L39:
 570 00ac 00000000 		.word	.LANCHOR7
 571 00b0 00000000 		.word	.LANCHOR8
 572 00b4 00247449 		.word	1232348160
 573 00b8 0000C842 		.word	1120403456
 574              		.cfi_endproc
 575              	.LFE126:
 577              		.section	.text._Z17zeroIntegralErrorv,"ax",%progbits
 578              		.align	1
 579              		.global	_Z17zeroIntegralErrorv
 580              		.thumb
 581              		.thumb_func
 583              	_Z17zeroIntegralErrorv:
 584              	.LFB127:
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** 
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** void zeroIntegralError() __attribute__ ((noinline));
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** void zeroIntegralError() {
 585              		.loc 7 90 0
 586              		.cfi_startproc
 587              		@ args = 0, pretend = 0, frame = 0
 588              		@ frame_needed = 0, uses_anonymous_args = 0
 589              		@ link register save eliminated.
 590              	.LVL41:
 591              	.LBB22:
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   for (byte axis = 0; axis <= ATTITUDE_YAXIS_PID_IDX; axis++) {
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].previousPIDTime = currentTime;
 592              		.loc 7 93 0
 593 0000 0C49     		ldr	r1, .L42
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 594              		.loc 7 92 0
 595 0002 0D4B     		ldr	r3, .L42+4
 596              		.loc 7 93 0
 597 0004 0868     		ldr	r0, [r1, #0]
 598 0006 07EE100A 		fmsr	s14, r0	@ int
 599 000a F8EE477A 		fuitos	s15, s14
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 600              		.loc 7 92 0
 601 000e 0022     		movs	r2, #0
 602 0010 5A61     		str	r2, [r3, #20]	@ float
 603              		.loc 7 93 0
 604 0012 C3ED047A 		fsts	s15, [r3, #16]
 605              	.LVL42:
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 606              		.loc 7 92 0
 607 0016 1A63     		str	r2, [r3, #48]	@ float
 608              		.loc 7 93 0
 609 0018 C3ED0B7A 		fsts	s15, [r3, #44]
 610              	.LVL43:
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 611              		.loc 7 92 0
 612 001c DA64     		str	r2, [r3, #76]	@ float
 613              		.loc 7 93 0
 614 001e C3ED127A 		fsts	s15, [r3, #72]
 615              	.LVL44:
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 616              		.loc 7 92 0
 617 0022 9A66     		str	r2, [r3, #104]	@ float
 618              		.loc 7 93 0
 619 0024 C3ED197A 		fsts	s15, [r3, #100]
 620              	.LVL45:
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****     PID[axis].integratedError = 0;
 621              		.loc 7 92 0
 622 0028 C3F88420 		str	r2, [r3, #132]	@ float
 623              		.loc 7 93 0
 624 002c C3ED207A 		fsts	s15, [r3, #128]
 625              	.LVL46:
 626              	.LBE22:
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h ****   }
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PID.h **** }
 627              		.loc 7 95 0
 628 0030 7047     		bx	lr
 629              	.L43:
 630 0032 00BF     		.align	2
 631              	.L42:
 632 0034 00000000 		.word	.LANCHOR7
 633 0038 00000000 		.word	.LANCHOR9
 634              		.cfi_endproc
 635              	.LFE127:
 637              		.section	.text._Z18computeFourthOrderfP15fourthOrderData,"ax",%progbits
 638              		.align	1
 639              		.global	_Z18computeFourthOrderfP15fourthOrderData
 640              		.thumb
 641              		.thumb_func
 643              	_Z18computeFourthOrderfP15fourthOrderData:
 644              	.LFB128:
 645              		.file 8 "../Libraries/AQ_Math/FourtOrderFilter.h"
   1:../Libraries/AQ_Math/FourtOrderFilter.h **** /*
   2:../Libraries/AQ_Math/FourtOrderFilter.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Math/FourtOrderFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Math/FourtOrderFilter.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Math/FourtOrderFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Math/FourtOrderFilter.h ****  
   7:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Math/FourtOrderFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Math/FourtOrderFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Math/FourtOrderFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  12:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Math/FourtOrderFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Math/FourtOrderFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Math/FourtOrderFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  17:../Libraries/AQ_Math/FourtOrderFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Math/FourtOrderFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Math/FourtOrderFilter.h **** */
  20:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  21:../Libraries/AQ_Math/FourtOrderFilter.h **** #ifndef _AQ_FOURTH_ORDER_FILTER_H_
  22:../Libraries/AQ_Math/FourtOrderFilter.h **** #define _AQ_FOURTH_ORDER_FILTER_H_
  23:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  24:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  25:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  26:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  27:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  28:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  29:../Libraries/AQ_Math/FourtOrderFilter.h **** #include <GlobalDefined.h>
  30:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  31:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  32:../Libraries/AQ_Math/FourtOrderFilter.h **** struct fourthOrderData
  33:../Libraries/AQ_Math/FourtOrderFilter.h **** {
  34:../Libraries/AQ_Math/FourtOrderFilter.h ****   float  inputTm1,  inputTm2,  inputTm3,  inputTm4;
  35:../Libraries/AQ_Math/FourtOrderFilter.h ****   float outputTm1, outputTm2, outputTm3, outputTm4;
  36:../Libraries/AQ_Math/FourtOrderFilter.h **** } fourthOrder[4];
  37:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  38:../Libraries/AQ_Math/FourtOrderFilter.h **** float computeFourthOrder(float currentInput, struct fourthOrderData *filterParameters)
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 646              		.loc 8 39 0
 647              		.cfi_startproc
 648              		@ args = 0, pretend = 0, frame = 0
 649              		@ frame_needed = 0, uses_anonymous_args = 0
 650              		@ link register save eliminated.
 651              	.LVL47:
 652              	.LBB23:
  40:../Libraries/AQ_Math/FourtOrderFilter.h ****   // cheby2(4,60,12.5/50)
  41:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b0  0.001893594048567
  42:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b1 -0.002220262954039
  43:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b2  0.003389066536478
  44:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b3 -0.002220262954039
  45:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b4  0.001893594048567
  46:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  47:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a1 -3.362256889209355
  48:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a2  4.282608240117919
  49:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a3 -2.444765517272841
  50:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a4  0.527149895089809
  51:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  52:../Libraries/AQ_Math/FourtOrderFilter.h ****   float output;
  53:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  54:../Libraries/AQ_Math/FourtOrderFilter.h ****   output = _b0 * currentInput                + 
  55:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b1 * filterParameters->inputTm1  + 
  56:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b2 * filterParameters->inputTm2  +
  57:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b3 * filterParameters->inputTm3  +
  58:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b4 * filterParameters->inputTm4  -
  59:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a1 * filterParameters->outputTm1 -
  60:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a2 * filterParameters->outputTm2 -
  61:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a3 * filterParameters->outputTm3 -
  62:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a4 * filterParameters->outputTm4;
 653              		.loc 8 62 0
 654 0000 91ED005A 		flds	s10, [r1, #0]
 655 0004 9FED203A 		flds	s6, .L45
 656              	.LBE23:
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 657              		.loc 8 39 0
 658 0008 05EE900A 		fmsr	s11, r0
 659              	.LBB24:
 660              		.loc 8 62 0
 661 000c 9FED1F2A 		flds	s4, .L45+4
 662 0010 65EE037A 		fmuls	s15, s10, s6
 663 0014 45EE827A 		fmacs	s15, s11, s4
 664 0018 D1ED014A 		flds	s9, [r1, #4]
 665 001c DFED1C2A 		flds	s5, .L45+8
 666 0020 44EEA27A 		fmacs	s15, s9, s5
 667 0024 91ED024A 		flds	s8, [r1, #8]
 668 0028 44EE037A 		fmacs	s15, s8, s6
 669 002c D1ED031A 		flds	s3, [r1, #12]
 670 0030 41EE827A 		fmacs	s15, s3, s4
 671 0034 91ED047A 		flds	s14, [r1, #16]
 672 0038 9FED161A 		flds	s2, .L45+12
 673 003c 47EE017A 		fmacs	s15, s14, s2
 674 0040 D1ED056A 		flds	s13, [r1, #20]
 675 0044 DFED140A 		flds	s1, .L45+16
 676 0048 46EEE07A 		fnmacs	s15, s13, s1
 677 004c 91ED066A 		flds	s12, [r1, #24]
 678 0050 9FED120A 		flds	s0, .L45+20
 679 0054 46EE007A 		fmacs	s15, s12, s0
 680 0058 91ED073A 		flds	s6, [r1, #28]
 681 005c DFED103A 		flds	s7, .L45+24
 682 0060 43EE637A 		fnmacs	s15, s6, s7
 683              	.LVL48:
  63:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
  67:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm1 = currentInput;
 684              		.loc 8 67 0
 685 0064 0860     		str	r0, [r1, #0]	@ float
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
 686              		.loc 8 64 0
 687 0066 81ED034A 		fsts	s8, [r1, #12]
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
 688              		.loc 8 65 0
 689 006a C1ED024A 		fsts	s9, [r1, #8]
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
 690              		.loc 8 66 0
 691 006e 81ED015A 		fsts	s10, [r1, #4]
  68:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  69:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm4 = filterParameters->outputTm3;
 692              		.loc 8 69 0
 693 0072 81ED076A 		fsts	s12, [r1, #28]
  70:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm3 = filterParameters->outputTm2;
 694              		.loc 8 70 0
 695 0076 C1ED066A 		fsts	s13, [r1, #24]
  71:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm2 = filterParameters->outputTm1;
 696              		.loc 8 71 0
 697 007a 81ED057A 		fsts	s14, [r1, #20]
  72:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm1 = output;
 698              		.loc 8 72 0
 699 007e C1ED047A 		fsts	s15, [r1, #16]
 700              	.LBE24:
  73:../Libraries/AQ_Math/FourtOrderFilter.h ****     
  74:../Libraries/AQ_Math/FourtOrderFilter.h ****   return output;
  75:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 701              		.loc 8 75 0
 702 0082 17EE900A 		fmrs	r0, s15
 703              	.LVL49:
 704 0086 7047     		bx	lr
 705              	.L46:
 706              		.align	2
 707              	.L45:
 708 0088 D58111BB 		.word	-1156480555
 709 008c 7932F83A 		.word	989344377
 710 0090 1A1B5E3B 		.word	996023066
 711 0094 382F5740 		.word	1079455544
 712 0098 200B8940 		.word	1082723104
 713 009c 0A771C40 		.word	1075607306
 714 00a0 4CF3063F 		.word	1057420108
 715              		.cfi_endproc
 716              	.LFE128:
 718              		.section	.text._Z16setupFourthOrderv,"ax",%progbits
 719              		.align	1
 720              		.global	_Z16setupFourthOrderv
 721              		.thumb
 722              		.thumb_func
 724              	_Z16setupFourthOrderv:
 725              	.LFB129:
  76:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  77:../Libraries/AQ_Math/FourtOrderFilter.h **** void setupFourthOrder(void)
  78:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 726              		.loc 8 78 0
 727              		.cfi_startproc
 728              		@ args = 0, pretend = 0, frame = 0
 729              		@ frame_needed = 0, uses_anonymous_args = 0
 730              		@ link register save eliminated.
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 731              		.loc 8 79 0
 732 0000 0D4B     		ldr	r3, .L48
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
  83:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
  88:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  89:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
  94:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
  99:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 100:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
 101:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm1 = -9.8065;
 733              		.loc 8 101 0
 734 0002 0E4A     		ldr	r2, .L48+4
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 735              		.loc 8 79 0
 736 0004 0020     		movs	r0, #0
 737 0006 1860     		str	r0, [r3, #0]	@ float
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
 738              		.loc 8 80 0
 739 0008 5860     		str	r0, [r3, #4]	@ float
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
 740              		.loc 8 81 0
 741 000a 9860     		str	r0, [r3, #8]	@ float
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
 742              		.loc 8 82 0
 743 000c D860     		str	r0, [r3, #12]	@ float
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
 744              		.loc 8 84 0
 745 000e 1861     		str	r0, [r3, #16]	@ float
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
 746              		.loc 8 85 0
 747 0010 5861     		str	r0, [r3, #20]	@ float
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
 748              		.loc 8 86 0
 749 0012 9861     		str	r0, [r3, #24]	@ float
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
 750              		.loc 8 87 0
 751 0014 D861     		str	r0, [r3, #28]	@ float
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
 752              		.loc 8 90 0
 753 0016 1862     		str	r0, [r3, #32]	@ float
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
 754              		.loc 8 91 0
 755 0018 5862     		str	r0, [r3, #36]	@ float
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
 756              		.loc 8 92 0
 757 001a 9862     		str	r0, [r3, #40]	@ float
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
 758              		.loc 8 93 0
 759 001c D862     		str	r0, [r3, #44]	@ float
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
 760              		.loc 8 95 0
 761 001e 1863     		str	r0, [r3, #48]	@ float
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
 762              		.loc 8 96 0
 763 0020 5863     		str	r0, [r3, #52]	@ float
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
 764              		.loc 8 97 0
 765 0022 9863     		str	r0, [r3, #56]	@ float
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
 766              		.loc 8 98 0
 767 0024 D863     		str	r0, [r3, #60]	@ float
 768              		.loc 8 101 0
 769 0026 1A64     		str	r2, [r3, #64]	@ float
 102:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm2 = -9.8065;
 770              		.loc 8 102 0
 771 0028 5A64     		str	r2, [r3, #68]	@ float
 103:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm3 = -9.8065;
 772              		.loc 8 103 0
 773 002a 9A64     		str	r2, [r3, #72]	@ float
 104:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm4 = -9.8065;
 774              		.loc 8 104 0
 775 002c DA64     		str	r2, [r3, #76]	@ float
 105:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 106:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm1 = -9.8065;
 776              		.loc 8 106 0
 777 002e 1A65     		str	r2, [r3, #80]	@ float
 107:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm2 = -9.8065;
 778              		.loc 8 107 0
 779 0030 5A65     		str	r2, [r3, #84]	@ float
 108:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm3 = -9.8065;
 780              		.loc 8 108 0
 781 0032 9A65     		str	r2, [r3, #88]	@ float
 109:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm4 = -9.8065;
 782              		.loc 8 109 0
 783 0034 DA65     		str	r2, [r3, #92]	@ float
 110:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 784              		.loc 8 110 0
 785 0036 7047     		bx	lr
 786              	.L49:
 787              		.align	2
 788              	.L48:
 789 0038 00000000 		.word	.LANCHOR10
 790 003c 6DE71CC1 		.word	-1055070355
 791              		.cfi_endproc
 792              	.LFE129:
 794              		.section	.text._ZN14HardwareSPIExt5SetCSEi,"axG",%progbits,_ZN14HardwareSPIExt5SetCSEi,comdat
 795              		.align	1
 796              		.weak	_ZN14HardwareSPIExt5SetCSEi
 797              		.thumb
 798              		.thumb_func
 800              	_ZN14HardwareSPIExt5SetCSEi:
 801              	.LFB133:
 802              		.file 9 "../Libraries/AQ_SPI/HardwareSPIExt.h"
   1:../Libraries/AQ_SPI/HardwareSPIExt.h **** #ifndef _AEROQUAD_SPI_HARDWARESPIEXT_H_
   2:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define _AEROQUAD_SPI_HARDWARESPIEXT_H_
   3:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   4:../Libraries/AQ_SPI/HardwareSPIExt.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   6:../Libraries/AQ_SPI/HardwareSPIExt.h **** // helper class to extend the maple HardwareSPI class
   7:../Libraries/AQ_SPI/HardwareSPIExt.h **** // used by the MPU6000 library
   8:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   9:../Libraries/AQ_SPI/HardwareSPIExt.h **** #include <HardwareSPI.h>
  10:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  11:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_READ_FLAG  0x80
  12:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_MULTI_FLAG 0x40
  13:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SetPin digitalWrite
  14:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  15:../Libraries/AQ_SPI/HardwareSPIExt.h **** class HardwareSPIExt : public HardwareSPI {
  16:../Libraries/AQ_SPI/HardwareSPIExt.h **** public:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  21:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  22:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetCS(int aCS)
 803              		.loc 9 22 0
 804              		.cfi_startproc
 805              		@ args = 0, pretend = 0, frame = 0
 806              		@ frame_needed = 0, uses_anonymous_args = 0
 807              		@ link register save eliminated.
 808              	.LVL50:
  23:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  24:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fCS = aCS;
 809              		.loc 9 24 0
 810 0000 4160     		str	r1, [r0, #4]
  25:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 811              		.loc 9 25 0
 812 0002 7047     		bx	lr
 813              		.cfi_endproc
 814              	.LFE133:
 816              		.section	.text._ZN14HardwareSPIExtC2Ej,"axG",%progbits,_ZN14HardwareSPIExtC5Ej,comdat
 817              		.align	1
 818              		.weak	_ZN14HardwareSPIExtC2Ej
 819              		.thumb
 820              		.thumb_func
 822              	_ZN14HardwareSPIExtC2Ej:
 823              	.LFB131:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 824              		.loc 9 17 0
 825              		.cfi_startproc
 826              		@ args = 0, pretend = 0, frame = 0
 827              		@ frame_needed = 0, uses_anonymous_args = 0
 828              	.LVL51:
 829 0000 10B5     		push	{r4, lr}
 830              	.LCFI1:
 831              		.cfi_def_cfa_offset 8
 832              		.cfi_offset 14, -4
 833              		.cfi_offset 4, -8
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 834              		.loc 9 17 0
 835 0002 0446     		mov	r4, r0
 836              	.LBB25:
 837 0004 FFF7FEFF 		bl	_ZN11HardwareSPIC2Ej
 838              	.LVL52:
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
 839              		.loc 9 18 0
 840 0008 2046     		mov	r0, r4
 841 000a FFF7FEFF 		bl	_ZN11HardwareSPI6nssPinEv
 842 000e 0146     		mov	r1, r0
 843 0010 2046     		mov	r0, r4
 844 0012 FFF7FEFF 		bl	_ZN14HardwareSPIExt5SetCSEi
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
 845              		.loc 9 19 0
 846 0016 0023     		movs	r3, #0
 847 0018 2372     		strb	r3, [r4, #8]
 848              	.LBE25:
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 849              		.loc 9 20 0
 850 001a 2046     		mov	r0, r4
 851 001c 10BD     		pop	{r4, pc}
 852              		.cfi_endproc
 853              	.LFE131:
 855              		.section	.text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj,"axG",%progbits,_ZN14HardwareSPIExt5begi
 856              		.align	1
 857              		.weak	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 858              		.thumb
 859              		.thumb_func
 861              	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj:
 862              	.LFB135:
  26:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  27:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetMultiFlag() {
  28:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = SPI_MULTI_FLAG;
  29:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  30:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 863              		.loc 9 31 0
 864              		.cfi_startproc
 865              		@ args = 0, pretend = 0, frame = 0
 866              		@ frame_needed = 0, uses_anonymous_args = 0
 867              	.LVL53:
 868 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 869              	.LCFI2:
 870              		.cfi_def_cfa_offset 24
 871              		.cfi_offset 14, -4
 872              		.cfi_offset 8, -8
 873              		.cfi_offset 7, -12
 874              		.cfi_offset 6, -16
 875              		.cfi_offset 5, -20
 876              		.cfi_offset 4, -24
 877              		.loc 9 31 0
 878 0004 0446     		mov	r4, r0
 879 0006 0D46     		mov	r5, r1
  32:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 880              		.loc 9 33 0
 881 0008 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 882              	.LVL54:
 883 000a 0121     		movs	r1, #1
 884              	.LVL55:
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
 885              		.loc 9 31 0
 886 000c 1746     		mov	r7, r2
 887 000e 1E46     		mov	r6, r3
 888              		.loc 9 33 0
 889 0010 FFF7FEFF 		bl	_Z12digitalWritehh
 890              	.LVL56:
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
 891              		.loc 9 34 0
 892 0014 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 893 0016 0021     		movs	r1, #0
 894 0018 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
  35:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 895              		.loc 9 36 0
 896 001c 2046     		mov	r0, r4
 897 001e 2946     		mov	r1, r5
 898 0020 3A46     		mov	r2, r7
 899 0022 3346     		mov	r3, r6
  37:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 900              		.loc 9 37 0
 901 0024 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 902              		.loc 9 36 0
 903 0028 FFF7FEBF 		b	_ZN11HardwareSPI5beginE12SPIFrequencyjj
 904              		.cfi_endproc
 905              	.LFE135:
 907              		.section	.text._ZN14HardwareSPIExt4ReadEiPhi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEiPhi,comdat
 908              		.align	1
 909              		.weak	_ZN14HardwareSPIExt4ReadEiPhi
 910              		.thumb
 911              		.thumb_func
 913              	_ZN14HardwareSPIExt4ReadEiPhi:
 914              	.LFB136:
  38:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 915              		.loc 9 39 0
 916              		.cfi_startproc
 917              		@ args = 0, pretend = 0, frame = 0
 918              		@ frame_needed = 0, uses_anonymous_args = 0
 919              	.LVL57:
 920 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 921              	.LCFI3:
 922              		.cfi_def_cfa_offset 24
 923              		.cfi_offset 14, -4
 924              		.cfi_offset 7, -8
 925              		.cfi_offset 6, -12
 926              		.cfi_offset 5, -16
 927              		.cfi_offset 4, -20
 928              		.cfi_offset 3, -24
 929              		.loc 9 39 0
 930 0002 0446     		mov	r4, r0
 931 0004 0D46     		mov	r5, r1
  40:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  41:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 932              		.loc 9 41 0
 933 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 934              	.LVL58:
 935 0008 0021     		movs	r1, #0
 936              	.LVL59:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 937              		.loc 9 39 0
 938 000a 1F46     		mov	r7, r3
 939 000c 1646     		mov	r6, r2
 940              		.loc 9 41 0
 941 000e FFF7FEFF 		bl	_Z12digitalWritehh
 942              	.LVL60:
  42:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | SPI_READ_FLAG | fSpiMultiFlag);
 943              		.loc 9 42 0
 944 0012 207A     		ldrb	r0, [r4, #8]	@ zero_extendqisi2
 945 0014 60F07F03 		orn	r3, r0, #127
 946 0018 1D43     		orrs	r5, r5, r3
 947              	.LVL61:
 948 001a E9B2     		uxtb	r1, r5
 949 001c 2046     		mov	r0, r4
 950 001e FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 951 0022 3D46     		mov	r5, r7
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 952              		.loc 9 43 0
 953 0024 06E0     		b	.L55
 954              	.LVL62:
 955              	.L56:
  44:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			*data++ = transfer(0);
 956              		.loc 9 44 0
 957 0026 2046     		mov	r0, r4
 958 0028 0021     		movs	r1, #0
 959 002a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 960 002e 06F8010B 		strb	r0, [r6], #1
 961              	.LVL63:
 962 0032 013D     		subs	r5, r5, #1
 963              	.L55:
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 964              		.loc 9 43 0 discriminator 1
 965 0034 002D     		cmp	r5, #0
 966 0036 F6DC     		bgt	.L56
  45:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 967              		.loc 9 46 0
 968 0038 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 969 003a 0121     		movs	r1, #1
  47:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 970              		.loc 9 47 0
 971 003c BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 972              		.loc 9 46 0
 973 0040 FFF7FEBF 		b	_Z12digitalWritehh
 974              		.cfi_endproc
 975              	.LFE136:
 977              		.section	.text._ZN14HardwareSPIExt4ReadEi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEi,comdat
 978              		.align	1
 979              		.weak	_ZN14HardwareSPIExt4ReadEi
 980              		.thumb
 981              		.thumb_func
 983              	_ZN14HardwareSPIExt4ReadEi:
 984              	.LFB137:
  48:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  49:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	unsigned char Read(int addr)
 985              		.loc 9 49 0
 986              		.cfi_startproc
 987              		@ args = 0, pretend = 0, frame = 8
 988              		@ frame_needed = 0, uses_anonymous_args = 0
 989              	.LVL64:
 990 0000 07B5     		push	{r0, r1, r2, lr}
 991              	.LCFI4:
 992              		.cfi_def_cfa_offset 16
 993              		.cfi_offset 14, -4
 994              		.cfi_offset 2, -8
 995              		.cfi_offset 1, -12
 996              		.cfi_offset 0, -16
 997              	.LBB26:
  50:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  51:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		unsigned char data;
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
 998              		.loc 9 52 0
 999 0002 0123     		movs	r3, #1
 1000 0004 0DF10702 		add	r2, sp, #7
 1001 0008 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 1002              	.LVL65:
 1003              	.LBE26:
  53:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  54:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		return data;
  55:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1004              		.loc 9 55 0
 1005 000c 9DF80700 		ldrb	r0, [sp, #7]	@ zero_extendqisi2
 1006 0010 0EBD     		pop	{r1, r2, r3, pc}
 1007              		.cfi_endproc
 1008              	.LFE137:
 1010              		.section	.text._ZN14HardwareSPIExt5WriteEiPhi,"axG",%progbits,_ZN14HardwareSPIExt5WriteEiPhi,comda
 1011              		.align	1
 1012              		.weak	_ZN14HardwareSPIExt5WriteEiPhi
 1013              		.thumb
 1014              		.thumb_func
 1016              	_ZN14HardwareSPIExt5WriteEiPhi:
 1017              	.LFB138:
  56:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1018              		.loc 9 57 0
 1019              		.cfi_startproc
 1020              		@ args = 0, pretend = 0, frame = 0
 1021              		@ frame_needed = 0, uses_anonymous_args = 0
 1022              	.LVL66:
 1023 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1024              	.LCFI5:
 1025              		.cfi_def_cfa_offset 24
 1026              		.cfi_offset 14, -4
 1027              		.cfi_offset 7, -8
 1028              		.cfi_offset 6, -12
 1029              		.cfi_offset 5, -16
 1030              		.cfi_offset 4, -20
 1031              		.cfi_offset 3, -24
 1032              		.loc 9 57 0
 1033 0002 0446     		mov	r4, r0
 1034 0004 0D46     		mov	r5, r1
  58:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  59:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1035              		.loc 9 59 0
 1036 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 1037              	.LVL67:
 1038 0008 0021     		movs	r1, #0
 1039              	.LVL68:
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
 1040              		.loc 9 57 0
 1041 000a 1F46     		mov	r7, r3
 1042 000c 1646     		mov	r6, r2
 1043              		.loc 9 59 0
 1044 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1045              	.LVL69:
  60:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | fSpiMultiFlag);
 1046              		.loc 9 60 0
 1047 0012 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 1048 0014 1D43     		orrs	r5, r5, r3
 1049              	.LVL70:
 1050 0016 E9B2     		uxtb	r1, r5
 1051 0018 2046     		mov	r0, r4
 1052 001a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1053 001e 3D46     		mov	r5, r7
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1054              		.loc 9 61 0
 1055 0020 05E0     		b	.L59
 1056              	.LVL71:
 1057              	.L60:
  62:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			transfer(*data++);
 1058              		.loc 9 62 0
 1059 0022 2046     		mov	r0, r4
 1060 0024 16F8011B 		ldrb	r1, [r6], #1	@ zero_extendqisi2
 1061              	.LVL72:
 1062 0028 FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1063 002c 013D     		subs	r5, r5, #1
 1064              	.LVL73:
 1065              	.L59:
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 1066              		.loc 9 61 0 discriminator 1
 1067 002e 002D     		cmp	r5, #0
 1068 0030 F7DC     		bgt	.L60
  63:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1069              		.loc 9 64 0
 1070 0032 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1071 0034 0121     		movs	r1, #1
  65:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1072              		.loc 9 65 0
 1073 0036 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1074              		.loc 9 64 0
 1075 003a FFF7FEBF 		b	_Z12digitalWritehh
 1076              		.cfi_endproc
 1077              	.LFE138:
 1079              		.section	.text._ZN14HardwareSPIExt5WriteEih,"axG",%progbits,_ZN14HardwareSPIExt5WriteEih,comdat
 1080              		.align	1
 1081              		.weak	_ZN14HardwareSPIExt5WriteEih
 1082              		.thumb
 1083              		.thumb_func
 1085              	_ZN14HardwareSPIExt5WriteEih:
 1086              	.LFB139:
  66:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  67:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char data)
 1087              		.loc 9 67 0
 1088              		.cfi_startproc
 1089              		@ args = 0, pretend = 0, frame = 8
 1090              		@ frame_needed = 0, uses_anonymous_args = 0
 1091              	.LVL74:
 1092 0000 07B5     		push	{r0, r1, r2, lr}
 1093              	.LCFI6:
 1094              		.cfi_def_cfa_offset 16
 1095              		.cfi_offset 14, -4
 1096              		.cfi_offset 2, -8
 1097              		.cfi_offset 1, -12
 1098              		.cfi_offset 0, -16
 1099              	.LVL75:
 1100              		.loc 9 67 0
 1101 0002 02AB     		add	r3, sp, #8
 1102              	.LVL76:
 1103 0004 03F8012D 		strb	r2, [r3, #-1]!
  68:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  69:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Write(addr, &data, 1);
 1104              		.loc 9 69 0
 1105 0008 1A46     		mov	r2, r3
 1106              	.LVL77:
 1107 000a 0123     		movs	r3, #1
 1108 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEiPhi
 1109              	.LVL78:
  70:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1110              		.loc 9 70 0
 1111 0010 0EBD     		pop	{r1, r2, r3, pc}
 1112              		.cfi_endproc
 1113              	.LFE139:
 1115              		.section	.text._Z19MPU6000_SpiLowSpeedv,"ax",%progbits
 1116              		.align	1
 1117              		.global	_Z19MPU6000_SpiLowSpeedv
 1118              		.thumb
 1119              		.thumb_func
 1121              	_Z19MPU6000_SpiLowSpeedv:
 1122              	.LFB140:
 1123              		.file 10 "../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h"
   1:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** /*
   2:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
   7:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  12:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  17:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** */
  20:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  21:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // parts of the init sequence were taken from AP_InertialSensor_MPU6000.h
  22:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  23:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef _AEROQUAD_PLATFORM_MPU6000_H_
  24:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define _AEROQUAD_PLATFORM_MPU6000_H_
  25:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  26:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // I2C support for MPU6000/6050 is not tested yet
  27:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C
  28:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  29:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include "Arduino.h"
  30:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include <SensorsStatus.h>
  31:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  32:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C	// insert this define before #include <Platform_MPU6000.h> when you use a I2C
  33:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  34:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // MPU 6000 registers
  35:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_WHOAMI			0x75
  36:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_SMPLRT_DIV		0x19
  37:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_CONFIG			0x1A
  38:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_CONFIG		0x1B
  39:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_CONFIG		0x1C
  40:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_EN			0x23
  41:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_PIN_CFG		0x37
  42:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_ENABLE		0x38
  43:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_STATUS		0x3A
  44:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_H		0x3B
  45:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_L		0x3C
  46:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_H		0x3D
  47:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_L		0x3E
  48:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_H		0x3F
  49:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_L		0x40
  50:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_H		0x41
  51:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_L		0x42
  52:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_H		0x43
  53:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_L		0x44
  54:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_H		0x45
  55:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_L		0x46
  56:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_H		0x47
  57:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_L		0x48
  58:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_USER_CTRL		0x6A
  59:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_1		0x6B
  60:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_2		0x6C
  61:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTH		0x72
  62:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTL		0x73
  63:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_R_W			0x74
  64:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  65:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  66:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // Configuration bits
  67:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_SLEEP				0x40
  68:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_H_RESET				0x80
  69:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_CLKSEL				0x07
  70:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROX	0x01
  71:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROZ	0x03
  72:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_EXT_SYNC_GYROX		0x02
  73:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_250DPS          0x00
  74:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_500DPS          0x08
  75:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_1000DPS         0x10
  76:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_2000DPS         0x18
  77:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_MASK            0x18
  78:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_256HZ_NOLPF2  0x00
  79:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_188HZ         0x01
  80:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_98HZ          0x02
  81:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_42HZ          0x03
  82:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_20HZ          0x04
  83:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_10HZ          0x05
  84:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_5HZ           0x06
  85:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_2100HZ_NOLPF  0x07
  86:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_MASK          0x07
  87:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_ANYRD_2CLEAR    0x10
  88:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_RAW_RDY_EN			0x01
  89:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_I2C_IF_DIS          0x10
  90:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_STATUS_DATA		0x01
  91:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  92:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  93:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** typedef struct {
  94:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short x;
  95:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short y;
  96:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short z;
  97:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } tAxis;
  98:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  99:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** union uMPU6000 {
 100:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned char rawByte[];
 101:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned short rawWord[];
 102:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   struct {
 103:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	tAxis accel;
 104:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short temperature;
 105:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	tAxis gyro;
 106:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   } data;
 107:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } MPU6000;
 108:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 109:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 110:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 111:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C_ADDRESS
 112:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#define MPU6000_I2C_ADDRESS 0x68
 113:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 114:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 115:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #include <HardwareSPIExt.h>
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   HardwareSPIExt spiMPU6000(4);
 117:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 118:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 119:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiLowSpeed()
 120:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1124              		.loc 10 120 0
 1125              		.cfi_startproc
 1126              		@ args = 0, pretend = 0, frame = 0
 1127              		@ frame_needed = 0, uses_anonymous_args = 0
 1128              		@ link register save eliminated.
 121:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 1129              		.loc 10 122 0
 1130 0000 0248     		ldr	r0, .L63
 1131 0002 0521     		movs	r1, #5
 1132 0004 0122     		movs	r2, #1
 1133 0006 0323     		movs	r3, #3
 123:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 124:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1134              		.loc 10 124 0
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 1135              		.loc 10 122 0
 1136 0008 FFF7FEBF 		b	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 1137              	.L64:
 1138              		.align	2
 1139              	.L63:
 1140 000c 00000000 		.word	.LANCHOR11
 1141              		.cfi_endproc
 1142              	.LFE140:
 1144              		.section	.text._Z20MPU6000_SpiHighSpeedv,"ax",%progbits
 1145              		.align	1
 1146              		.global	_Z20MPU6000_SpiHighSpeedv
 1147              		.thumb
 1148              		.thumb_func
 1150              	_Z20MPU6000_SpiHighSpeedv:
 1151              	.LFB141:
 125:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 126:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiHighSpeed()
 127:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1152              		.loc 10 127 0
 1153              		.cfi_startproc
 1154              		@ args = 0, pretend = 0, frame = 0
 1155              		@ frame_needed = 0, uses_anonymous_args = 0
 1156 0000 10B5     		push	{r4, lr}
 1157              	.LCFI7:
 1158              		.cfi_def_cfa_offset 8
 1159              		.cfi_offset 14, -4
 1160              		.cfi_offset 4, -8
 128:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 129:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.end();
 1161              		.loc 10 129 0
 1162 0002 064C     		ldr	r4, .L66
 1163 0004 2046     		mov	r0, r4
 1164 0006 FFF7FEFF 		bl	_ZN11HardwareSPI3endEv
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 1165              		.loc 10 130 0
 1166 000a 0121     		movs	r1, #1
 1167 000c 2046     		mov	r0, r4
 1168 000e 0A46     		mov	r2, r1
 1169 0010 0323     		movs	r3, #3
 131:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 132:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1170              		.loc 10 132 0
 1171 0012 BDE81040 		pop	{r4, lr}
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 1172              		.loc 10 130 0
 1173 0016 FFF7FEBF 		b	_ZN14HardwareSPIExt5beginE12SPIFrequencyjj
 1174              	.L67:
 1175 001a 00BF     		.align	2
 1176              	.L66:
 1177 001c 00000000 		.word	.LANCHOR11
 1178              		.cfi_endproc
 1179              	.LFE141:
 1181              		.section	.text._Z16MPU6000_WriteRegih,"ax",%progbits
 1182              		.align	1
 1183              		.global	_Z16MPU6000_WriteRegih
 1184              		.thumb
 1185              		.thumb_func
 1187              	_Z16MPU6000_WriteRegih:
 1188              	.LFB142:
 133:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 134:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_WriteReg(int addr, byte data)
 135:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1189              		.loc 10 135 0
 1190              		.cfi_startproc
 1191              		@ args = 0, pretend = 0, frame = 0
 1192              		@ frame_needed = 0, uses_anonymous_args = 0
 1193              	.LVL79:
 1194 0000 08B5     		push	{r3, lr}
 1195              	.LCFI8:
 1196              		.cfi_def_cfa_offset 8
 1197              		.cfi_offset 14, -4
 1198              		.cfi_offset 3, -8
 1199              		.loc 10 135 0
 1200 0002 0346     		mov	r3, r0
 1201 0004 0A46     		mov	r2, r1
 136:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 137:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	updateRegisterI2C(MPU6000_I2C_ADDRESS, addr, data);
 138:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 139:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Write(addr, data);
 1202              		.loc 10 139 0
 1203 0006 0448     		ldr	r0, .L69
 1204              	.LVL80:
 1205 0008 1946     		mov	r1, r3
 1206              	.LVL81:
 1207 000a FFF7FEFF 		bl	_ZN14HardwareSPIExt5WriteEih
 1208              	.LVL82:
 140:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1209              		.loc 10 141 0
 1210 000e 0120     		movs	r0, #1
 142:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1211              		.loc 10 142 0
 1212 0010 BDE80840 		pop	{r3, lr}
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1213              		.loc 10 141 0
 1214 0014 FFF7FEBF 		b	_Z5delaym
 1215              	.L70:
 1216              		.align	2
 1217              	.L69:
 1218 0018 00000000 		.word	.LANCHOR11
 1219              		.cfi_endproc
 1220              	.LFE142:
 1222              		.section	.text._Z15MPU6000_ReadRegi,"ax",%progbits
 1223              		.align	1
 1224              		.global	_Z15MPU6000_ReadRegi
 1225              		.thumb
 1226              		.thumb_func
 1228              	_Z15MPU6000_ReadRegi:
 1229              	.LFB143:
 143:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 144:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** byte MPU6000_ReadReg(int addr)
 145:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1230              		.loc 10 145 0
 1231              		.cfi_startproc
 1232              		@ args = 0, pretend = 0, frame = 0
 1233              		@ frame_needed = 0, uses_anonymous_args = 0
 1234              	.LVL83:
 1235 0000 10B5     		push	{r4, lr}
 1236              	.LCFI9:
 1237              		.cfi_def_cfa_offset 8
 1238              		.cfi_offset 14, -4
 1239              		.cfi_offset 4, -8
 1240              		.loc 10 145 0
 1241 0002 0146     		mov	r1, r0
 1242              	.LBB27:
 146:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 147:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, addr);
 148:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = readByteI2C(MPU6000_I2C_ADDRESS);
 149:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 150:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = spiMPU6000.Read(addr);
 1243              		.loc 10 150 0
 1244 0004 0448     		ldr	r0, .L72
 1245              	.LVL84:
 1246 0006 FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEi
 1247              	.LVL85:
 1248 000a 0446     		mov	r4, r0
 1249              	.LVL86:
 151:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 152:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1250              		.loc 10 152 0
 1251 000c 0120     		movs	r0, #1
 1252              	.LVL87:
 1253 000e FFF7FEFF 		bl	_Z5delaym
 1254              	.LBE27:
 153:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   return data;
 154:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1255              		.loc 10 154 0
 1256 0012 2046     		mov	r0, r4
 1257 0014 10BD     		pop	{r4, pc}
 1258              	.L73:
 1259 0016 00BF     		.align	2
 1260              	.L72:
 1261 0018 00000000 		.word	.LANCHOR11
 1262              		.cfi_endproc
 1263              	.LFE143:
 1265              		.section	.text._Z24initializeMPU6000Sensorsv,"ax",%progbits
 1266              		.align	1
 1267              		.global	_Z24initializeMPU6000Sensorsv
 1268              		.thumb
 1269              		.thumb_func
 1271              	_Z24initializeMPU6000Sensorsv:
 1272              	.LFB144:
 155:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 156:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** bool initializeMPU6000SensorsDone = false;
 157:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void initializeMPU6000Sensors()
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1273              		.loc 10 158 0
 1274              		.cfi_startproc
 1275              		@ args = 0, pretend = 0, frame = 0
 1276              		@ frame_needed = 0, uses_anonymous_args = 0
 1277              	.LBB28:
 159:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if(initializeMPU6000SensorsDone) {
 1278              		.loc 10 159 0
 1279 0000 1E4B     		ldr	r3, .L76
 1280              	.LBE28:
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1281              		.loc 10 158 0
 1282 0002 10B5     		push	{r4, lr}
 1283              	.LCFI10:
 1284              		.cfi_def_cfa_offset 8
 1285              		.cfi_offset 14, -4
 1286              		.cfi_offset 4, -8
 1287              	.LBB29:
 1288              		.loc 10 159 0
 1289 0004 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 1290 0006 002C     		cmp	r4, #0
 1291 0008 36D1     		bne	.L74
 160:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	return;
 161:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 162:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   initializeMPU6000SensorsDone = true;
 1292              		.loc 10 162 0
 1293 000a 0122     		movs	r2, #1
 1294 000c 1A70     		strb	r2, [r3, #0]
 163:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 164:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiLowSpeed();
 1295              		.loc 10 164 0
 1296 000e FFF7FEFF 		bl	_Z19MPU6000_SpiLowSpeedv
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 166:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned char val;
 167:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 168:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   val = MPU6000_ReadReg(MPUREG_WHOAMI);
 1297              		.loc 10 168 0
 1298 0012 7520     		movs	r0, #117
 1299 0014 FFF7FEFF 		bl	_Z15MPU6000_ReadRegi
 1300              	.LVL88:
 169:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if((val&0x7E) == 0x68) {
 1301              		.loc 10 169 0
 1302 0018 00F07E00 		and	r0, r0, #126
 1303              	.LVL89:
 1304 001c 6828     		cmp	r0, #104
 1305 001e 2BD1     		bne	.L74
 170:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= GYRO_DETECTED;
 171:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= ACCEL_DETECTED;
 1306              		.loc 10 171 0
 1307 0020 174B     		ldr	r3, .L76+4
 1308 0022 1868     		ldr	r0, [r3, #0]
 1309 0024 40F00301 		orr	r1, r0, #3
 1310 0028 1960     		str	r1, [r3, #0]
 172:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   } 
 173:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   else {
 174:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	return;
 175:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 176:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 177:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // Chip reset
 178:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
 1311              		.loc 10 178 0
 1312 002a 6B20     		movs	r0, #107
 1313 002c 8021     		movs	r1, #128
 1314 002e FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 179:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(100);  // Startup time delay
 1315              		.loc 10 179 0
 1316 0032 6420     		movs	r0, #100
 1317 0034 FFF7FEFF 		bl	_Z5delaym
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 181:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 182:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Disable I2C bus
 183:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
 1318              		.loc 10 183 0
 1319 0038 6A20     		movs	r0, #106
 1320 003a 1021     		movs	r1, #16
 1321 003c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 184:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 185:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 186:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // Wake Up device and select GyroZ clock (better performance)
 187:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
 1322              		.loc 10 187 0
 1323 0040 6B20     		movs	r0, #107
 1324 0042 0321     		movs	r1, #3
 1325 0044 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 188:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_2, 0);
 1326              		.loc 10 188 0
 1327 0048 6C20     		movs	r0, #108
 1328 004a 2146     		mov	r1, r4
 1329 004c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 189:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 190:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // SAMPLE RATE
 191:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_SMPLRT_DIV,0x00);     // Sample rate = 1kHz
 1330              		.loc 10 191 0
 1331 0050 1920     		movs	r0, #25
 1332 0052 2146     		mov	r1, r4
 1333 0054 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 192:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 193:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // FS & DLPF   FS=1000/s, DLPF = 42Hz (low pass filter)
 194:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_CONFIG, BITS_DLPF_CFG_42HZ);
 1334              		.loc 10 194 0
 1335 0058 1A20     		movs	r0, #26
 1336 005a 0321     		movs	r1, #3
 1337 005c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 195:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_GYRO_CONFIG,BITS_FS_1000DPS);  // Gyro scale 1000/s
 1338              		.loc 10 195 0
 1339 0060 1B20     		movs	r0, #27
 1340 0062 1021     		movs	r1, #16
 1341 0064 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 196:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_ACCEL_CONFIG,0x08);   // Accel scale +-4g (4096LSB/g)
 1342              		.loc 10 196 0
 1343 0068 1C20     		movs	r0, #28
 1344 006a 0821     		movs	r1, #8
 1345 006c FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1346              	.LBE29:
 197:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 198:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 199:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // switch to high clock rate
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiHighSpeed();
 201:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1347              		.loc 10 201 0
 1348 0070 BDE81040 		pop	{r4, lr}
 1349              	.LBB30:
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiHighSpeed();
 1350              		.loc 10 200 0
 1351 0074 FFF7FEBF 		b	_Z20MPU6000_SpiHighSpeedv
 1352              	.L74:
 1353 0078 10BD     		pop	{r4, pc}
 1354              	.L77:
 1355 007a 00BF     		.align	2
 1356              	.L76:
 1357 007c 00000000 		.word	.LANCHOR12
 1358 0080 00000000 		.word	.LANCHOR13
 1359              	.LBE30:
 1360              		.cfi_endproc
 1361              	.LFE144:
 1363              		.section	.text._Z15MPU6000SwapDataPhi,"ax",%progbits
 1364              		.align	1
 1365              		.global	_Z15MPU6000SwapDataPhi
 1366              		.thumb
 1367              		.thumb_func
 1369              	_Z15MPU6000SwapDataPhi:
 1370              	.LFB145:
 202:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 203:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 204:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000SwapData(unsigned char *data, int datalen)
 205:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1371              		.loc 10 205 0
 1372              		.cfi_startproc
 1373              		@ args = 0, pretend = 0, frame = 0
 1374              		@ frame_needed = 0, uses_anonymous_args = 0
 1375              		@ link register save eliminated.
 1376              	.LVL90:
 1377              	.LBB31:
 206:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   datalen /= 2;
 1378              		.loc 10 206 0
 1379 0000 01EBD171 		add	r1, r1, r1, lsr #31
 1380              	.LVL91:
 1381 0004 4910     		asrs	r1, r1, #1
 1382              	.LVL92:
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   while(datalen--) {
 1383              		.loc 10 207 0
 1384 0006 04E0     		b	.L79
 1385              	.LVL93:
 1386              	.L80:
 1387              	.LBB32:
 208:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     unsigned char t = data[0];
 1388              		.loc 10 208 0
 1389 0008 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 1390              	.LVL94:
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[0] = data[1];
 1391              		.loc 10 209 0
 1392 000a 4278     		ldrb	r2, [r0, #1]	@ zero_extendqisi2
 210:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[1] = t;
 1393              		.loc 10 210 0
 1394 000c 4370     		strb	r3, [r0, #1]
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[0] = data[1];
 1395              		.loc 10 209 0
 1396 000e 0270     		strb	r2, [r0, #0]
 211:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data += 2;
 1397              		.loc 10 211 0
 1398 0010 0230     		adds	r0, r0, #2
 1399              	.LVL95:
 1400              	.L79:
 1401              	.LBE32:
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   while(datalen--) {
 1402              		.loc 10 207 0 discriminator 1
 1403 0012 11F1FF31 		adds	r1, r1, #-1
 1404              	.LVL96:
 1405 0016 F7D2     		bcs	.L80
 1406              	.LBE31:
 212:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 213:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1407              		.loc 10 213 0
 1408 0018 7047     		bx	lr
 1409              		.cfi_endproc
 1410              	.LFE145:
 1412              		.section	.text._Z18readMPU6000Sensorsv,"ax",%progbits
 1413              		.align	1
 1414              		.global	_Z18readMPU6000Sensorsv
 1415              		.thumb
 1416              		.thumb_func
 1418              	_Z18readMPU6000Sensorsv:
 1419              	.LFB146:
 214:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Sensors()
 216:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1420              		.loc 10 216 0
 1421              		.cfi_startproc
 1422              		@ args = 0, pretend = 0, frame = 0
 1423              		@ frame_needed = 0, uses_anonymous_args = 0
 1424 0000 10B5     		push	{r4, lr}
 1425              	.LCFI11:
 1426              		.cfi_def_cfa_offset 8
 1427              		.cfi_offset 14, -4
 1428              		.cfi_offset 4, -8
 217:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 218:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     sendByteI2C(MPU6000_I2C_ADDRESS, MPUREG_ACCEL_XOUT_H);
 219:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     Wire.requestFrom(MPU6000_I2C_ADDRESS, sizeof(MPU6000));
 220:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     for(byte i=0; i<sizeof(MPU6000)/sizeof(short); i++) {
 221:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****       MPU6000.rawWord[i] = readWordI2C();
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     }
 223:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 224:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.Read(MPUREG_ACCEL_XOUT_H, MPU6000.rawByte, sizeof(MPU6000));
 1429              		.loc 10 224 0
 1430 0002 064C     		ldr	r4, .L82
 1431 0004 0648     		ldr	r0, .L82+4
 1432 0006 3B21     		movs	r1, #59
 1433 0008 2246     		mov	r2, r4
 1434 000a 0E23     		movs	r3, #14
 1435 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 225:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1436              		.loc 10 225 0
 1437 0010 2046     		mov	r0, r4
 1438 0012 0E21     		movs	r1, #14
 226:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 227:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1439              		.loc 10 227 0
 1440 0014 BDE81040 		pop	{r4, lr}
 225:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1441              		.loc 10 225 0
 1442 0018 FFF7FEBF 		b	_Z15MPU6000SwapDataPhi
 1443              	.L83:
 1444              		.align	2
 1445              	.L82:
 1446 001c 00000000 		.word	.LANCHOR14
 1447 0020 00000000 		.word	.LANCHOR11
 1448              		.cfi_endproc
 1449              	.LFE146:
 1451              		.section	.text._Z16readMPU6000Accelv,"ax",%progbits
 1452              		.align	1
 1453              		.global	_Z16readMPU6000Accelv
 1454              		.thumb
 1455              		.thumb_func
 1457              	_Z16readMPU6000Accelv:
 1458              	.LFB147:
 228:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 229:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000Count=0;
 230:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000AccelCount=0;
 231:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** int readMPU6000GyroCount=0;
 232:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 233:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Accel()
 234:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1459              		.loc 10 234 0
 1460              		.cfi_startproc
 1461              		@ args = 0, pretend = 0, frame = 0
 1462              		@ frame_needed = 0, uses_anonymous_args = 0
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1463              		.loc 10 235 0
 1464 0000 0748     		ldr	r0, .L86
 234:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1465              		.loc 10 234 0
 1466 0002 10B5     		push	{r4, lr}
 1467              	.LCFI12:
 1468              		.cfi_def_cfa_offset 8
 1469              		.cfi_offset 14, -4
 1470              		.cfi_offset 4, -8
 236:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if(readMPU6000AccelCount != readMPU6000Count) {
 1471              		.loc 10 236 0
 1472 0004 074C     		ldr	r4, .L86+4
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1473              		.loc 10 235 0
 1474 0006 0168     		ldr	r1, [r0, #0]
 1475              		.loc 10 236 0
 1476 0008 2268     		ldr	r2, [r4, #0]
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1477              		.loc 10 235 0
 1478 000a 4B1C     		adds	r3, r1, #1
 1479              		.loc 10 236 0
 1480 000c 9342     		cmp	r3, r2
 235:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000AccelCount++;
 1481              		.loc 10 235 0
 1482 000e 0360     		str	r3, [r0, #0]
 1483              		.loc 10 236 0
 1484 0010 04D0     		beq	.L84
 237:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000Sensors();
 1485              		.loc 10 237 0
 1486 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 238:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000Count++;
 1487              		.loc 10 238 0
 1488 0016 2368     		ldr	r3, [r4, #0]
 1489 0018 5A1C     		adds	r2, r3, #1
 1490 001a 2260     		str	r2, [r4, #0]
 1491              	.L84:
 1492 001c 10BD     		pop	{r4, pc}
 1493              	.L87:
 1494 001e 00BF     		.align	2
 1495              	.L86:
 1496 0020 00000000 		.word	.LANCHOR15
 1497 0024 00000000 		.word	.LANCHOR16
 1498              		.cfi_endproc
 1499              	.LFE147:
 1501              		.section	.text._Z15readMPU6000Gyrov,"ax",%progbits
 1502              		.align	1
 1503              		.global	_Z15readMPU6000Gyrov
 1504              		.thumb
 1505              		.thumb_func
 1507              	_Z15readMPU6000Gyrov:
 1508              	.LFB148:
 239:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 240:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 241:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 242:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Gyro()
 243:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1509              		.loc 10 243 0
 1510              		.cfi_startproc
 1511              		@ args = 0, pretend = 0, frame = 0
 1512              		@ frame_needed = 0, uses_anonymous_args = 0
 1513 0000 10B5     		push	{r4, lr}
 1514              	.LCFI13:
 1515              		.cfi_def_cfa_offset 8
 1516              		.cfi_offset 14, -4
 1517              		.cfi_offset 4, -8
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1518              		.loc 10 244 0
 1519 0002 074C     		ldr	r4, .L90
 245:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if(readMPU6000GyroCount != readMPU6000Count) {
 1520              		.loc 10 245 0
 1521 0004 0748     		ldr	r0, .L90+4
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1522              		.loc 10 244 0
 1523 0006 2168     		ldr	r1, [r4, #0]
 1524              		.loc 10 245 0
 1525 0008 0268     		ldr	r2, [r0, #0]
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1526              		.loc 10 244 0
 1527 000a 4B1C     		adds	r3, r1, #1
 1528              		.loc 10 245 0
 1529 000c 9342     		cmp	r3, r2
 244:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   readMPU6000GyroCount++;
 1530              		.loc 10 244 0
 1531 000e 2360     		str	r3, [r4, #0]
 1532              		.loc 10 245 0
 1533 0010 04D0     		beq	.L88
 246:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000Sensors();
 1534              		.loc 10 246 0
 1535 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 247:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     readMPU6000GyroCount++;
 1536              		.loc 10 247 0
 1537 0016 2368     		ldr	r3, [r4, #0]
 1538 0018 5A1C     		adds	r2, r3, #1
 1539 001a 2260     		str	r2, [r4, #0]
 1540              	.L88:
 1541 001c 10BD     		pop	{r4, pc}
 1542              	.L91:
 1543 001e 00BF     		.align	2
 1544              	.L90:
 1545 0020 00000000 		.word	.LANCHOR17
 1546 0024 00000000 		.word	.LANCHOR16
 1547              		.cfi_endproc
 1548              	.LFE148:
 1550              		.section	.text._Z14initializeGyrov,"ax",%progbits
 1551              		.align	1
 1552              		.global	_Z14initializeGyrov
 1553              		.thumb
 1554              		.thumb_func
 1556              	_Z14initializeGyrov:
 1557              	.LFB149:
 1558              		.file 11 "../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h"
   1:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** /*
   2:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
   7:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  12:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  17:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** */
  20:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  21:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #ifndef _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  22:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  23:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  24:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** int gyroRaw[3] = {0,0,0};
  25:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  26:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Platform_MPU6000.h>
  27:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Gyroscope.h>
  28:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  29:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define GYRO_CALIBRATION_TRESHOLD 25
  30:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  31:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void initializeGyro() {
 1559              		.loc 11 31 0
 1560              		.cfi_startproc
 1561              		@ args = 0, pretend = 0, frame = 0
 1562              		@ frame_needed = 0, uses_anonymous_args = 0
 1563              		@ link register save eliminated.
 1564              	.LVL97:
 1565              	.LBB33:
  32:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   float range = 2*1000.0;
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroScaleFactor = radians(range/65536.0);
 1566              		.loc 11 33 0
 1567 0000 024A     		ldr	r2, .L93
 1568 0002 034B     		ldr	r3, .L93+4
 1569 0004 1A60     		str	r2, [r3, #0]	@ float
 1570              	.LBE33:
  34:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
  36:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1571              		.loc 11 36 0
 1572              	.LBB34:
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
 1573              		.loc 11 35 0
 1574 0006 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 1575              	.L94:
 1576 000a 00BF     		.align	2
 1577              	.L93:
 1578 000c 58A00B3A 		.word	973840472
 1579 0010 00000000 		.word	.LANCHOR18
 1580              	.LBE34:
 1581              		.cfi_endproc
 1582              	.LFE149:
 1584              		.section	.text._Z17gyroUpdateHeadingv,"ax",%progbits
 1585              		.align	1
 1586              		.global	_Z17gyroUpdateHeadingv
 1587              		.thumb
 1588              		.thumb_func
 1590              	_Z17gyroUpdateHeadingv:
 1591              	.LFB150:
  37:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  38:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void gyroUpdateHeading()
  39:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** {
 1592              		.loc 11 39 0
 1593              		.cfi_startproc
 1594              		@ args = 0, pretend = 0, frame = 0
 1595              		@ frame_needed = 0, uses_anonymous_args = 0
 1596 0000 08B5     		push	{r3, lr}
 1597              	.LCFI14:
 1598              		.cfi_def_cfa_offset 8
 1599              		.cfi_offset 14, -4
 1600              		.cfi_offset 3, -8
 1601              	.LBB35:
  40:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   long int currentTime = micros();
 1602              		.loc 11 40 0
 1603 0002 FFF7FEFF 		bl	_ZL6microsv
 1604              	.LVL98:
  41:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   if (gyroRate[ZAXIS] > (float)radians(1.0) || gyroRate[ZAXIS] < (float)radians(-1.0)) {
 1605              		.loc 11 41 0
 1606 0006 124B     		ldr	r3, .L99
 1607 0008 DFED127A 		flds	s15, .L99+4
 1608 000c 93ED027A 		flds	s14, [r3, #8]
 1609 0010 B4EEE77A 		fcmpes	s14, s15
 1610 0014 F1EE10FA 		fmstat
 1611 0018 0F4B     		ldr	r3, .L99+8
 1612 001a 06DC     		bgt	.L96
 1613              		.loc 11 41 0 is_stmt 0 discriminator 1
 1614 001c 9FED0F0A 		flds	s0, .L99+12
 1615 0020 B4EEC07A 		fcmpes	s14, s0
 1616 0024 F1EE10FA 		fmstat
 1617 0028 10D5     		bpl	.L97
 1618              	.L96:
  42:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
 1619              		.loc 11 42 0 is_stmt 1
 1620 002a 1968     		ldr	r1, [r3, #0]
 1621 002c 0C4A     		ldr	r2, .L99+16
 1622 002e 411A     		subs	r1, r0, r1
 1623 0030 01EE901A 		fmsr	s3, r1	@ int
 1624 0034 9FED0B1A 		flds	s2, .L99+20
 1625 0038 F8EE616A 		fuitos	s13, s3
 1626 003c D2ED000A 		flds	s1, [r2, #0]
 1627 0040 C6EE816A 		fdivs	s13, s13, s2
 1628 0044 47EE260A 		fmacs	s1, s14, s13
 1629 0048 C2ED000A 		fsts	s1, [r2, #0]
 1630              	.L97:
  43:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  44:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroLastMesuredTime = currentTime;
 1631              		.loc 11 44 0
 1632 004c 1860     		str	r0, [r3, #0]
 1633              	.LBE35:
  45:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1634              		.loc 11 45 0
 1635 004e 08BD     		pop	{r3, pc}
 1636              	.L100:
 1637              		.align	2
 1638              	.L99:
 1639 0050 00000000 		.word	.LANCHOR19
 1640 0054 35FA8E3C 		.word	1016003125
 1641 0058 00000000 		.word	.LANCHOR21
 1642 005c 35FA8EBC 		.word	-1131480523
 1643 0060 00000000 		.word	.LANCHOR20
 1644 0064 00247449 		.word	1232348160
 1645              		.cfi_endproc
 1646              	.LFE150:
 1648              		.section	.text._Z11measureGyrov,"ax",%progbits
 1649              		.align	1
 1650              		.global	_Z11measureGyrov
 1651              		.thumb
 1652              		.thumb_func
 1654              	_Z11measureGyrov:
 1655              	.LFB151:
  46:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  47:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyro() {
 1656              		.loc 11 47 0
 1657              		.cfi_startproc
 1658              		@ args = 0, pretend = 0, frame = 16
 1659              		@ frame_needed = 0, uses_anonymous_args = 0
 1660 0000 30B5     		push	{r4, r5, lr}
 1661              	.LCFI15:
 1662              		.cfi_def_cfa_offset 12
 1663              		.cfi_offset 14, -4
 1664              		.cfi_offset 5, -8
 1665              		.cfi_offset 4, -12
 1666 0002 85B0     		sub	sp, sp, #20
 1667              	.LCFI16:
 1668              		.cfi_def_cfa_offset 32
 1669              	.LBB36:
  48:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1670              		.loc 11 48 0
 1671 0004 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1672              		.loc 11 51 0
 1673 0008 1A4A     		ldr	r2, .L102
 1674 000a 1B49     		ldr	r1, .L102+4
 1675 000c B2F90850 		ldrsh	r5, [r2, #8]
 1676 0010 1A4B     		ldr	r3, .L102+8
 1677 0012 0C68     		ldr	r4, [r1, #0]
 1678 0014 1D60     		str	r5, [r3, #0]
 1679 0016 2C1B     		subs	r4, r5, r4
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1680              		.loc 11 52 0
 1681 0018 B2F90A00 		ldrsh	r0, [r2, #10]
 1682 001c 4D68     		ldr	r5, [r1, #4]
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1683              		.loc 11 53 0
 1684 001e B2F90C20 		ldrsh	r2, [r2, #12]
 1685 0022 8968     		ldr	r1, [r1, #8]
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1686              		.loc 11 52 0
 1687 0024 5860     		str	r0, [r3, #4]
 1688              		.loc 11 53 0
 1689 0026 9A60     		str	r2, [r3, #8]
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1690              		.loc 11 52 0
 1691 0028 281A     		subs	r0, r5, r0
 1692              		.loc 11 53 0
 1693 002a 8A1A     		subs	r2, r1, r2
 1694              	.LBB37:
  54:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  55:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  56:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1695              		.loc 11 56 0
 1696 002c 01EE904A 		fmsr	s3, r4	@ int
 1697 0030 1349     		ldr	r1, .L102+12
 1698 0032 144B     		ldr	r3, .L102+16
 1699              	.LBE37:
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1700              		.loc 11 51 0
 1701 0034 0194     		str	r4, [sp, #4]
 1702              	.LBB38:
 1703              		.loc 11 56 0
 1704 0036 00EE900A 		fmsr	s1, r0	@ int
 1705 003a 06EE902A 		fmsr	s13, r2	@ int
 1706 003e D1ED007A 		flds	s15, [r1, #0]
 1707 0042 B8EEE11A 		fsitos	s2, s3
 1708 0046 B8EEE00A 		fsitos	s0, s1
 1709 004a B8EEE67A 		fsitos	s14, s13
 1710 004e 21EE271A 		fmuls	s2, s2, s15
 1711 0052 20EE270A 		fmuls	s0, s0, s15
 1712 0056 67EE277A 		fmuls	s15, s14, s15
 1713              	.LBE38:
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1714              		.loc 11 52 0
 1715 005a 0290     		str	r0, [sp, #8]
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1716              		.loc 11 53 0
 1717 005c 0392     		str	r2, [sp, #12]
 1718              	.LVL99:
 1719              	.LBB39:
 1720              		.loc 11 56 0
 1721 005e 83ED001A 		fsts	s2, [r3, #0]
 1722              	.LVL100:
 1723 0062 83ED010A 		fsts	s0, [r3, #4]
 1724              	.LVL101:
 1725 0066 C3ED027A 		fsts	s15, [r3, #8]
 1726              	.LVL102:
 1727              	.LBE39:
 1728              	.LBE36:
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  58:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  60:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1729              		.loc 11 60 0
 1730 006a 05B0     		add	sp, sp, #20
 1731 006c BDE83040 		pop	{r4, r5, lr}
 1732              	.LBB40:
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1733              		.loc 11 59 0
 1734 0070 FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1735              	.L103:
 1736              		.align	2
 1737              	.L102:
 1738 0074 00000000 		.word	.LANCHOR14
 1739 0078 00000000 		.word	.LANCHOR23
 1740 007c 00000000 		.word	.LANCHOR22
 1741 0080 00000000 		.word	.LANCHOR18
 1742 0084 00000000 		.word	.LANCHOR19
 1743              	.LBE40:
 1744              		.cfi_endproc
 1745              	.LFE151:
 1747              		.section	.text._Z14measureGyroSumv,"ax",%progbits
 1748              		.align	1
 1749              		.global	_Z14measureGyroSumv
 1750              		.thumb
 1751              		.thumb_func
 1753              	_Z14measureGyroSumv:
 1754              	.LFB152:
  61:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  62:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyroSum() {
 1755              		.loc 11 62 0
 1756              		.cfi_startproc
 1757              		@ args = 0, pretend = 0, frame = 0
 1758              		@ frame_needed = 0, uses_anonymous_args = 0
 1759 0000 10B5     		push	{r4, lr}
 1760              	.LCFI17:
 1761              		.cfi_def_cfa_offset 8
 1762              		.cfi_offset 14, -4
 1763              		.cfi_offset 4, -8
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Gyro();
 1764              		.loc 11 63 0
 1765 0002 FFF7FEFF 		bl	_Z15readMPU6000Gyrov
  64:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] += (gyroRaw[XAXIS]=MPU6000.data.gyro.x);
 1766              		.loc 11 64 0
 1767 0006 0D4B     		ldr	r3, .L105
 1768 0008 0D49     		ldr	r1, .L105+4
 1769 000a 1C68     		ldr	r4, [r3, #0]
 1770 000c B1F90800 		ldrsh	r0, [r1, #8]
 1771 0010 0C4A     		ldr	r2, .L105+8
 1772 0012 2418     		adds	r4, r4, r0
 1773 0014 1C60     		str	r4, [r3, #0]
 1774 0016 1060     		str	r0, [r2, #0]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1775              		.loc 11 65 0
 1776 0018 5C68     		ldr	r4, [r3, #4]
 1777 001a B1F90A00 		ldrsh	r0, [r1, #10]
  66:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] += (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1778              		.loc 11 66 0
 1779 001e B1F90C10 		ldrsh	r1, [r1, #12]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1780              		.loc 11 65 0
 1781 0022 5060     		str	r0, [r2, #4]
 1782 0024 2018     		adds	r0, r4, r0
 1783 0026 5860     		str	r0, [r3, #4]
 1784              		.loc 11 66 0
 1785 0028 9868     		ldr	r0, [r3, #8]
 1786 002a 9160     		str	r1, [r2, #8]
 1787 002c 4118     		adds	r1, r0, r1
 1788 002e 9960     		str	r1, [r3, #8]
  67:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  68:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount++;
 1789              		.loc 11 68 0
 1790 0030 054B     		ldr	r3, .L105+12
 1791 0032 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 1792 0034 421C     		adds	r2, r0, #1
 1793 0036 1A70     		strb	r2, [r3, #0]
  69:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1794              		.loc 11 69 0
 1795 0038 10BD     		pop	{r4, pc}
 1796              	.L106:
 1797 003a 00BF     		.align	2
 1798              	.L105:
 1799 003c 00000000 		.word	.LANCHOR24
 1800 0040 00000000 		.word	.LANCHOR14
 1801 0044 00000000 		.word	.LANCHOR22
 1802 0048 00000000 		.word	.LANCHOR25
 1803              		.cfi_endproc
 1804              	.LFE152:
 1806              		.section	.text._Z16evaluateGyroRatev,"ax",%progbits
 1807              		.align	1
 1808              		.global	_Z16evaluateGyroRatev
 1809              		.thumb
 1810              		.thumb_func
 1812              	_Z16evaluateGyroRatev:
 1813              	.LFB153:
  70:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void evaluateGyroRate() {
 1814              		.loc 11 71 0
 1815              		.cfi_startproc
 1816              		@ args = 0, pretend = 0, frame = 16
 1817              		@ frame_needed = 0, uses_anonymous_args = 0
 1818 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 1819              	.LCFI18:
 1820              		.cfi_def_cfa_offset 32
 1821              		.cfi_offset 14, -4
 1822              		.cfi_offset 6, -8
 1823              		.cfi_offset 5, -12
 1824              		.cfi_offset 4, -16
 1825              		.cfi_offset 3, -20
 1826              		.cfi_offset 2, -24
 1827              		.cfi_offset 1, -28
 1828              		.cfi_offset 0, -32
 1829              	.LBB41:
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1830              		.loc 11 73 0
 1831 0002 1F4B     		ldr	r3, .L108
 1832 0004 1F4D     		ldr	r5, .L108+4
 1833 0006 1A68     		ldr	r2, [r3, #0]
 1834 0008 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1835              		.loc 11 74 0
 1836 000c 5968     		ldr	r1, [r3, #4]
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1837              		.loc 11 73 0
 1838 000e 92FBFCF4 		sdiv	r4, r2, ip
 1839 0012 1D4A     		ldr	r2, .L108+8
 1840 0014 1068     		ldr	r0, [r2, #0]
 1841              		.loc 11 74 0
 1842 0016 5668     		ldr	r6, [r2, #4]
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1843              		.loc 11 73 0
 1844 0018 241A     		subs	r4, r4, r0
 1845              		.loc 11 74 0
 1846 001a 91FBFCF0 		sdiv	r0, r1, ip
 1847 001e 301A     		subs	r0, r6, r0
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1848              		.loc 11 75 0
 1849 0020 9E68     		ldr	r6, [r3, #8]
 1850 0022 9168     		ldr	r1, [r2, #8]
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1851              		.loc 11 73 0
 1852 0024 0194     		str	r4, [sp, #4]
 1853              		.loc 11 75 0
 1854 0026 96FBFCFC 		sdiv	ip, r6, ip
  76:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  77:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] = 0;
 1855              		.loc 11 77 0
 1856 002a 0022     		movs	r2, #0
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1857              		.loc 11 75 0
 1858 002c CCEB0101 		rsb	r1, ip, r1
 1859              		.loc 11 77 0
 1860 0030 1A60     		str	r2, [r3, #0]
  78:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] = 0;
 1861              		.loc 11 78 0
 1862 0032 5A60     		str	r2, [r3, #4]
  79:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] = 0;
 1863              		.loc 11 79 0
 1864 0034 9A60     		str	r2, [r3, #8]
  80:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount = 0;
 1865              		.loc 11 80 0
 1866 0036 2A70     		strb	r2, [r5, #0]
 1867              	.LVL103:
 1868              	.LBB42:
  81:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  82:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  83:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1869              		.loc 11 83 0
 1870 0038 01EE904A 		fmsr	s3, r4	@ int
 1871 003c 134A     		ldr	r2, .L108+12
 1872 003e 144B     		ldr	r3, .L108+16
 1873              	.LBE42:
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1874              		.loc 11 74 0
 1875 0040 0290     		str	r0, [sp, #8]
 1876              	.LBB43:
 1877              		.loc 11 83 0
 1878 0042 00EE900A 		fmsr	s1, r0	@ int
 1879 0046 06EE901A 		fmsr	s13, r1	@ int
 1880 004a D2ED007A 		flds	s15, [r2, #0]
 1881 004e B8EEE11A 		fsitos	s2, s3
 1882 0052 B8EEE00A 		fsitos	s0, s1
 1883 0056 B8EEE67A 		fsitos	s14, s13
 1884 005a 21EE271A 		fmuls	s2, s2, s15
 1885 005e 20EE270A 		fmuls	s0, s0, s15
 1886 0062 67EE277A 		fmuls	s15, s14, s15
 1887              	.LBE43:
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1888              		.loc 11 75 0
 1889 0066 0391     		str	r1, [sp, #12]
 1890              	.LBB44:
 1891              		.loc 11 83 0
 1892 0068 83ED001A 		fsts	s2, [r3, #0]
 1893              	.LVL104:
 1894 006c 83ED010A 		fsts	s0, [r3, #4]
 1895              	.LVL105:
 1896 0070 C3ED027A 		fsts	s15, [r3, #8]
 1897              	.LVL106:
 1898              	.LBE44:
 1899              	.LBE41:
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  85:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  87:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1900              		.loc 11 87 0
 1901 0074 04B0     		add	sp, sp, #16
 1902 0076 BDE87040 		pop	{r4, r5, r6, lr}
 1903              	.LBB45:
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1904              		.loc 11 86 0
 1905 007a FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1906              	.L109:
 1907 007e 00BF     		.align	2
 1908              	.L108:
 1909 0080 00000000 		.word	.LANCHOR24
 1910 0084 00000000 		.word	.LANCHOR25
 1911 0088 00000000 		.word	.LANCHOR23
 1912 008c 00000000 		.word	.LANCHOR18
 1913 0090 00000000 		.word	.LANCHOR19
 1914              	.LBE45:
 1915              		.cfi_endproc
 1916              	.LFE153:
 1918              		.section	.text._Z13calibrateGyrov,"ax",%progbits
 1919              		.align	1
 1920              		.global	_Z13calibrateGyrov
 1921              		.thumb
 1922              		.thumb_func
 1924              	_Z13calibrateGyrov:
 1925              	.LFB154:
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  89:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** boolean calibrateGyro() {
 1926              		.loc 11 90 0
 1927              		.cfi_startproc
 1928              		@ args = 0, pretend = 0, frame = 200
 1929              		@ frame_needed = 0, uses_anonymous_args = 0
 1930 0000 70B5     		push	{r4, r5, r6, lr}
 1931              	.LCFI19:
 1932              		.cfi_def_cfa_offset 16
 1933              		.cfi_offset 14, -4
 1934              		.cfi_offset 6, -8
 1935              		.cfi_offset 5, -12
 1936              		.cfi_offset 4, -16
 1937 0002 B2B0     		sub	sp, sp, #200
 1938              	.LCFI20:
 1939              		.cfi_def_cfa_offset 216
 1940              	.LBB46:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int findZero[FINDZERO];
  93:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int diff = 0; 
 1941              		.loc 11 93 0
 1942 0004 0024     		movs	r4, #0
 1943 0006 3194     		str	r4, [sp, #196]
 1944              	.LVL107:
 1945 0008 154D     		ldr	r5, .L121
 1946 000a 22E0     		b	.L111
 1947              	.LVL108:
 1948              	.L115:
 1949              	.LBB47:
 1950              	.LBB48:
 1951              	.LBB49:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
  96:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       readMPU6000Sensors();
 1952              		.loc 11 96 0
 1953 000c FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 1954 0010 144B     		ldr	r3, .L121+4
  97:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       if(axis == XAXIS) {
 1955              		.loc 11 97 0
 1956 0012 14B9     		cbnz	r4, .L112
  98:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.x;
 1957              		.loc 11 98 0
 1958 0014 B3F90830 		ldrsh	r3, [r3, #8]
 1959 0018 05E0     		b	.L120
 1960              	.L112:
  99:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } 
 100:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  else if(axis == YAXIS) {
 1961              		.loc 11 100 0
 1962 001a 012C     		cmp	r4, #1
 101:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.y;
 1963              		.loc 11 101 0
 1964 001c 0CBF     		ite	eq
 1965 001e B3F90A30 		ldrsheq	r3, [r3, #10]
 102:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } 
 103:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  else {
 104:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.z;
 1966              		.loc 11 104 0
 1967 0022 B3F90C30 		ldrshne	r3, [r3, #12]
 1968              	.L120:
 1969 0026 4DF80630 		str	r3, [sp, r6]
 105:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       }
 106:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       delay(10);
 1970              		.loc 11 106 0
 1971 002a 0A20     		movs	r0, #10
 1972 002c 0436     		adds	r6, r6, #4
 1973 002e FFF7FEFF 		bl	_Z5delaym
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
 1974              		.loc 11 95 0
 1975 0032 C42E     		cmp	r6, #196
 1976 0034 EAD1     		bne	.L115
 1977              	.LBE49:
 107:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     }
 108:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     int tmp = findMedianIntWithDiff(findZero, FINDZERO, &diff);
 1978              		.loc 11 108 0
 1979 0036 3121     		movs	r1, #49
 1980 0038 6846     		mov	r0, sp
 1981 003a 31AA     		add	r2, sp, #196
 1982 003c FFF7FEFF 		bl	_Z21findMedianIntWithDiffPiiS_
 1983              	.LVL109:
 109:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	if (diff <= GYRO_CALIBRATION_TRESHOLD) { 
 1984              		.loc 11 109 0
 1985 0040 319B     		ldr	r3, [sp, #196]
 1986 0042 192B     		cmp	r3, #25
 1987 0044 07DC     		bgt	.L117
 1988              	.LBE48:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 1989              		.loc 11 94 0
 1990 0046 0134     		adds	r4, r4, #1
 1991 0048 E4B2     		uxtb	r4, r4
 1992              	.LVL110:
 1993 004a 032C     		cmp	r4, #3
 1994              	.LBB50:
 110:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  gyroZero[axis] = tmp;
 1995              		.loc 11 110 0
 1996 004c 45F8040F 		str	r0, [r5, #4]!
 1997              	.LBE50:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 1998              		.loc 11 94 0
 1999 0050 03D0     		beq	.L118
 2000              	.LVL111:
 2001              	.L111:
 2002              	.LBE47:
 2003              	.LBE46:
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** boolean calibrateGyro() {
 2004              		.loc 11 90 0 discriminator 1
 2005 0052 0026     		movs	r6, #0
 2006 0054 DAE7     		b	.L115
 2007              	.LVL112:
 2008              	.L117:
 2009              	.LBB53:
 2010              	.LBB52:
 2011              	.LBB51:
 111:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	} 
 112:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	else {
 113:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 		return false; //Calibration failed.
 2012              		.loc 11 113 0
 2013 0056 0020     		movs	r0, #0
 2014              	.LVL113:
 2015 0058 00E0     		b	.L116
 2016              	.LVL114:
 2017              	.L118:
 2018              	.LBE51:
 114:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	}
 115:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
 116:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   return true;
 2019              		.loc 11 116 0
 2020 005a 0120     		movs	r0, #1
 2021              	.LVL115:
 2022              	.L116:
 2023              	.LBE52:
 2024              	.LBE53:
 117:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 2025              		.loc 11 117 0
 2026 005c 32B0     		add	sp, sp, #200
 2027 005e 70BD     		pop	{r4, r5, r6, pc}
 2028              	.L122:
 2029              		.align	2
 2030              	.L121:
 2031 0060 FCFFFFFF 		.word	.LANCHOR23-4
 2032 0064 00000000 		.word	.LANCHOR14
 2033              		.cfi_endproc
 2034              	.LFE154:
 2036              		.section	.text._Z15initializeAccelv,"ax",%progbits
 2037              		.align	1
 2038              		.global	_Z15initializeAccelv
 2039              		.thumb
 2040              		.thumb_func
 2042              	_Z15initializeAccelv:
 2043              	.LFB155:
 2044              		.file 12 "../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h"
   1:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** /*
   2:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
   7:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  12:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  17:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** */
  20:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  21:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #ifndef _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  22:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #define _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  23:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  24:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Platform_MPU6000.h>
  25:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Accelerometer.h>
  26:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  27:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void initializeAccel() {
 2045              		.loc 12 27 0
 2046              		.cfi_startproc
 2047              		@ args = 0, pretend = 0, frame = 0
 2048              		@ frame_needed = 0, uses_anonymous_args = 0
 2049              		@ link register save eliminated.
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
  29:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2050              		.loc 12 29 0
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   initializeMPU6000Sensors();
 2051              		.loc 12 28 0
 2052 0000 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 2053              		.cfi_endproc
 2054              	.LFE155:
 2056              		.section	.text._Z12measureAccelv,"ax",%progbits
 2057              		.align	1
 2058              		.global	_Z12measureAccelv
 2059              		.thumb
 2060              		.thumb_func
 2062              	_Z12measureAccelv:
 2063              	.LFB156:
  30:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  31:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  32:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccel() {
 2064              		.loc 12 32 0
 2065              		.cfi_startproc
 2066              		@ args = 0, pretend = 0, frame = 0
 2067              		@ frame_needed = 0, uses_anonymous_args = 0
 2068 0000 10B5     		push	{r4, lr}
 2069              	.LCFI21:
 2070              		.cfi_def_cfa_offset 8
 2071              		.cfi_offset 14, -4
 2072              		.cfi_offset 4, -8
  33:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2073              		.loc 12 33 0
 2074 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  34:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2075              		.loc 12 35 0
 2076 0006 1748     		ldr	r0, .L125
 2077 0008 1749     		ldr	r1, .L125+4
 2078 000a B0F90040 		ldrsh	r4, [r0, #0]
 2079 000e 174A     		ldr	r2, .L125+8
 2080 0010 174B     		ldr	r3, .L125+12
 2081 0012 04EE104A 		fmsr	s8, r4	@ int
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2082              		.loc 12 36 0
 2083 0016 B0F90240 		ldrsh	r4, [r0, #2]
  37:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[ZAXIS] = MPU6000.data.accel.z * accelScaleFactor[ZAXIS] + runTimeAccelBias[ZAXIS];
 2084              		.loc 12 37 0
 2085 001a B0F90400 		ldrsh	r0, [r0, #4]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2086              		.loc 12 36 0
 2087 001e 02EE104A 		fmsr	s4, r4	@ int
 2088              		.loc 12 37 0
 2089 0022 00EE100A 		fmsr	s0, r0	@ int
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2090              		.loc 12 35 0
 2091 0026 B8EEC43A 		fsitos	s6, s8
 2092 002a D1ED003A 		flds	s7, [r1, #0]
 2093 002e D2ED002A 		flds	s5, [r2, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2094              		.loc 12 36 0
 2095 0032 B8EEC21A 		fsitos	s2, s4
 2096 0036 D1ED011A 		flds	s3, [r1, #4]
 2097 003a D2ED010A 		flds	s1, [r2, #4]
 2098              		.loc 12 37 0
 2099 003e F8EEC06A 		fsitos	s13, s0
 2100 0042 91ED027A 		flds	s14, [r1, #8]
 2101 0046 D2ED027A 		flds	s15, [r2, #8]
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2102              		.loc 12 35 0
 2103 004a 43EE232A 		fmacs	s5, s6, s7
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2104              		.loc 12 36 0
 2105 004e 41EE210A 		fmacs	s1, s2, s3
 2106              		.loc 12 37 0
 2107 0052 46EE877A 		fmacs	s15, s13, s14
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2108              		.loc 12 35 0
 2109 0056 C3ED002A 		fsts	s5, [r3, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2110              		.loc 12 36 0
 2111 005a C3ED010A 		fsts	s1, [r3, #4]
 2112              		.loc 12 37 0
 2113 005e C3ED027A 		fsts	s15, [r3, #8]
  38:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2114              		.loc 12 38 0
 2115 0062 10BD     		pop	{r4, pc}
 2116              	.L126:
 2117              		.align	2
 2118              	.L125:
 2119 0064 00000000 		.word	.LANCHOR14
 2120 0068 00000000 		.word	.LANCHOR27
 2121 006c 00000000 		.word	.LANCHOR28
 2122 0070 00000000 		.word	.LANCHOR26
 2123              		.cfi_endproc
 2124              	.LFE156:
 2126              		.section	.text._Z15measureAccelSumv,"ax",%progbits
 2127              		.align	1
 2128              		.global	_Z15measureAccelSumv
 2129              		.thumb
 2130              		.thumb_func
 2132              	_Z15measureAccelSumv:
 2133              	.LFB157:
  39:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  40:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccelSum() {
 2134              		.loc 12 40 0
 2135              		.cfi_startproc
 2136              		@ args = 0, pretend = 0, frame = 0
 2137              		@ frame_needed = 0, uses_anonymous_args = 0
 2138 0000 08B5     		push	{r3, lr}
 2139              	.LCFI22:
 2140              		.cfi_def_cfa_offset 8
 2141              		.cfi_offset 14, -4
 2142              		.cfi_offset 3, -8
  41:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Accel();
 2143              		.loc 12 41 0
 2144 0002 FFF7FEFF 		bl	_Z16readMPU6000Accelv
  42:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[XAXIS] += MPU6000.data.accel.x;
 2145              		.loc 12 42 0
 2146 0006 0C4B     		ldr	r3, .L128
 2147 0008 0C4A     		ldr	r2, .L128+4
 2148 000a 1868     		ldr	r0, [r3, #0]
 2149 000c B2F900C0 		ldrsh	ip, [r2, #0]
 2150 0010 00EB0C01 		add	r1, r0, ip
 2151 0014 1960     		str	r1, [r3, #0]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2152              		.loc 12 43 0
 2153 0016 5868     		ldr	r0, [r3, #4]
 2154 0018 B2F90210 		ldrsh	r1, [r2, #2]
  44:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[ZAXIS] += MPU6000.data.accel.z;
 2155              		.loc 12 44 0
 2156 001c B2F904C0 		ldrsh	ip, [r2, #4]
 2157 0020 9A68     		ldr	r2, [r3, #8]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2158              		.loc 12 43 0
 2159 0022 4018     		adds	r0, r0, r1
 2160              		.loc 12 44 0
 2161 0024 02EB0C01 		add	r1, r2, ip
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2162              		.loc 12 43 0
 2163 0028 5860     		str	r0, [r3, #4]
 2164              		.loc 12 44 0
 2165 002a 9960     		str	r1, [r3, #8]
  45:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  46:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount++;
 2166              		.loc 12 46 0
 2167 002c 044B     		ldr	r3, .L128+8
 2168 002e 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 2169 0030 421C     		adds	r2, r0, #1
 2170 0032 1A70     		strb	r2, [r3, #0]
  47:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2171              		.loc 12 47 0
 2172 0034 08BD     		pop	{r3, pc}
 2173              	.L129:
 2174 0036 00BF     		.align	2
 2175              	.L128:
 2176 0038 00000000 		.word	.LANCHOR29
 2177 003c 00000000 		.word	.LANCHOR14
 2178 0040 00000000 		.word	.LANCHOR30
 2179              		.cfi_endproc
 2180              	.LFE157:
 2182              		.section	.text._Z20evaluateMetersPerSecv,"ax",%progbits
 2183              		.align	1
 2184              		.global	_Z20evaluateMetersPerSecv
 2185              		.thumb
 2186              		.thumb_func
 2188              	_Z20evaluateMetersPerSecv:
 2189              	.LFB158:
  48:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2190              		.loc 12 49 0
 2191              		.cfi_startproc
 2192              		@ args = 0, pretend = 0, frame = 0
 2193              		@ frame_needed = 0, uses_anonymous_args = 0
 2194              	.LVL116:
 2195 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2196              	.LCFI23:
 2197              		.cfi_def_cfa_offset 20
 2198              		.cfi_offset 14, -4
 2199              		.cfi_offset 7, -8
 2200              		.cfi_offset 6, -12
 2201              		.cfi_offset 5, -16
 2202              		.cfi_offset 4, -20
 2203              	.LBB54:
 2204              	.LBB55:
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2205              		.loc 12 51 0
 2206 0002 114A     		ldr	r2, .L133
 2207 0004 114C     		ldr	r4, .L133+4
 2208 0006 1778     		ldrb	r7, [r2, #0]	@ zero_extendqisi2
 2209 0008 1148     		ldr	r0, .L133+8
 2210 000a 1249     		ldr	r1, .L133+12
 2211 000c 0023     		movs	r3, #0
 2212 000e 1646     		mov	r6, r2
 2213              	.LVL117:
 2214              	.L131:
 2215              		.loc 12 51 0 is_stmt 0 discriminator 2
 2216 0010 114D     		ldr	r5, .L133+16
 2217 0012 5A59     		ldr	r2, [r3, r5]
 2218 0014 92FBF7F2 		sdiv	r2, r2, r7
 2219 0018 00EE102A 		fmsr	s0, r2	@ int
 2220 001c 0434     		adds	r4, r4, #4
 2221 001e 0430     		adds	r0, r0, #4
 2222 0020 F8EEC06A 		fsitos	s13, s0
 2223 0024 94ED007A 		flds	s14, [r4, #0]
 2224 0028 D0ED007A 		flds	s15, [r0, #0]
 2225 002c 46EE877A 		fmacs	s15, s13, s14
  52:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   	accelSample[axis] = 0;
 2226              		.loc 12 52 0 is_stmt 1 discriminator 2
 2227 0030 0022     		movs	r2, #0
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2228              		.loc 12 51 0 discriminator 2
 2229 0032 17EE90CA 		fmrs	ip, s15
 2230              		.loc 12 52 0 discriminator 2
 2231 0036 5A51     		str	r2, [r3, r5]
 2232 0038 0433     		adds	r3, r3, #4
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2233              		.loc 12 50 0 discriminator 2
 2234 003a 0C2B     		cmp	r3, #12
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2235              		.loc 12 51 0 discriminator 2
 2236 003c 41F804CF 		str	ip, [r1, #4]!	@ float
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2237              		.loc 12 50 0 discriminator 2
 2238 0040 E6D1     		bne	.L131
 2239              	.LBE55:
  53:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  54:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2240              		.loc 12 54 0
 2241 0042 3270     		strb	r2, [r6, #0]
 2242              	.LBE54:
  55:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2243              		.loc 12 55 0
 2244 0044 F0BD     		pop	{r4, r5, r6, r7, pc}
 2245              	.L134:
 2246 0046 00BF     		.align	2
 2247              	.L133:
 2248 0048 00000000 		.word	.LANCHOR30
 2249 004c FCFFFFFF 		.word	.LANCHOR27-4
 2250 0050 FCFFFFFF 		.word	.LANCHOR28-4
 2251 0054 FCFFFFFF 		.word	.LANCHOR26-4
 2252 0058 00000000 		.word	.LANCHOR29
 2253              		.cfi_endproc
 2254              	.LFE158:
 2256              		.section	.text._Z16computeAccelBiasv,"ax",%progbits
 2257              		.align	1
 2258              		.global	_Z16computeAccelBiasv
 2259              		.thumb
 2260              		.thumb_func
 2262              	_Z16computeAccelBiasv:
 2263              	.LFB159:
  56:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2264              		.loc 12 57 0
 2265              		.cfi_startproc
 2266              		@ args = 0, pretend = 0, frame = 0
 2267              		@ frame_needed = 0, uses_anonymous_args = 0
 2268              	.LVL118:
 2269 0000 10B5     		push	{r4, lr}
 2270              	.LCFI24:
 2271              		.cfi_def_cfa_offset 8
 2272              		.cfi_offset 14, -4
 2273              		.cfi_offset 4, -8
 2274              	.LBB56:
 2275              	.LBB57:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2276              		.loc 12 58 0
 2277 0002 0024     		movs	r4, #0
 2278 0004 08E0     		b	.L136
 2279              	.LVL119:
 2280              	.L137:
  59:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 	readMPU6000Sensors();
 2281              		.loc 12 59 0 discriminator 2
 2282 0006 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
  60:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     measureAccelSum();
 2283              		.loc 12 60 0 discriminator 2
 2284 000a FFF7FEFF 		bl	_Z15measureAccelSumv
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     delayMicroseconds(2500);
 2285              		.loc 12 61 0 discriminator 2
 2286 000e 40F6C410 		movw	r0, #2500
 2287 0012 FFF7FEFF 		bl	_Z17delayMicrosecondsj
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2288              		.loc 12 58 0 discriminator 2
 2289 0016 0134     		adds	r4, r4, #1
 2290              	.LVL120:
 2291              	.L136:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2292              		.loc 12 58 0 is_stmt 0 discriminator 1
 2293 0018 B4F5C87F 		cmp	r4, #400
 2294 001c F3D1     		bne	.L137
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2295              		.loc 12 58 0
 2296 001e 2048     		ldr	r0, .L141
 2297 0020 2049     		ldr	r1, .L141+4
 2298 0022 0023     		movs	r3, #0
 2299              	.LVL121:
 2300              	.L138:
 2301              	.LBE57:
 2302              	.LBB58:
  62:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  63:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  65:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2303              		.loc 12 65 0 is_stmt 1 discriminator 2
 2304 0024 204C     		ldr	r4, .L141+8
 2305 0026 1A59     		ldr	r2, [r3, r4]
 2306 0028 00EE902A 		fmsr	s1, r2	@ int
 2307 002c 9FED1F0A 		flds	s0, .L141+12
 2308 0030 B8EEE07A 		fsitos	s14, s1
 2309 0034 0430     		adds	r0, r0, #4
 2310 0036 87EE007A 		fdivs	s14, s14, s0
 2311 003a D0ED007A 		flds	s15, [r0, #0]
 2312 003e 67EE277A 		fmuls	s15, s14, s15
 2313 0042 17EE902A 		fmrs	r2, s15
 2314 0046 41F8042F 		str	r2, [r1, #4]!	@ float
  66:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     accelSample[axis] = 0;
 2315              		.loc 12 66 0 discriminator 2
 2316 004a 0022     		movs	r2, #0
 2317 004c 1A51     		str	r2, [r3, r4]
 2318 004e 0433     		adds	r3, r3, #4
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2319              		.loc 12 64 0 discriminator 2
 2320 0050 0C2B     		cmp	r3, #12
 2321 0052 E7D1     		bne	.L138
 2322              	.LBE58:
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
  69:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2323              		.loc 12 70 0
 2324 0054 1649     		ldr	r1, .L141+16
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2325              		.loc 12 68 0
 2326 0056 174B     		ldr	r3, .L141+20
 2327              		.loc 12 70 0
 2328 0058 1748     		ldr	r0, .L141+24
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2329              		.loc 12 68 0
 2330 005a 1A70     		strb	r2, [r3, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2331              		.loc 12 72 0
 2332 005c 91ED022A 		flds	s4, [r1, #8]
 2333 0060 DFED162A 		flds	s5, .L141+28
 2334 0064 72EEC21A 		fsubs	s3, s5, s4
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2335              		.loc 12 70 0
 2336 0068 D1ED004A 		flds	s9, [r1, #0]
  73:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  74:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelOneG = abs(meterPerSecSec[ZAXIS] + runTimeAccelBias[ZAXIS]);
 2337              		.loc 12 74 0
 2338 006c 32EE211A 		fadds	s2, s4, s3
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2339              		.loc 12 71 0
 2340 0070 D1ED013A 		flds	s7, [r1, #4]
 2341              		.loc 12 74 0
 2342 0074 B5EEC01A 		fcmpezs	s2
 2343 0078 F1EE10FA 		fmstat
 2344 007c 104B     		ldr	r3, .L141+32
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2345              		.loc 12 70 0
 2346 007e B1EE644A 		fnegs	s8, s9
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2347              		.loc 12 71 0
 2348 0082 B1EE633A 		fnegs	s6, s7
 2349              		.loc 12 74 0
 2350 0086 D8BF     		it	le
 2351 0088 B1EE411A 		fnegsle	s2, s2
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2352              		.loc 12 70 0
 2353 008c 80ED004A 		fsts	s8, [r0, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2354              		.loc 12 71 0
 2355 0090 80ED013A 		fsts	s6, [r0, #4]
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2356              		.loc 12 72 0
 2357 0094 C0ED021A 		fsts	s3, [r0, #8]
 2358              		.loc 12 74 0
 2359 0098 83ED001A 		fsts	s2, [r3, #0]
 2360              	.LBE56:
  75:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
 2361              		.loc 12 75 0
 2362 009c 10BD     		pop	{r4, pc}
 2363              	.L142:
 2364 009e 00BF     		.align	2
 2365              	.L141:
 2366 00a0 FCFFFFFF 		.word	.LANCHOR27-4
 2367 00a4 FCFFFFFF 		.word	.LANCHOR26-4
 2368 00a8 00000000 		.word	.LANCHOR29
 2369 00ac 0000C843 		.word	1137180672
 2370 00b0 00000000 		.word	.LANCHOR26
 2371 00b4 00000000 		.word	.LANCHOR30
 2372 00b8 00000000 		.word	.LANCHOR28
 2373 00bc 6DE71CC1 		.word	-1055070355
 2374 00c0 00000000 		.word	.LANCHOR31
 2375              		.cfi_endproc
 2376              	.LFE159:
 2378              		.section	.text._Z12initPlatformv,"ax",%progbits
 2379              		.align	1
 2380              		.global	_Z12initPlatformv
 2381              		.thumb
 2382              		.thumb_func
 2384              	_Z12initPlatformv:
 2385              	.LFB160:
 2386              		.file 13 "../AeroQuad32/platform_aeroquad32.h"
   1:../AeroQuad32/platform_aeroquad32.h **** #ifndef _PLATFORM_AEROQUAD32_H_
   2:../AeroQuad32/platform_aeroquad32.h **** 
   3:../AeroQuad32/platform_aeroquad32.h **** #define _PLATFORM_AEROQUAD32_H_
   4:../AeroQuad32/platform_aeroquad32.h **** 
   5:../AeroQuad32/platform_aeroquad32.h **** static byte __attribute__((unused)) stm32_motor_mapping[] = {
   6:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  9),
   7:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  8),
   8:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  7),
   9:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  6),
  10:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('A', 15),
  11:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  3),
  12:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  4),
  13:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  5)
  14:../AeroQuad32/platform_aeroquad32.h **** };
  15:../AeroQuad32/platform_aeroquad32.h **** 
  16:../AeroQuad32/platform_aeroquad32.h **** static byte __attribute__((unused)) stm32_motor_mapping_tri[] = {
  17:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('A', 15), // note this must be on separate timer device !!
  18:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  8),
  19:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  7),
  20:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  6),
  21:../AeroQuad32/platform_aeroquad32.h **** };
  22:../AeroQuad32/platform_aeroquad32.h **** 
  23:../AeroQuad32/platform_aeroquad32.h **** #ifdef RECEIVER_STM32PPM
  24:../AeroQuad32/platform_aeroquad32.h ****   static byte receiverPinPPM = Port2Pin('D', 15);
  25:../AeroQuad32/platform_aeroquad32.h **** #elif defined ReceiverSBUS
  26:../AeroQuad32/platform_aeroquad32.h ****   // Do nothing
  27:../AeroQuad32/platform_aeroquad32.h **** #else
  28:../AeroQuad32/platform_aeroquad32.h ****   static byte receiverPin[] = {
  29:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 12),
  30:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 13),
  31:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 14),
  32:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 15),
  33:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E',  9),
  34:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 11),
  35:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 13),
  36:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 14)
  37:../AeroQuad32/platform_aeroquad32.h ****   };
  38:../AeroQuad32/platform_aeroquad32.h **** #endif
  39:../AeroQuad32/platform_aeroquad32.h **** 
  40:../AeroQuad32/platform_aeroquad32.h **** #define STM32_BOARD_TYPE "aeroquad32"
  41:../AeroQuad32/platform_aeroquad32.h **** #define LED_Green  Port2Pin('E', 6)
  42:../AeroQuad32/platform_aeroquad32.h **** #define LED_Red    Port2Pin('E', 5)
  43:../AeroQuad32/platform_aeroquad32.h **** #define LED_Yellow LED_Red
  44:../AeroQuad32/platform_aeroquad32.h **** 
  45:../AeroQuad32/platform_aeroquad32.h **** #define BATT_ANALOG_INPUT	Port2Pin('C', 0)
  46:../AeroQuad32/platform_aeroquad32.h **** #define A1       Port2Pin('B',0)
  47:../AeroQuad32/platform_aeroquad32.h **** #define A2       Port2Pin('C',4)
  48:../AeroQuad32/platform_aeroquad32.h **** #define A3       Port2Pin('B',1)
  49:../AeroQuad32/platform_aeroquad32.h **** #define A4       Port2Pin('C',5)
  50:../AeroQuad32/platform_aeroquad32.h **** #define A5       Port2Pin('C',2)
  51:../AeroQuad32/platform_aeroquad32.h **** #define A6       Port2Pin('C',3)
  52:../AeroQuad32/platform_aeroquad32.h **** 
  53:../AeroQuad32/platform_aeroquad32.h **** // external LED drivers
  54:../AeroQuad32/platform_aeroquad32.h **** #define PLED1 Port2Pin('D',  7)
  55:../AeroQuad32/platform_aeroquad32.h **** #define PLED2 Port2Pin('E',  0)
  56:../AeroQuad32/platform_aeroquad32.h **** #define PLED3 Port2Pin('E',  1)
  57:../AeroQuad32/platform_aeroquad32.h **** #define PLED4 Port2Pin('D',  4) 
  58:../AeroQuad32/platform_aeroquad32.h **** 
  59:../AeroQuad32/platform_aeroquad32.h **** #include <Device_I2C.h>
  60:../AeroQuad32/platform_aeroquad32.h **** 
  61:../AeroQuad32/platform_aeroquad32.h **** #include <Gyroscope_MPU6000.h>
  62:../AeroQuad32/platform_aeroquad32.h **** #include <Accelerometer_MPU6000.h>
  63:../AeroQuad32/platform_aeroquad32.h **** 
  64:../AeroQuad32/platform_aeroquad32.h **** // heading mag hold declaration
  65:../AeroQuad32/platform_aeroquad32.h **** #ifdef HeadingMagHold
  66:../AeroQuad32/platform_aeroquad32.h ****   #include <Compass.h>
  67:../AeroQuad32/platform_aeroquad32.h ****   #define HMC5883L
  68:../AeroQuad32/platform_aeroquad32.h **** #endif
  69:../AeroQuad32/platform_aeroquad32.h **** 
  70:../AeroQuad32/platform_aeroquad32.h **** // Altitude declaration
  71:../AeroQuad32/platform_aeroquad32.h **** #ifdef AltitudeHoldBaro
  72:../AeroQuad32/platform_aeroquad32.h ****   #define MS5611
  73:../AeroQuad32/platform_aeroquad32.h **** #endif
  74:../AeroQuad32/platform_aeroquad32.h **** 
  75:../AeroQuad32/platform_aeroquad32.h **** #ifdef AltitudeHoldRangeFinder
  76:../AeroQuad32/platform_aeroquad32.h ****   #define XLMAXSONAR
  77:../AeroQuad32/platform_aeroquad32.h **** #endif
  78:../AeroQuad32/platform_aeroquad32.h **** 
  79:../AeroQuad32/platform_aeroquad32.h **** // Battery Monitor declaration
  80:../AeroQuad32/platform_aeroquad32.h **** #ifdef BattMonitor
  81:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_AREF         3.3		// V
  82:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_R_HIGH       10.0		// kOhm
  83:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_R_LOW        1.5		// kOhm
  84:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_DIODE_LOSS		0.0
  85:../AeroQuad32/platform_aeroquad32.h ****   #define BattDefaultConfig DEFINE_BATTERY(0, BATT_ANALOG_INPUT, (BATT_AREF * (BATT_R_HIGH + BATT_R
  86:../AeroQuad32/platform_aeroquad32.h **** #endif
  87:../AeroQuad32/platform_aeroquad32.h **** 
  88:../AeroQuad32/platform_aeroquad32.h **** #ifdef OSD
  89:../AeroQuad32/platform_aeroquad32.h ****   #define MAX7456_OSD
  90:../AeroQuad32/platform_aeroquad32.h **** #endif
  91:../AeroQuad32/platform_aeroquad32.h **** 
  92:../AeroQuad32/platform_aeroquad32.h **** #ifdef CameraControl
  93:../AeroQuad32/platform_aeroquad32.h ****   #define CameraControl_STM32
  94:../AeroQuad32/platform_aeroquad32.h **** #endif
  95:../AeroQuad32/platform_aeroquad32.h **** 
  96:../AeroQuad32/platform_aeroquad32.h **** void initPlatform() {
 2387              		.loc 13 96 0
 2388              		.cfi_startproc
 2389              		@ args = 0, pretend = 0, frame = 0
 2390              		@ frame_needed = 0, uses_anonymous_args = 0
 2391 0000 10B5     		push	{r4, lr}
 2392              	.LCFI25:
 2393              		.cfi_def_cfa_offset 8
 2394              		.cfi_offset 14, -4
 2395              		.cfi_offset 4, -8
 2396              	.LBB59:
  97:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Green, OUTPUT);
 2397              		.loc 13 97 0
 2398 0002 4620     		movs	r0, #70
 2399 0004 0021     		movs	r1, #0
 2400 0006 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2401              	.LVL122:
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2402              		.loc 13 98 0
 2403 000a 0024     		movs	r4, #0
 2404              	.LVL123:
 2405              	.L144:
 2406              	.LBB60:
  99:../AeroQuad32/platform_aeroquad32.h ****     digitalWrite(LED_Green, ledloop & 1);
 2407              		.loc 13 99 0 discriminator 2
 2408 000c 4620     		movs	r0, #70
 2409 000e 04F00101 		and	r1, r4, #1
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2410              		.loc 13 98 0 discriminator 2
 2411 0012 0134     		adds	r4, r4, #1
 2412              		.loc 13 99 0 discriminator 2
 2413 0014 FFF7FEFF 		bl	_Z12digitalWritehh
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2414              		.loc 13 98 0 discriminator 2
 2415 0018 E4B2     		uxtb	r4, r4
 100:../AeroQuad32/platform_aeroquad32.h ****     delay(50);
 2416              		.loc 13 100 0 discriminator 2
 2417 001a 3220     		movs	r0, #50
 2418 001c FFF7FEFF 		bl	_Z5delaym
 2419              	.LVL124:
  98:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2420              		.loc 13 98 0 discriminator 2
 2421 0020 0A2C     		cmp	r4, #10
 2422 0022 F3D1     		bne	.L144
 2423              	.LBE60:
 101:../AeroQuad32/platform_aeroquad32.h ****   }
 102:../AeroQuad32/platform_aeroquad32.h **** 
 103:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Red, OUTPUT);
 2424              		.loc 13 103 0
 2425 0024 4520     		movs	r0, #69
 2426 0026 0021     		movs	r1, #0
 2427 0028 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 104:../AeroQuad32/platform_aeroquad32.h ****   digitalWrite(LED_Red, LOW);
 2428              		.loc 13 104 0
 2429 002c 4520     		movs	r0, #69
 2430 002e 0021     		movs	r1, #0
 2431 0030 FFF7FEFF 		bl	_Z12digitalWritehh
 105:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Yellow, OUTPUT);
 2432              		.loc 13 105 0
 2433 0034 4520     		movs	r0, #69
 2434 0036 0021     		movs	r1, #0
 2435 0038 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 106:../AeroQuad32/platform_aeroquad32.h ****   digitalWrite(LED_Yellow, LOW);
 2436              		.loc 13 106 0
 2437 003c 4520     		movs	r0, #69
 2438 003e 0021     		movs	r1, #0
 2439 0040 FFF7FEFF 		bl	_Z12digitalWritehh
 107:../AeroQuad32/platform_aeroquad32.h **** 
 108:../AeroQuad32/platform_aeroquad32.h ****   pinMode(BATT_ANALOG_INPUT, INPUT_ANALOG);
 2440              		.loc 13 108 0
 2441 0044 2020     		movs	r0, #32
 2442 0046 0321     		movs	r1, #3
 2443 0048 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 109:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A1, INPUT_ANALOG);
 2444              		.loc 13 109 0
 2445 004c 1020     		movs	r0, #16
 2446 004e 0321     		movs	r1, #3
 2447 0050 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 110:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A2, INPUT_ANALOG);
 2448              		.loc 13 110 0
 2449 0054 2420     		movs	r0, #36
 2450 0056 0321     		movs	r1, #3
 2451 0058 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 111:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A3, INPUT_ANALOG);
 2452              		.loc 13 111 0
 2453 005c 1120     		movs	r0, #17
 2454 005e 0321     		movs	r1, #3
 2455 0060 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 112:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A4, INPUT_ANALOG);
 2456              		.loc 13 112 0
 2457 0064 2520     		movs	r0, #37
 2458 0066 0321     		movs	r1, #3
 2459 0068 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 113:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A5, INPUT_ANALOG);
 2460              		.loc 13 113 0
 2461 006c 2220     		movs	r0, #34
 2462 006e 0321     		movs	r1, #3
 2463 0070 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 114:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A6, INPUT_ANALOG);
 2464              		.loc 13 114 0
 2465 0074 0321     		movs	r1, #3
 2466 0076 2320     		movs	r0, #35
 2467 0078 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 115:../AeroQuad32/platform_aeroquad32.h **** 
 116:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED1, OUTPUT);
 2468              		.loc 13 116 0
 2469 007c 3720     		movs	r0, #55
 2470 007e 0021     		movs	r1, #0
 2471 0080 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 117:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED2, OUTPUT);
 2472              		.loc 13 117 0
 2473 0084 4020     		movs	r0, #64
 2474 0086 0021     		movs	r1, #0
 2475 0088 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 118:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED3, OUTPUT);
 2476              		.loc 13 118 0
 2477 008c 4120     		movs	r0, #65
 2478 008e 0021     		movs	r1, #0
 2479 0090 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 119:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED4, OUTPUT);
 2480              		.loc 13 119 0
 2481 0094 3420     		movs	r0, #52
 2482 0096 0021     		movs	r1, #0
 2483 0098 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 120:../AeroQuad32/platform_aeroquad32.h **** 
 121:../AeroQuad32/platform_aeroquad32.h ****   // I2C setup
 122:../AeroQuad32/platform_aeroquad32.h ****   Wire.begin(Port2Pin('B', 7), Port2Pin('B', 6)); // I2C1_SDA PB7, I2C1_SCL PB6
 2484              		.loc 13 122 0
 2485 009c 0448     		ldr	r0, .L146
 2486 009e 1721     		movs	r1, #23
 2487 00a0 1622     		movs	r2, #22
 2488 00a2 FFF7FEFF 		bl	_ZN7TwoWire5beginEhh
 123:../AeroQuad32/platform_aeroquad32.h **** 
 124:../AeroQuad32/platform_aeroquad32.h ****   #if !defined(USE_USB_SERIAL)
 125:../AeroQuad32/platform_aeroquad32.h ****     SerialUSB.begin();
 2489              		.loc 13 125 0
 2490 00a6 0348     		ldr	r0, .L146+4
 2491              	.LBE59:
 126:../AeroQuad32/platform_aeroquad32.h ****   #endif
 127:../AeroQuad32/platform_aeroquad32.h **** }
 2492              		.loc 13 127 0
 2493 00a8 BDE81040 		pop	{r4, lr}
 2494              	.LBB61:
 125:../AeroQuad32/platform_aeroquad32.h ****     SerialUSB.begin();
 2495              		.loc 13 125 0
 2496 00ac FFF7FEBF 		b	_ZN9USBSerial5beginEv
 2497              	.L147:
 2498              		.align	2
 2499              	.L146:
 2500 00b0 00000000 		.word	Wire
 2501 00b4 00000000 		.word	SerialUSB
 2502              	.LBE61:
 2503              		.cfi_endproc
 2504              	.LFE160:
 2506              		.section	.text._Z42initializePlatformSpecificAccelCalibrationv,"ax",%progbits
 2507              		.align	1
 2508              		.global	_Z42initializePlatformSpecificAccelCalibrationv
 2509              		.thumb
 2510              		.thumb_func
 2512              	_Z42initializePlatformSpecificAccelCalibrationv:
 2513              	.LFB161:
 128:../AeroQuad32/platform_aeroquad32.h **** 
 129:../AeroQuad32/platform_aeroquad32.h **** // called when eeprom is initialized
 130:../AeroQuad32/platform_aeroquad32.h **** void initializePlatformSpecificAccelCalibration() {
 2514              		.loc 13 130 0
 2515              		.cfi_startproc
 2516              		@ args = 0, pretend = 0, frame = 0
 2517              		@ frame_needed = 0, uses_anonymous_args = 0
 2518              		@ link register save eliminated.
 131:../AeroQuad32/platform_aeroquad32.h ****   // Kenny default value, a real accel calibration is strongly recommended
 132:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[XAXIS] = 0.0011970000;
 2519              		.loc 13 132 0
 2520 0000 034B     		ldr	r3, .L149
 2521 0002 0449     		ldr	r1, .L149+4
 133:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[YAXIS] = -0.0012050000;
 2522              		.loc 13 133 0
 2523 0004 0448     		ldr	r0, .L149+8
 134:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[ZAXIS] = -0.0011770000;
 2524              		.loc 13 134 0
 2525 0006 054A     		ldr	r2, .L149+12
 132:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[XAXIS] = 0.0011970000;
 2526              		.loc 13 132 0
 2527 0008 1960     		str	r1, [r3, #0]	@ float
 133:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[YAXIS] = -0.0012050000;
 2528              		.loc 13 133 0
 2529 000a 5860     		str	r0, [r3, #4]	@ float
 2530              		.loc 13 134 0
 2531 000c 9A60     		str	r2, [r3, #8]	@ float
 135:../AeroQuad32/platform_aeroquad32.h ****   #ifdef HeadingMagHold
 136:../AeroQuad32/platform_aeroquad32.h ****     magBias[XAXIS]  = 152.000000;
 137:../AeroQuad32/platform_aeroquad32.h ****     magBias[YAXIS]  = 24.000000;
 138:../AeroQuad32/platform_aeroquad32.h ****     magBias[ZAXIS]  = 16.500000;
 139:../AeroQuad32/platform_aeroquad32.h ****   #endif
 140:../AeroQuad32/platform_aeroquad32.h **** 
 141:../AeroQuad32/platform_aeroquad32.h **** }
 2532              		.loc 13 141 0
 2533 000e 7047     		bx	lr
 2534              	.L150:
 2535              		.align	2
 2536              	.L149:
 2537 0010 00000000 		.word	.LANCHOR27
 2538 0014 A8E49C3A 		.word	983360680
 2539 0018 17F19DBA 		.word	-1164054249
 2540 001c 91459ABA 		.word	-1164294767
 2541              		.cfi_endproc
 2542              	.LFE161:
 2544              		.section	.text._Z22measureCriticalSensorsv,"ax",%progbits
 2545              		.align	1
 2546              		.global	_Z22measureCriticalSensorsv
 2547              		.thumb
 2548              		.thumb_func
 2550              	_Z22measureCriticalSensorsv:
 2551              	.LFB162:
 142:../AeroQuad32/platform_aeroquad32.h **** 
 143:../AeroQuad32/platform_aeroquad32.h **** unsigned long previousMeasureCriticalSensorsTime = 0;
 144:../AeroQuad32/platform_aeroquad32.h **** void measureCriticalSensors() {
 2552              		.loc 13 144 0
 2553              		.cfi_startproc
 2554              		@ args = 0, pretend = 0, frame = 0
 2555              		@ frame_needed = 0, uses_anonymous_args = 0
 2556 0000 38B5     		push	{r3, r4, r5, lr}
 2557              	.LCFI26:
 2558              		.cfi_def_cfa_offset 16
 2559              		.cfi_offset 14, -4
 2560              		.cfi_offset 5, -8
 2561              		.cfi_offset 4, -12
 2562              		.cfi_offset 3, -16
 145:../AeroQuad32/platform_aeroquad32.h ****   // read sensors not faster than every 1 ms
 146:../AeroQuad32/platform_aeroquad32.h ****   if (currentTime - previousMeasureCriticalSensorsTime >= 1000) {
 2563              		.loc 13 146 0
 2564 0002 074D     		ldr	r5, .L153
 2565 0004 074C     		ldr	r4, .L153+4
 2566 0006 2A68     		ldr	r2, [r5, #0]
 2567 0008 2068     		ldr	r0, [r4, #0]
 2568 000a 131A     		subs	r3, r2, r0
 2569 000c B3F57A7F 		cmp	r3, #1000
 2570 0010 05D3     		bcc	.L151
 147:../AeroQuad32/platform_aeroquad32.h ****     measureGyroSum();
 2571              		.loc 13 147 0
 2572 0012 FFF7FEFF 		bl	_Z14measureGyroSumv
 148:../AeroQuad32/platform_aeroquad32.h ****     measureAccelSum();
 2573              		.loc 13 148 0
 2574 0016 FFF7FEFF 		bl	_Z15measureAccelSumv
 149:../AeroQuad32/platform_aeroquad32.h ****     previousMeasureCriticalSensorsTime = currentTime;
 2575              		.loc 13 149 0
 2576 001a 2968     		ldr	r1, [r5, #0]
 2577 001c 2160     		str	r1, [r4, #0]
 2578              	.L151:
 2579 001e 38BD     		pop	{r3, r4, r5, pc}
 2580              	.L154:
 2581              		.align	2
 2582              	.L153:
 2583 0020 00000000 		.word	.LANCHOR7
 2584 0024 00000000 		.word	.LANCHOR32
 2585              		.cfi_endproc
 2586              	.LFE162:
 2588              		.section	.text._Z29initializeBaseKinematicsParamv,"ax",%progbits
 2589              		.align	1
 2590              		.global	_Z29initializeBaseKinematicsParamv
 2591              		.thumb
 2592              		.thumb_func
 2594              	_Z29initializeBaseKinematicsParamv:
 2595              	.LFB163:
 2596              		.file 14 "../Libraries/AQ_Kinematics/Kinematics.h"
   1:../Libraries/AQ_Kinematics/Kinematics.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics.h **** #ifndef _AQ_KINEMATICS_
  22:../Libraries/AQ_Kinematics/Kinematics.h **** #define _AQ_KINEMATICS_
  23:../Libraries/AQ_Kinematics/Kinematics.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics.h **** #include "GlobalDefined.h"
  25:../Libraries/AQ_Kinematics/Kinematics.h **** 
  26:../Libraries/AQ_Kinematics/Kinematics.h **** #define CF 0
  27:../Libraries/AQ_Kinematics/Kinematics.h **** #define KF 1
  28:../Libraries/AQ_Kinematics/Kinematics.h **** #define DCM 2
  29:../Libraries/AQ_Kinematics/Kinematics.h **** #define ARG 3
  30:../Libraries/AQ_Kinematics/Kinematics.h **** #define MARG 4
  31:../Libraries/AQ_Kinematics/Kinematics.h **** 
  32:../Libraries/AQ_Kinematics/Kinematics.h **** // This class is responsible for calculating vehicle attitude
  33:../Libraries/AQ_Kinematics/Kinematics.h **** byte kinematicsType = 0;
  34:../Libraries/AQ_Kinematics/Kinematics.h **** float kinematicsAngle[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Kinematics/Kinematics.h **** float gyroAngle[2] = {0.0,0.0};
  36:../Libraries/AQ_Kinematics/Kinematics.h **** float correctedRateVector[3] = {0.0,0.0,0.0};
  37:../Libraries/AQ_Kinematics/Kinematics.h **** float earthAccel[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Kinematics/Kinematics.h **** 
  39:../Libraries/AQ_Kinematics/Kinematics.h **** float accelCutoff = 0.0;
  40:../Libraries/AQ_Kinematics/Kinematics.h **** 
  41:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeBaseKinematicsParam() {
 2597              		.loc 14 41 0
 2598              		.cfi_startproc
 2599              		@ args = 0, pretend = 0, frame = 0
 2600              		@ frame_needed = 0, uses_anonymous_args = 0
 2601              		@ link register save eliminated.
 2602              	.LVL125:
 2603              	.LBB62:
 2604              	.LBB63:
  42:../Libraries/AQ_Kinematics/Kinematics.h **** 
  43:../Libraries/AQ_Kinematics/Kinematics.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2605              		.loc 14 44 0
 2606 0000 0448     		ldr	r0, .L156
 2607              	.LBE63:
  45:../Libraries/AQ_Kinematics/Kinematics.h ****   }
  46:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[XAXIS] = 0;
 2608              		.loc 14 46 0
 2609 0002 054A     		ldr	r2, .L156+4
 2610              	.LBB64:
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2611              		.loc 14 44 0
 2612 0004 0023     		movs	r3, #0
 2613 0006 0360     		str	r3, [r0, #0]	@ float
 2614              	.LVL126:
 2615 0008 4360     		str	r3, [r0, #4]	@ float
 2616              	.LVL127:
 2617 000a 8360     		str	r3, [r0, #8]	@ float
 2618              	.LVL128:
 2619              	.LBE64:
 2620              		.loc 14 46 0
 2621 000c 1360     		str	r3, [r2, #0]	@ float
  47:../Libraries/AQ_Kinematics/Kinematics.h ****   gyroAngle[YAXIS] = 0;
 2622              		.loc 14 47 0
 2623 000e 5360     		str	r3, [r2, #4]	@ float
 2624              	.LBE62:
  48:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2625              		.loc 14 48 0
 2626 0010 7047     		bx	lr
 2627              	.L157:
 2628 0012 00BF     		.align	2
 2629              	.L156:
 2630 0014 00000000 		.word	.LANCHOR33
 2631 0018 00000000 		.word	.LANCHOR34
 2632              		.cfi_endproc
 2633              	.LFE163:
 2635              		.section	.text._Z27kinematicsGetDegreesHeadingh,"ax",%progbits
 2636              		.align	1
 2637              		.global	_Z27kinematicsGetDegreesHeadingh
 2638              		.thumb
 2639              		.thumb_func
 2641              	_Z27kinematicsGetDegreesHeadingh:
 2642              	.LFB164:
  49:../Libraries/AQ_Kinematics/Kinematics.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeKinematics(float hdgX, float hdgY);
  51:../Libraries/AQ_Kinematics/Kinematics.h **** void calculateKinematics(float rollRate,           float pitchRate,     float yawRate,       
  52:../Libraries/AQ_Kinematics/Kinematics.h ****                          float longitudinalAccel,  float lateralAccel,  float verticalAccel, 
  53:../Libraries/AQ_Kinematics/Kinematics.h ****                          float G_Dt);
  54:../Libraries/AQ_Kinematics/Kinematics.h **** float getGyroUnbias(byte axis);
  55:../Libraries/AQ_Kinematics/Kinematics.h **** void calibrateKinematics();
  56:../Libraries/AQ_Kinematics/Kinematics.h ****  
  57:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns the kinematicsAngle of a specific axis in SI units (radians)
  58:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getData(byte axis) {
  59:../Libraries/AQ_Kinematics/Kinematics.h **** //    return kinematicsAngle[axis];
  60:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  61:../Libraries/AQ_Kinematics/Kinematics.h ****   // return heading as +PI/-PI
  62:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getHeading(byte axis) {
  63:../Libraries/AQ_Kinematics/Kinematics.h **** //    return(kinematicsAngle[axis]);
  64:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  65:../Libraries/AQ_Kinematics/Kinematics.h ****   
  66:../Libraries/AQ_Kinematics/Kinematics.h ****   // This really needs to be in Radians to be consistent
  67:../Libraries/AQ_Kinematics/Kinematics.h ****   // I'll fix later - AKA
  68:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns heading in degrees as 0-360
  69:../Libraries/AQ_Kinematics/Kinematics.h **** const float kinematicsGetDegreesHeading(byte axis) {
 2643              		.loc 14 69 0
 2644              		.cfi_startproc
 2645              		@ args = 0, pretend = 0, frame = 0
 2646              		@ frame_needed = 0, uses_anonymous_args = 0
 2647              		@ link register save eliminated.
 2648              	.LVL129:
 2649              	.LBB65:
  70:../Libraries/AQ_Kinematics/Kinematics.h ****   float tDegrees;
  71:../Libraries/AQ_Kinematics/Kinematics.h ****     
  72:../Libraries/AQ_Kinematics/Kinematics.h ****   tDegrees = degrees(kinematicsAngle[axis]);
 2650              		.loc 14 72 0
 2651 0000 0A49     		ldr	r1, .L162
 2652 0002 01EB8003 		add	r3, r1, r0, lsl #2
 2653 0006 93ED007A 		flds	s14, [r3, #0]
 2654 000a DFED097A 		flds	s15, .L162+4
 2655 000e 67EE277A 		fmuls	s15, s14, s15
 2656              	.LVL130:
  73:../Libraries/AQ_Kinematics/Kinematics.h ****   if (tDegrees < 0.0)
 2657              		.loc 14 73 0
 2658 0012 F5EEC07A 		fcmpezs	s15
 2659 0016 F1EE10FA 		fmstat
  74:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees + 360.0);
 2660              		.loc 14 74 0
 2661 001a 44BF     		itt	mi
 2662 001c 9FED057A 		fldsmi	s14, .L162+8
 2663 0020 77EE877A 		faddsmi	s15, s15, s14
 2664              	.LVL131:
 2665              	.LBE65:
  75:../Libraries/AQ_Kinematics/Kinematics.h ****   else
  76:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees);
  77:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2666              		.loc 14 77 0
 2667 0024 17EE900A 		fmrs	r0, s15
 2668              	.LVL132:
 2669 0028 7047     		bx	lr
 2670              	.L163:
 2671 002a 00BF     		.align	2
 2672              	.L162:
 2673 002c 00000000 		.word	.LANCHOR33
 2674 0030 E12E6542 		.word	1113927393
 2675 0034 0000B443 		.word	1135869952
 2676              		.cfi_endproc
 2677              	.LFE164:
 2679              		.global	__aeabi_f2d
 2680              		.global	__aeabi_d2f
 2681              		.section	.text._Z9argUpdatefffffff,"ax",%progbits
 2682              		.align	1
 2683              		.global	_Z9argUpdatefffffff
 2684              		.thumb
 2685              		.thumb_func
 2687              	_Z9argUpdatefffffff:
 2688              	.LFB165:
 2689              		.file 15 "../Libraries/AQ_Kinematics/Kinematics_ARG.h"
   1:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #ifndef _AQ_KINEMATICS_ARG_
  22:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #define _AQ_KINEMATICS_ARG_
  23:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  25:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // IMU.c
  26:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // S.O.H. Madgwick
  27:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // 25th September 2010
  28:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  29:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Description:
  30:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  31:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Quaternion implementation of the 'DCM filter' [Mayhony et al].
  32:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  33:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must define 'halfT' as the (sample period / 2), and the filter gains 'Kp' and 'Ki'.
  34:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  35:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Global variables 'q0', 'q1', 'q2', 'q3' are the quaternion elements representing the estimated
  36:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // orientation.  See my report for an overview of the use of quaternions in this application.
  37:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  38:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must call 'IMUupdate()' every sample period and parse calibrated gyroscope ('gx', 'gy', 'gz
  39:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // and accelerometer ('ax', 'ay', 'ay') data.  Gyroscope units are radians/second, accelerometer 
  40:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // units are irrelevant as the vector is normalised.
  41:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  42:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  43:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  44:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  45:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  46:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // ARG - Accelerometer, Rate Gyro
  47:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  48:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  49:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include "Kinematics.h"
  51:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  52:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include <AQMath.h>
  53:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  54:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Kp = 0.0;                   					// proportional gain governs rate of convergence to accelero
  55:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Ki = 0.0;                   					// integral gain governs rate of convergence of gyroscope bi
  56:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float halfT = 0.0;                					// half the sample period
  57:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float q0 = 0.0, q1 = 0.0, q2 = 0.0, q3 = 0.0;       // quaternion elements representing the estimat
  58:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float exInt = 0.0, eyInt = 0.0, ezInt = 0.0;  		// scaled integral error
  59:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  60:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEx = 0.0;
  61:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEy = 0.0;
  62:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEz = 0.0;
  63:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  64:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  65:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // argUpdate
  66:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2690              		.loc 15 67 0
 2691              		.cfi_startproc
 2692              		@ args = 12, pretend = 0, frame = 0
 2693              		@ frame_needed = 0, uses_anonymous_args = 0
 2694              	.LVL133:
 2695 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2696              	.LCFI27:
 2697              		.cfi_def_cfa_offset 40
 2698              		.cfi_offset 14, -4
 2699              		.cfi_offset 11, -8
 2700              		.cfi_offset 10, -12
 2701              		.cfi_offset 9, -16
 2702              		.cfi_offset 8, -20
 2703              		.cfi_offset 7, -24
 2704              		.cfi_offset 6, -28
 2705              		.cfi_offset 5, -32
 2706              		.cfi_offset 4, -36
 2707              		.cfi_offset 3, -40
 2708 0004 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 2709              	.LCFI28:
 2710              		.cfi_def_cfa_offset 64
 2711              		.cfi_offset 84, -48
 2712              		.cfi_offset 82, -56
 2713              		.cfi_offset 80, -64
 2714              		.loc 15 67 0
 2715 0008 DDED108A 		flds	s17, [sp, #64]
 2716 000c 08EE103A 		fmsr	s16, r3
 2717              	.LBB66:
  68:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  69:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float norm;
  70:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float vx, vy, vz;
  71:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float q0i, q1i, q2i, q3i;
  72:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float ex, ey, ez;
  73:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
  75:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  76:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise the measurements
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2718              		.loc 15 77 0
 2719 0010 68EEA82A 		fmuls	s5, s17, s17
 2720 0014 48EE082A 		fmacs	s5, s16, s16
 2721              	.LBE66:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2722              		.loc 15 67 0
 2723 0018 9DED119A 		flds	s18, [sp, #68]
 2724              	.LBB67:
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2725              		.loc 15 74 0
 2726 001c DDED127A 		flds	s15, [sp, #72]
 2727              		.loc 15 77 0
 2728 0020 49EE092A 		fmacs	s5, s18, s18
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2729              		.loc 15 74 0
 2730 0024 B6EE003A 		fconsts	s6, #96
 2731 0028 27EE833A 		fmuls	s6, s15, s6
 2732 002c DFF83092 		ldr	r9, .L168+20
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
  81:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****      	
  82:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // estimated direction of gravity and flux (v and w)
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2733              		.loc 15 83 0
 2734 0030 864C     		ldr	r4, .L168
 2735 0032 874F     		ldr	r7, .L168+4
 2736 0034 874D     		ldr	r5, .L168+8
 2737 0036 884E     		ldr	r6, .L168+12
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
  86:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  87:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // error is sum of cross product between reference direction of fields and direction measured by 
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
  91:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  92:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integral error scaled integral gain
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2738              		.loc 15 93 0
 2739 0038 DFF828A2 		ldr	sl, .L168+24
 2740 003c DFF828B2 		ldr	fp, .L168+28
  94:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEx,ex)) {
 2741              		.loc 15 94 0
 2742 0040 DFF82882 		ldr	r8, .L168+32
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2743              		.loc 15 74 0
 2744 0044 89ED003A 		fsts	s6, [r9, #0]
 2745              	.LBE67:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2746              		.loc 15 67 0
 2747 0048 09EE900A 		fmsr	s19, r0
 2748              	.LBB68:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2749              		.loc 15 77 0
 2750 004c 12EE900A 		fmrs	r0, s5
 2751              	.LVL134:
 2752              	.LBE68:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2753              		.loc 15 67 0
 2754 0050 0AEE902A 		fmsr	s21, r2
 2755 0054 0AEE101A 		fmsr	s20, r1
 2756              	.LBB69:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2757              		.loc 15 77 0
 2758 0058 FFF7FEFF 		bl	__aeabi_f2d
 2759              	.LVL135:
 2760 005c FFF7FEFF 		bl	sqrt
 2761 0060 FFF7FEFF 		bl	__aeabi_d2f
 2762 0064 02EE100A 		fmsr	s4, r0
 2763              	.LVL136:
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
 2764              		.loc 15 79 0
 2765 0068 88EE825A 		fdivs	s10, s17, s4
 2766              		.loc 15 94 0
 2767 006c D8F80000 		ldr	r0, [r8, #0]	@ float
 2768              	.LVL137:
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
 2769              		.loc 15 80 0
 2770 0070 C9EE023A 		fdivs	s7, s18, s4
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2771              		.loc 15 83 0
 2772 0074 D4ED000A 		flds	s1, [r4, #0]
 2773 0078 97ED006A 		flds	s12, [r7, #0]
 2774 007c D5ED006A 		flds	s13, [r5, #0]
 2775 0080 96ED000A 		flds	s0, [r6, #0]
 2776 0084 66EE261A 		fmuls	s3, s12, s13
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2777              		.loc 15 84 0
 2778 0088 26EEA01A 		fmuls	s2, s13, s1
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2779              		.loc 15 83 0
 2780 008c 50EE201A 		fmscs	s3, s0, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2781              		.loc 15 84 0
 2782 0090 06EE001A 		fmacs	s2, s12, s0
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2783              		.loc 15 85 0
 2784 0094 20EE000A 		fmuls	s0, s0, s0
 2785 0098 16EE060A 		fmscs	s0, s12, s12
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
 2786              		.loc 15 78 0
 2787 009c 88EE024A 		fdivs	s8, s16, s4
 2788              	.LVL138:
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2789              		.loc 15 85 0
 2790 00a0 06EEE60A 		fnmacs	s0, s13, s13
 2791 00a4 00EEA00A 		fmacs	s0, s1, s1
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2792              		.loc 15 84 0
 2793 00a8 71EE015A 		fadds	s11, s2, s2
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
 2794              		.loc 15 88 0
 2795 00ac 20EE058A 		fmuls	s16, s0, s10
 2796 00b0 15EEA38A 		fmscs	s16, s11, s7
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2797              		.loc 15 93 0
 2798 00b4 DAED007A 		flds	s15, [sl, #0]
 2799 00b8 9BED007A 		flds	s14, [fp, #0]
 2800 00bc 48EE077A 		fmacs	s15, s16, s14
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2801              		.loc 15 83 0
 2802 00c0 71EEA14A 		fadds	s9, s3, s3
 2803              	.LVL139:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 2804              		.loc 15 90 0
 2805 00c4 25EE849A 		fmuls	s18, s11, s8
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 2806              		.loc 15 89 0
 2807 00c8 64EEA38A 		fmuls	s17, s9, s7
 2808              		.loc 15 94 0
 2809 00cc 18EE101A 		fmrs	r1, s16
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 2810              		.loc 15 89 0
 2811 00d0 50EE048A 		fmscs	s17, s0, s8
 2812              	.LVL140:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 2813              		.loc 15 90 0
 2814 00d4 14EE859A 		fmscs	s18, s9, s10
 2815              	.LVL141:
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2816              		.loc 15 93 0
 2817 00d8 CAED007A 		fsts	s15, [sl, #0]
 2818              		.loc 15 94 0
 2819 00dc FFF7FEFF 		bl	_Z10isSwitchedff
 2820              	.LVL142:
 2821 00e0 4346     		mov	r3, r8
 2822 00e2 10B1     		cbz	r0, .L165
  95:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     exInt = 0.0;
 2823              		.loc 15 95 0
 2824 00e4 0022     		movs	r2, #0
 2825 00e6 CAF80020 		str	r2, [sl, #0]	@ float
 2826              	.L165:
  96:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
  98:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2827              		.loc 15 99 0
 2828 00ea DFF88491 		ldr	r9, .L168+36
 100:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEy,ey)) {
 2829              		.loc 15 100 0
 2830 00ee DFF88481 		ldr	r8, .L168+40
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2831              		.loc 15 99 0
 2832 00f2 D9ED004A 		flds	s9, [r9, #0]
 2833 00f6 9BED007A 		flds	s14, [fp, #0]
 2834 00fa 48EE874A 		fmacs	s9, s17, s14
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
 2835              		.loc 15 97 0
 2836 00fe 83ED008A 		fsts	s16, [r3, #0]
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2837              		.loc 15 99 0
 2838 0102 C9ED004A 		fsts	s9, [r9, #0]
 2839              		.loc 15 100 0
 2840 0106 D8F80000 		ldr	r0, [r8, #0]	@ float
 2841 010a 18EE901A 		fmrs	r1, s17
 2842 010e FFF7FEFF 		bl	_Z10isSwitchedff
 2843 0112 4346     		mov	r3, r8
 2844 0114 10B1     		cbz	r0, .L166
 101:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     eyInt = 0.0;
 2845              		.loc 15 101 0
 2846 0116 0020     		movs	r0, #0
 2847 0118 C9F80000 		str	r0, [r9, #0]	@ float
 2848              	.L166:
 102:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 104:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 2849              		.loc 15 105 0
 2850 011c DFF85881 		ldr	r8, .L168+44
 2851 0120 9BED004A 		flds	s8, [fp, #0]
 2852 0124 98ED005A 		flds	s10, [r8, #0]
 2853 0128 09EE045A 		fmacs	s10, s18, s8
 106:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEz,ez)) {
 2854              		.loc 15 106 0
 2855 012c DFF84CB1 		ldr	fp, .L168+48
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 2856              		.loc 15 103 0
 2857 0130 C3ED008A 		fsts	s17, [r3, #0]
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 2858              		.loc 15 105 0
 2859 0134 88ED005A 		fsts	s10, [r8, #0]
 2860              		.loc 15 106 0
 2861 0138 DBF80000 		ldr	r0, [fp, #0]	@ float
 2862 013c 19EE101A 		fmrs	r1, s18
 2863 0140 FFF7FEFF 		bl	_Z10isSwitchedff
 2864 0144 4346     		mov	r3, r8
 2865 0146 5A46     		mov	r2, fp
 2866 0148 08B1     		cbz	r0, .L167
 107:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     ezInt = 0.0;
 2867              		.loc 15 107 0
 2868 014a 0021     		movs	r1, #0
 2869 014c 1960     		str	r1, [r3, #0]	@ float
 2870              	.L167:
 108:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 109:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = ez;
 2871              		.loc 15 109 0
 2872 014e 82ED009A 		fsts	s18, [r2, #0]
 110:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 111:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // adjusted gyroscope measurements
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2873              		.loc 15 112 0
 2874 0152 424A     		ldr	r2, .L168+16
 2875 0154 D2ED000A 		flds	s1, [r2, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 2876              		.loc 15 114 0
 2877 0158 40EE89AA 		fmacs	s21, s1, s18
 2878              	.LVL143:
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2879              		.loc 15 112 0
 2880 015c 40EE889A 		fmacs	s19, s1, s16
 2881              	.LVL144:
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2882              		.loc 15 113 0
 2883 0160 00EEA8AA 		fmacs	s20, s1, s17
 2884              	.LVL145:
 2885              		.loc 15 114 0
 2886 0164 D3ED003A 		flds	s7, [r3, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2887              		.loc 15 113 0
 2888 0168 D9ED006A 		flds	s13, [r9, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2889              		.loc 15 112 0
 2890 016c 9AED006A 		flds	s12, [sl, #0]
 2891              		.loc 15 114 0
 2892 0170 7AEEA3AA 		fadds	s21, s21, s7
 115:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 116:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integrate quaternion rate and normalise
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2893              		.loc 15 117 0
 2894 0174 D5ED004A 		flds	s9, [r5, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2895              		.loc 15 113 0
 2896 0178 3AEE26AA 		fadds	s20, s20, s13
 118:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1i = ( q0*gx + q2*gz - q3*gy) * halfT;
 2897              		.loc 15 118 0
 2898 017c 97ED007A 		flds	s14, [r7, #0]
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2899              		.loc 15 112 0
 2900 0180 79EE869A 		fadds	s19, s19, s12
 2901              	.LVL146:
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2902              		.loc 15 117 0
 2903 0184 96ED005A 		flds	s10, [r6, #0]
 2904              		.loc 15 118 0
 2905 0188 64EEAA5A 		fmuls	s11, s9, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2906              		.loc 15 117 0
 2907 018c 24EE8A0A 		fmuls	s0, s9, s20
 2908              		.loc 15 118 0
 2909 0190 47EE295A 		fmacs	s11, s14, s19
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2910              		.loc 15 117 0
 2911 0194 94ED001A 		flds	s2, [r4, #0]
 2912 0198 15EE690A 		fnmscs	s0, s10, s19
 2913              		.loc 15 118 0
 2914 019c 41EE4A5A 		fnmacs	s11, s2, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2915              		.loc 15 117 0
 2916 01a0 2F4B     		ldr	r3, .L168+20
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 2917              		.loc 15 119 0
 2918 01a2 25EE2A4A 		fmuls	s8, s10, s21
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2919              		.loc 15 117 0
 2920 01a6 01EE6A0A 		fnmacs	s0, s2, s21
 2921              		.loc 15 119 0
 2922 01aa 17EE0A4A 		fmscs	s8, s14, s20
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2923              		.loc 15 117 0
 2924 01ae 93ED003A 		flds	s6, [r3, #0]
 2925              	.LVL147:
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 2926              		.loc 15 122 0
 2927 01b2 F0EE452A 		fcpys	s5, s10
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2928              		.loc 15 120 0
 2929 01b6 65EE0A7A 		fmuls	s15, s10, s20
 2930              		.loc 15 122 0
 2931 01ba 45EE832A 		fmacs	s5, s11, s6
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 2932              		.loc 15 119 0
 2933 01be 01EE294A 		fmacs	s8, s2, s19
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2934              		.loc 15 121 0
 2935 01c2 B0EE472A 		fcpys	s4, s14
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2936              		.loc 15 120 0
 2937 01c6 47EE2A7A 		fmacs	s15, s14, s21
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2938              		.loc 15 121 0
 2939 01ca 00EE032A 		fmacs	s4, s0, s6
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 2940              		.loc 15 123 0
 2941 01ce F0EE641A 		fcpys	s3, s9
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2942              		.loc 15 120 0
 2943 01d2 44EEE97A 		fnmacs	s15, s9, s19
 2944              		.loc 15 123 0
 2945 01d6 44EE031A 		fmacs	s3, s8, s6
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 125:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 126:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise quaternion
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 2946              		.loc 15 127 0
 2947 01da 22EEA26A 		fmuls	s12, s5, s5
 2948 01de 02EE026A 		fmacs	s12, s4, s4
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 2949              		.loc 15 124 0
 2950 01e2 07EE831A 		fmacs	s2, s15, s6
 2951              		.loc 15 127 0
 2952 01e6 01EEA16A 		fmacs	s12, s3, s3
 2953 01ea 01EE016A 		fmacs	s12, s2, s2
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2954              		.loc 15 121 0
 2955 01ee 87ED002A 		fsts	s4, [r7, #0]
 2956              		.loc 15 127 0
 2957 01f2 16EE100A 		fmrs	r0, s12
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 2958              		.loc 15 122 0
 2959 01f6 C6ED002A 		fsts	s5, [r6, #0]
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 2960              		.loc 15 123 0
 2961 01fa C5ED001A 		fsts	s3, [r5, #0]
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 2962              		.loc 15 124 0
 2963 01fe 84ED001A 		fsts	s2, [r4, #0]
 2964              		.loc 15 127 0
 2965 0202 FFF7FEFF 		bl	__aeabi_f2d
 2966              	.LVL148:
 2967 0206 FFF7FEFF 		bl	sqrt
 2968 020a FFF7FEFF 		bl	__aeabi_d2f
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 2969              		.loc 15 128 0
 2970 020e D7ED006A 		flds	s13, [r7, #0]
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 2971              		.loc 15 127 0
 2972 0212 05EE900A 		fmsr	s11, r0
 2973              	.LVL149:
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 2974              		.loc 15 129 0
 2975 0216 D6ED000A 		flds	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 2976              		.loc 15 130 0
 2977 021a D5ED003A 		flds	s7, [r5, #0]
 131:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = q3 / norm;
 2978              		.loc 15 131 0
 2979 021e 94ED000A 		flds	s0, [r4, #0]
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 2980              		.loc 15 128 0
 2981 0222 C6EEA56A 		fdivs	s13, s13, s11
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 2982              		.loc 15 129 0
 2983 0226 C0EEA50A 		fdivs	s1, s1, s11
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 2984              		.loc 15 130 0
 2985 022a C3EEA53A 		fdivs	s7, s7, s11
 2986              		.loc 15 131 0
 2987 022e C0EE255A 		fdivs	s11, s0, s11
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 2988              		.loc 15 128 0
 2989 0232 C7ED006A 		fsts	s13, [r7, #0]
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 2990              		.loc 15 129 0
 2991 0236 C6ED000A 		fsts	s1, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 2992              		.loc 15 130 0
 2993 023a C5ED003A 		fsts	s7, [r5, #0]
 2994              		.loc 15 131 0
 2995 023e C4ED005A 		fsts	s11, [r4, #0]
 2996              	.LBE69:
 132:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 2997              		.loc 15 132 0
 2998 0242 BDEC068B 		fldmfdd	sp!, {d8, d9, d10}
 2999 0246 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3000              	.L169:
 3001 024a 00BF     		.align	2
 3002              	.L168:
 3003 024c 00000000 		.word	.LANCHOR37
 3004 0250 00000000 		.word	.LANCHOR38
 3005 0254 00000000 		.word	.LANCHOR39
 3006 0258 00000000 		.word	.LANCHOR36
 3007 025c 00000000 		.word	.LANCHOR47
 3008 0260 00000000 		.word	.LANCHOR35
 3009 0264 00000000 		.word	.LANCHOR40
 3010 0268 00000000 		.word	.LANCHOR41
 3011 026c 00000000 		.word	.LANCHOR42
 3012 0270 00000000 		.word	.LANCHOR43
 3013 0274 00000000 		.word	.LANCHOR44
 3014 0278 00000000 		.word	.LANCHOR45
 3015 027c 00000000 		.word	.LANCHOR46
 3016              		.cfi_endproc
 3017              	.LFE165:
 3019              		.section	.text._Z11eulerAnglesv,"ax",%progbits
 3020              		.align	1
 3021              		.global	_Z11eulerAnglesv
 3022              		.thumb
 3023              		.thumb_func
 3025              	_Z11eulerAnglesv:
 3026              	.LFB166:
 133:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 134:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void eulerAngles()
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3027              		.loc 15 135 0
 3028              		.cfi_startproc
 3029              		@ args = 0, pretend = 0, frame = 0
 3030              		@ frame_needed = 0, uses_anonymous_args = 0
 3031 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 3032              	.LCFI29:
 3033              		.cfi_def_cfa_offset 32
 3034              		.cfi_offset 14, -4
 3035              		.cfi_offset 9, -8
 3036              		.cfi_offset 8, -12
 3037              		.cfi_offset 7, -16
 3038              		.cfi_offset 6, -20
 3039              		.cfi_offset 5, -24
 3040              		.cfi_offset 4, -28
 3041              		.cfi_offset 3, -32
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3042              		.loc 15 136 0
 3043 0004 3C4C     		ldr	r4, .L171
 3044 0006 3D4E     		ldr	r6, .L171+4
 3045 0008 3D4D     		ldr	r5, .L171+8
 3046 000a 3E4F     		ldr	r7, .L171+12
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3047              		.loc 15 135 0
 3048 000c 2DED048B 		fstmfdd	sp!, {d8, d9}
 3049              	.LCFI30:
 3050              		.cfi_def_cfa_offset 48
 3051              		.cfi_offset 82, -40
 3052              		.cfi_offset 80, -48
 3053              		.loc 15 136 0
 3054 0010 D4ED005A 		flds	s11, [r4, #0]
 3055 0014 96ED008A 		flds	s16, [r6, #0]
 3056 0018 D5ED007A 		flds	s15, [r5, #0]
 3057 001c D7ED008A 		flds	s17, [r7, #0]
 3058 0020 68EE255A 		fmuls	s11, s16, s11
 3059 0024 48EEA75A 		fmacs	s11, s17, s15
 3060 0028 B7EE009A 		fconsts	s18, #112
 3061 002c 35EEA55A 		fadds	s10, s11, s11
 3062 0030 15EE100A 		fmrs	r0, s10
 3063 0034 FFF7FEFF 		bl	__aeabi_f2d
 3064 0038 68EE084A 		fmuls	s9, s16, s16
 3065 003c 48EEA84A 		fmacs	s9, s17, s17
 3066 0040 8046     		mov	r8, r0
 3067 0042 34EEA44A 		fadds	s8, s9, s9
 3068 0046 8946     		mov	r9, r1
 3069 0048 79EE443A 		fsubs	s7, s18, s8
 3070 004c 13EE900A 		fmrs	r0, s7
 3071 0050 FFF7FEFF 		bl	__aeabi_f2d
 3072 0054 0246     		mov	r2, r0
 3073 0056 0B46     		mov	r3, r1
 3074 0058 4046     		mov	r0, r8
 3075 005a 4946     		mov	r1, r9
 3076 005c FFF7FEFF 		bl	atan2
 3077 0060 FFF7FEFF 		bl	__aeabi_d2f
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3078              		.loc 15 137 0
 3079 0064 97ED006A 		flds	s12, [r7, #0]
 3080 0068 D4ED002A 		flds	s5, [r4, #0]
 3081 006c D5ED006A 		flds	s13, [r5, #0]
 3082 0070 96ED003A 		flds	s6, [r6, #0]
 3083 0074 66EE222A 		fmuls	s5, s12, s5
 3084 0078 56EE832A 		fmscs	s5, s13, s6
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3085              		.loc 15 136 0
 3086 007c DFF88880 		ldr	r8, .L171+16
 3087              		.loc 15 137 0
 3088 0080 32EEA22A 		fadds	s4, s5, s5
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3089              		.loc 15 136 0
 3090 0084 C8F80000 		str	r0, [r8, #0]	@ float
 3091              		.loc 15 137 0
 3092 0088 12EE100A 		fmrs	r0, s4
 3093 008c FFF7FEFF 		bl	__aeabi_f2d
 3094 0090 FFF7FEFF 		bl	asin
 3095 0094 FFF7FEFF 		bl	__aeabi_d2f
 138:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[ZAXIS]   = atan2(2 * (q0*q3 + q1*q2), 1 - 2 *(q2*q2 + q3*q3));
 3096              		.loc 15 138 0
 3097 0098 D6ED008A 		flds	s17, [r6, #0]
 3098 009c D7ED001A 		flds	s3, [r7, #0]
 3099 00a0 95ED007A 		flds	s14, [r5, #0]
 3100 00a4 94ED008A 		flds	s16, [r4, #0]
 3101 00a8 68EEA11A 		fmuls	s3, s17, s3
 3102 00ac 48EE071A 		fmacs	s3, s16, s14
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3103              		.loc 15 137 0
 3104 00b0 C8F80400 		str	r0, [r8, #4]	@ float
 3105              		.loc 15 138 0
 3106 00b4 31EEA11A 		fadds	s2, s3, s3
 3107 00b8 11EE100A 		fmrs	r0, s2
 3108 00bc FFF7FEFF 		bl	__aeabi_f2d
 3109 00c0 68EE080A 		fmuls	s1, s16, s16
 3110 00c4 48EEA80A 		fmacs	s1, s17, s17
 3111 00c8 0446     		mov	r4, r0
 3112 00ca 30EEA00A 		fadds	s0, s1, s1
 3113 00ce 0D46     		mov	r5, r1
 3114 00d0 79EE407A 		fsubs	s15, s18, s0
 3115 00d4 17EE900A 		fmrs	r0, s15
 3116 00d8 FFF7FEFF 		bl	__aeabi_f2d
 3117 00dc 0246     		mov	r2, r0
 3118 00de 0B46     		mov	r3, r1
 3119 00e0 2046     		mov	r0, r4
 3120 00e2 2946     		mov	r1, r5
 3121 00e4 FFF7FEFF 		bl	atan2
 3122 00e8 FFF7FEFF 		bl	__aeabi_d2f
 3123 00ec C8F80800 		str	r0, [r8, #8]	@ float
 139:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3124              		.loc 15 139 0
 3125 00f0 BDEC048B 		fldmfdd	sp!, {d8, d9}
 3126 00f4 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 3127              	.L172:
 3128              		.align	2
 3129              	.L171:
 3130 00f8 00000000 		.word	.LANCHOR37
 3131 00fc 00000000 		.word	.LANCHOR39
 3132 0100 00000000 		.word	.LANCHOR38
 3133 0104 00000000 		.word	.LANCHOR36
 3134 0108 00000000 		.word	.LANCHOR33
 3135              		.cfi_endproc
 3136              	.LFE166:
 3138              		.section	.text._Z20initializeKinematicsv,"ax",%progbits
 3139              		.align	1
 3140              		.global	_Z20initializeKinematicsv
 3141              		.thumb
 3142              		.thumb_func
 3144              	_Z20initializeKinematicsv:
 3145              	.LFB167:
 140:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 141:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 142:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Initialize ARG
 143:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 144:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 145:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void initializeKinematics() 
 146:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3146              		.loc 15 146 0
 3147              		.cfi_startproc
 3148              		@ args = 0, pretend = 0, frame = 0
 3149              		@ frame_needed = 0, uses_anonymous_args = 0
 3150 0000 08B5     		push	{r3, lr}
 3151              	.LCFI31:
 3152              		.cfi_def_cfa_offset 8
 3153              		.cfi_offset 14, -4
 3154              		.cfi_offset 3, -8
 147:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   initializeBaseKinematicsParam();
 3155              		.loc 15 147 0
 3156 0002 FFF7FEFF 		bl	_Z29initializeBaseKinematicsParamv
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3157              		.loc 15 148 0
 3158 0006 0F4B     		ldr	r3, .L174
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3159              		.loc 15 149 0
 3160 0008 0F49     		ldr	r1, .L174+4
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3161              		.loc 15 150 0
 3162 000a 1048     		ldr	r0, .L174+8
 151:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = 0.0;
 3163              		.loc 15 151 0
 3164 000c 104A     		ldr	r2, .L174+12
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3165              		.loc 15 148 0
 3166 000e 4FF07E5C 		mov	ip, #1065353216
 3167 0012 C3F800C0 		str	ip, [r3, #0]	@ float
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3168              		.loc 15 149 0
 3169 0016 0023     		movs	r3, #0
 3170 0018 0B60     		str	r3, [r1, #0]	@ float
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3171              		.loc 15 150 0
 3172 001a 0360     		str	r3, [r0, #0]	@ float
 3173              		.loc 15 151 0
 3174 001c 1360     		str	r3, [r2, #0]	@ float
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3175              		.loc 15 152 0
 3176 001e 0D49     		ldr	r1, .L174+16
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3177              		.loc 15 153 0
 3178 0020 0D48     		ldr	r0, .L174+20
 154:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = 0.0;
 3179              		.loc 15 154 0
 3180 0022 0E4A     		ldr	r2, .L174+24
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3181              		.loc 15 152 0
 3182 0024 0B60     		str	r3, [r1, #0]	@ float
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3183              		.loc 15 153 0
 3184 0026 0360     		str	r3, [r0, #0]	@ float
 3185              		.loc 15 154 0
 3186 0028 1360     		str	r3, [r2, #0]	@ float
 155:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3187              		.loc 15 156 0
 3188 002a 0D49     		ldr	r1, .L174+28
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3189              		.loc 15 157 0
 3190 002c 0D48     		ldr	r0, .L174+32
 158:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = 0;
 3191              		.loc 15 158 0
 3192 002e 0E4A     		ldr	r2, .L174+36
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3193              		.loc 15 156 0
 3194 0030 0B60     		str	r3, [r1, #0]	@ float
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3195              		.loc 15 157 0
 3196 0032 0360     		str	r3, [r0, #0]	@ float
 3197              		.loc 15 158 0
 3198 0034 1360     		str	r3, [r2, #0]	@ float
 159:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3199              		.loc 15 160 0
 3200 0036 0D48     		ldr	r0, .L174+40
 3201 0038 0D49     		ldr	r1, .L174+44
 161:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Ki = 0.0005; //0.005;
 3202              		.loc 15 161 0
 3203 003a 0E4A     		ldr	r2, .L174+48
 3204 003c 0E4B     		ldr	r3, .L174+52
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3205              		.loc 15 160 0
 3206 003e 0860     		str	r0, [r1, #0]	@ float
 3207              		.loc 15 161 0
 3208 0040 1A60     		str	r2, [r3, #0]	@ float
 162:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3209              		.loc 15 162 0
 3210 0042 08BD     		pop	{r3, pc}
 3211              	.L175:
 3212              		.align	2
 3213              	.L174:
 3214 0044 00000000 		.word	.LANCHOR38
 3215 0048 00000000 		.word	.LANCHOR36
 3216 004c 00000000 		.word	.LANCHOR39
 3217 0050 00000000 		.word	.LANCHOR37
 3218 0054 00000000 		.word	.LANCHOR40
 3219 0058 00000000 		.word	.LANCHOR43
 3220 005c 00000000 		.word	.LANCHOR45
 3221 0060 00000000 		.word	.LANCHOR42
 3222 0064 00000000 		.word	.LANCHOR44
 3223 0068 00000000 		.word	.LANCHOR46
 3224 006c CDCC4C3E 		.word	1045220557
 3225 0070 00000000 		.word	.LANCHOR47
 3226 0074 6F12033A 		.word	973279855
 3227 0078 00000000 		.word	.LANCHOR41
 3228              		.cfi_endproc
 3229              	.LFE167:
 3231              		.section	.text._Z19calculateKinematicsfffffff,"ax",%progbits
 3232              		.align	1
 3233              		.global	_Z19calculateKinematicsfffffff
 3234              		.thumb
 3235              		.thumb_func
 3237              	_Z19calculateKinematicsfffffff:
 3238              	.LFB168:
 163:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 164:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 165:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Calculate ARG
 166:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calculateKinematics(float rollRate,          float pitchRate,    float yawRate,  
 168:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float longitudinalAccel, float lateralAccel, float verticalAccel, 
 169:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float G_DT) {
 3239              		.loc 15 169 0
 3240              		.cfi_startproc
 3241              		@ args = 12, pretend = 0, frame = 0
 3242              		@ frame_needed = 0, uses_anonymous_args = 0
 3243              	.LVL150:
 3244 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 3245              	.LCFI32:
 3246              		.cfi_def_cfa_offset 24
 3247              		.cfi_offset 14, -4
 3248              		.cfi_offset 4, -8
 3249              		.cfi_offset 3, -12
 3250              		.cfi_offset 2, -16
 3251              		.cfi_offset 1, -20
 3252              		.cfi_offset 0, -24
 170:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 171:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   argUpdate(rollRate,          pitchRate,    yawRate, 
 172:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****             longitudinalAccel, lateralAccel, verticalAccel,  
 173:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 		    G_Dt);
 3253              		.loc 15 173 0
 3254 0002 DDF818E0 		ldr	lr, [sp, #24]	@ float
 3255 0006 DDF81CC0 		ldr	ip, [sp, #28]	@ float
 3256 000a 074C     		ldr	r4, .L177
 3257 000c CDF800E0 		str	lr, [sp, #0]	@ float
 3258 0010 CDF804C0 		str	ip, [sp, #4]	@ float
 3259 0014 2468     		ldr	r4, [r4, #0]	@ float
 3260 0016 0294     		str	r4, [sp, #8]	@ float
 3261 0018 FFF7FEFF 		bl	_Z9argUpdatefffffff
 3262              	.LVL151:
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 175:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3263              		.loc 15 175 0
 3264 001c 04B0     		add	sp, sp, #16
 3265 001e BDE81040 		pop	{r4, lr}
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 3266              		.loc 15 174 0
 3267 0022 FFF7FEBF 		b	_Z11eulerAnglesv
 3268              	.L178:
 3269 0026 00BF     		.align	2
 3270              	.L177:
 3271 0028 00000000 		.word	.LANCHOR48
 3272              		.cfi_endproc
 3273              	.LFE168:
 3275              		.section	.text._Z13getGyroUnbiash,"ax",%progbits
 3276              		.align	1
 3277              		.global	_Z13getGyroUnbiash
 3278              		.thumb
 3279              		.thumb_func
 3281              	_Z13getGyroUnbiash:
 3282              	.LFB169:
 176:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 177:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float getGyroUnbias(byte axis) {
 3283              		.loc 15 177 0
 3284              		.cfi_startproc
 3285              		@ args = 0, pretend = 0, frame = 0
 3286              		@ frame_needed = 0, uses_anonymous_args = 0
 3287              		@ link register save eliminated.
 3288              	.LVL152:
 178:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   return correctedRateVector[axis];
 3289              		.loc 15 178 0
 3290 0000 0249     		ldr	r1, .L180
 3291 0002 01EB8003 		add	r3, r1, r0, lsl #2
 179:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3292              		.loc 15 179 0
 3293 0006 1868     		ldr	r0, [r3, #0]	@ float
 3294              	.LVL153:
 3295 0008 7047     		bx	lr
 3296              	.L181:
 3297 000a 00BF     		.align	2
 3298              	.L180:
 3299 000c 00000000 		.word	.LANCHOR49
 3300              		.cfi_endproc
 3301              	.LFE169:
 3303              		.section	.text._Z19calibrateKinematicsv,"ax",%progbits
 3304              		.align	1
 3305              		.global	_Z19calibrateKinematicsv
 3306              		.thumb
 3307              		.thumb_func
 3309              	_Z19calibrateKinematicsv:
 3310              	.LFB170:
 180:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 181:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calibrateKinematics() {}
 3311              		.loc 15 181 0
 3312              		.cfi_startproc
 3313              		@ args = 0, pretend = 0, frame = 0
 3314              		@ frame_needed = 0, uses_anonymous_args = 0
 3315              		@ link register save eliminated.
 3316              		.loc 15 181 0
 3317 0000 7047     		bx	lr
 3318              		.cfi_endproc
 3319              	.LFE170:
 3321              		.section	.text._Z7FrqInitiiPV8tFrqDataP9timer_devi,"ax",%progbits
 3322              		.align	1
 3323              		.global	_Z7FrqInitiiPV8tFrqDataP9timer_devi
 3324              		.thumb
 3325              		.thumb_func
 3327              	_Z7FrqInitiiPV8tFrqDataP9timer_devi:
 3328              	.LFB171:
 3329              		.file 16 "../Libraries/AQ_Receiver/Receiver_STM32.h"
   1:../Libraries/AQ_Receiver/Receiver_STM32.h **** /*
   2:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Copyright (c) 2011 ala42.  All rights reserved.
   3:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
   4:../Libraries/AQ_Receiver/Receiver_STM32.h ****   STM32 receiver class by ala42 using time input capture
   5:../Libraries/AQ_Receiver/Receiver_STM32.h ****   for use with AeroQuad software and Maple library
   6:../Libraries/AQ_Receiver/Receiver_STM32.h ****   V 1.0 Oct 15 2011
   7:../Libraries/AQ_Receiver/Receiver_STM32.h ****   V 1.1 Jan 22 2012	class free version for AeroQuad 3.0 compatibility
   8:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
   9:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Define the pin numbers used for the receiver in receiverPin[]
  10:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  11:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Timer and timer channels are accessed using the Maple PIN_MAP array.
  12:../Libraries/AQ_Receiver/Receiver_STM32.h ****   Make sure libmaple and this receiver class are compiled using the
  13:../Libraries/AQ_Receiver/Receiver_STM32.h ****   same structure alignment mode. When in doubt, change the stm32_pin_info
  14:../Libraries/AQ_Receiver/Receiver_STM32.h ****   declaration in wirish_types.h to align the size to a multiple of 4 byte
  15:../Libraries/AQ_Receiver/Receiver_STM32.h ****   by adding a filler byte at the end of the structure declaration.
  16:../Libraries/AQ_Receiver/Receiver_STM32.h **** */
  17:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  18:../Libraries/AQ_Receiver/Receiver_STM32.h **** #ifndef _AEROQUAD_RECEIVER_STM32_H_
  19:../Libraries/AQ_Receiver/Receiver_STM32.h **** #define _AEROQUAD_RECEIVER_STM32_H_
  20:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  21:../Libraries/AQ_Receiver/Receiver_STM32.h **** #if defined(AeroQuadSTM32)
  22:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  23:../Libraries/AQ_Receiver/Receiver_STM32.h **** #include "Receiver.h"
  24:../Libraries/AQ_Receiver/Receiver_STM32.h **** #include "wirish.h"
  25:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  26:../Libraries/AQ_Receiver/Receiver_STM32.h **** //#define STM32_TIMER_DEBUG // enable debug messages
  27:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  28:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
  29:../Libraries/AQ_Receiver/Receiver_STM32.h **** // configuration part starts here
  30:../Libraries/AQ_Receiver/Receiver_STM32.h **** // definition of pins used for PWM receiver input
  31:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  32:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  33:../Libraries/AQ_Receiver/Receiver_STM32.h **** /*
  34:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	ROLL     0	3
  35:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	PITCH    1	1
  36:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	YAW      2	0
  37:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	THROTTLE 3	2
  38:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	MODE     4	4
  39:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	AUX      5	6
  40:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	AUX2     6	5
  41:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	AUX3     7	7
  42:../Libraries/AQ_Receiver/Receiver_STM32.h **** */
  43:../Libraries/AQ_Receiver/Receiver_STM32.h **** static byte ReceiverChannelMap[] = {0, 1, 2, 3, 4, 5, 6, 7}; // default mapping
  44:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  45:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  46:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
  47:../Libraries/AQ_Receiver/Receiver_STM32.h **** // implementation part starts here.
  48:../Libraries/AQ_Receiver/Receiver_STM32.h **** // forward declaration, array is defined at the end of this file
  49:../Libraries/AQ_Receiver/Receiver_STM32.h **** extern voidFuncPtr PWM_in_handler[];
  50:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  51:../Libraries/AQ_Receiver/Receiver_STM32.h **** typedef struct {
  52:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_dev   *TimerDev;
  53:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_gen_reg_map *TimerRegs;
  54:../Libraries/AQ_Receiver/Receiver_STM32.h ****   __io uint32	*Timer_ccr;
  55:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Low;
  56:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			High;
  57:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16		HighTime;
  58:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16		RiseTime;
  59:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16		LastChange;
  60:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Channel;
  61:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			TimerChannel;
  62:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			PolarityMask;
  63:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Valid;
  64:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int			Debug;
  65:../Libraries/AQ_Receiver/Receiver_STM32.h **** } tFrqData;
  66:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  67:../Libraries/AQ_Receiver/Receiver_STM32.h **** #define FRQInputs 8
  68:../Libraries/AQ_Receiver/Receiver_STM32.h **** volatile tFrqData FrqData[FRQInputs];
  69:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  70:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqInit(int aChannel, int aDefault, volatile tFrqData *f, timer_dev *aTimer, int aTimerChannel
 3330              		.loc 16 70 0
 3331              		.cfi_startproc
 3332              		@ args = 4, pretend = 0, frame = 0
 3333              		@ frame_needed = 0, uses_anonymous_args = 0
 3334              	.LVL154:
 3335 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3336              	.LCFI33:
 3337              		.cfi_def_cfa_offset 24
 3338              		.cfi_offset 14, -4
 3339              		.cfi_offset 8, -8
 3340              		.cfi_offset 7, -12
 3341              		.cfi_offset 6, -16
 3342              		.cfi_offset 5, -20
 3343              		.cfi_offset 4, -24
 3344              	.LBB70:
  71:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  72:../Libraries/AQ_Receiver/Receiver_STM32.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3345              		.loc 16 72 0
 3346 0004 069D     		ldr	r5, [sp, #24]
  73:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  74:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Channel      = aChannel;
 3347              		.loc 16 74 0
 3348 0006 D061     		str	r0, [r2, #28]
  75:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Valid        = false;
 3349              		.loc 16 75 0
 3350 0008 0027     		movs	r7, #0
 3351 000a 9762     		str	r7, [r2, #40]
  76:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  77:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerDev     = aTimer;
 3352              		.loc 16 77 0
 3353 000c 1360     		str	r3, [r2, #0]
  72:../Libraries/AQ_Receiver/Receiver_STM32.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3354              		.loc 16 72 0
 3355 000e 6E1E     		subs	r6, r5, #1
 3356              	.LVL155:
  78:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
 3357              		.loc 16 78 0
 3358 0010 1D68     		ldr	r5, [r3, #0]
 3359              	.LVL156:
  79:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerRegs    = timer;
  80:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  81:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3360              		.loc 16 81 0
 3361 0012 B300     		lsls	r3, r6, #2
 3362              	.LVL157:
 3363 0014 05F13408 		add	r8, r5, #52
 3364 0018 08EB0300 		add	r0, r8, r3
 3365              	.LVL158:
  79:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerRegs    = timer;
 3366              		.loc 16 79 0
 3367 001c 5560     		str	r5, [r2, #4]
 3368              	.LBE70:
  70:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqInit(int aChannel, int aDefault, volatile tFrqData *f, timer_dev *aTimer, int aTimerChannel
 3369              		.loc 16 70 0
 3370 001e 1446     		mov	r4, r2
 3371              	.LBB71:
 3372              		.loc 16 81 0
 3373 0020 9060     		str	r0, [r2, #8]
  82:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->Debug        = false;
 3374              		.loc 16 82 0
 3375 0022 D762     		str	r7, [r2, #44]
  83:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->HighTime     = aDefault;
 3376              		.loc 16 83 0
 3377 0024 9182     		strh	r1, [r2, #20]	@ movhi
  84:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerChannel = aTimerChannel;
 3378              		.loc 16 84 0
 3379 0026 1662     		str	r6, [r2, #32]
  85:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  86:../Libraries/AQ_Receiver/Receiver_STM32.h ****   int TimerEnable = (1 << (4*aTimerChannel));
 3380              		.loc 16 86 0
 3381 0028 4FF00102 		mov	r2, #1
 3382              	.LVL159:
 3383 002c 02FA03F8 		lsl	r8, r2, r3
 3384              	.LVL160:
  87:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->PolarityMask = TimerEnable << 1;
 3385              		.loc 16 87 0
 3386 0030 4FEA4800 		lsl	r0, r8, #1
 3387 0034 6062     		str	r0, [r4, #36]
  88:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  89:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(f->TimerDev->clk_id);
 3388              		.loc 16 89 0
 3389 0036 2168     		ldr	r1, [r4, #0]
 3390              	.LVL161:
 3391 0038 0879     		ldrb	r0, [r1, #4]	@ zero_extendqisi2
 3392 003a FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 3393              	.LVL162:
  90:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3394              		.loc 16 90 0
 3395 003e 1A4A     		ldr	r2, .L186
 3396 0040 B0FBF2F3 		udiv	r3, r0, r2
 3397 0044 581E     		subs	r0, r3, #1
 3398              	.LVL163:
  91:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->ARR	= 0xffff;
 3399              		.loc 16 91 0
 3400 0046 4FF6FF71 		movw	r1, #65535
  90:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3401              		.loc 16 90 0
 3402 004a A862     		str	r0, [r5, #40]
 3403              		.loc 16 91 0
 3404 004c E962     		str	r1, [r5, #44]
  92:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CR1	= 0;
 3405              		.loc 16 92 0
 3406 004e 2F60     		str	r7, [r5, #0]
  93:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->DIER &= ~(1);
 3407              		.loc 16 93 0
 3408 0050 EA68     		ldr	r2, [r5, #12]
 3409 0052 22F00103 		bic	r3, r2, #1
 3410 0056 EB60     		str	r3, [r5, #12]
  94:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  95:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 3411              		.loc 16 95 0
 3412 0058 286A     		ldr	r0, [r5, #32]
 3413 005a 20EA0801 		bic	r1, r0, r8
 3414 005e 2962     		str	r1, [r5, #32]
  96:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER &= ~(f->PolarityMask);
 3415              		.loc 16 96 0
 3416 0060 2B6A     		ldr	r3, [r5, #32]
 3417 0062 626A     		ldr	r2, [r4, #36]
  97:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
  98:../Libraries/AQ_Receiver/Receiver_STM32.h ****   volatile uint32 *mr;
  99:../Libraries/AQ_Receiver/Receiver_STM32.h ****   if(aTimerChannel < 2) {
 3418              		.loc 16 99 0
 3419 0064 012E     		cmp	r6, #1
  96:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER &= ~(f->PolarityMask);
 3420              		.loc 16 96 0
 3421 0066 23EA0203 		bic	r3, r3, r2
 3422 006a 2B62     		str	r3, [r5, #32]
 100:../Libraries/AQ_Receiver/Receiver_STM32.h ****     mr = &(timer->CCMR1);
 3423              		.loc 16 100 0
 3424 006c D4BF     		ite	le
 3425 006e 05F11803 		addle	r3, r5, #24
 3426              	.LVL164:
 101:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 102:../Libraries/AQ_Receiver/Receiver_STM32.h ****   else {
 103:../Libraries/AQ_Receiver/Receiver_STM32.h ****     mr = &(timer->CCMR2);
 3427              		.loc 16 103 0
 3428 0072 05F11C03 		addgt	r3, r5, #28
 3429              	.LVL165:
 104:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 105:../Libraries/AQ_Receiver/Receiver_STM32.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 3430              		.loc 16 105 0
 3431 0076 06F00100 		and	r0, r6, #1
 3432 007a 1968     		ldr	r1, [r3, #0]
 3433 007c C000     		lsls	r0, r0, #3
 3434 007e FF26     		movs	r6, #255
 3435              	.LVL166:
 3436 0080 16FA00F2 		lsls	r2, r6, r0
 3437 0084 21EA0206 		bic	r6, r1, r2
 3438 0088 1E60     		str	r6, [r3, #0]
 106:../Libraries/AQ_Receiver/Receiver_STM32.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 3439              		.loc 16 106 0
 3440 008a 1A68     		ldr	r2, [r3, #0]
 3441 008c 6121     		movs	r1, #97
 3442 008e 11FA00F6 		lsls	r6, r1, r0
 3443 0092 1643     		orrs	r6, r6, r2
 3444 0094 1E60     		str	r6, [r3, #0]
 107:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 108:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER |= TimerEnable; // Enable
 3445              		.loc 16 108 0
 3446 0096 296A     		ldr	r1, [r5, #32]
 109:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CR1 = 1;
 3447              		.loc 16 109 0
 3448 0098 0123     		movs	r3, #1
 3449              	.LVL167:
 108:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer->CCER |= TimerEnable; // Enable
 3450              		.loc 16 108 0
 3451 009a 48EA0100 		orr	r0, r8, r1
 3452 009e 2862     		str	r0, [r5, #32]
 3453              		.loc 16 109 0
 3454 00a0 2B60     		str	r3, [r5, #0]
 3455              	.LBE71:
 110:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3456              		.loc 16 110 0
 3457 00a2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3458              	.L187:
 3459 00a6 00BF     		.align	2
 3460              	.L186:
 3461 00a8 40420F00 		.word	1000000
 3462              		.cfi_endproc
 3463              	.LFE171:
 3465              		.section	.text._Z18InitFrqMeasurementv,"ax",%progbits
 3466              		.align	1
 3467              		.global	_Z18InitFrqMeasurementv
 3468              		.thumb
 3469              		.thumb_func
 3471              	_Z18InitFrqMeasurementv:
 3472              	.LFB172:
 111:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 112:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 113:../Libraries/AQ_Receiver/Receiver_STM32.h **** void InitFrqMeasurement() {
 3473              		.loc 16 113 0
 3474              		.cfi_startproc
 3475              		@ args = 0, pretend = 0, frame = 0
 3476              		@ frame_needed = 0, uses_anonymous_args = 0
 3477              	.LVL168:
 3478 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 3479              	.LCFI34:
 3480              		.cfi_def_cfa_offset 24
 3481              		.cfi_offset 14, -4
 3482              		.cfi_offset 6, -8
 3483              		.cfi_offset 5, -12
 3484              		.cfi_offset 4, -16
 3485              		.cfi_offset 1, -20
 3486              		.cfi_offset 0, -24
 114:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 115:../Libraries/AQ_Receiver/Receiver_STM32.h ****   for(int rcLine = 0; rcLine < (int)(sizeof(receiverPin) / sizeof(receiverPin[0])); rcLine++) {
 3487              		.loc 16 115 0
 3488 0002 0024     		movs	r4, #0
 3489              	.LVL169:
 3490              	.L190:
 3491              	.LBB72:
 3492              	.LBB73:
 116:../Libraries/AQ_Receiver/Receiver_STM32.h ****     int pin = receiverPin[rcLine];
 3493              		.loc 16 116 0
 3494 0004 1148     		ldr	r0, .L192
 117:../Libraries/AQ_Receiver/Receiver_STM32.h ****     timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3495              		.loc 16 117 0
 3496 0006 124A     		ldr	r2, .L192+4
 116:../Libraries/AQ_Receiver/Receiver_STM32.h ****     int pin = receiverPin[rcLine];
 3497              		.loc 16 116 0
 3498 0008 235C     		ldrb	r3, [r4, r0]	@ zero_extendqisi2
 3499              	.LVL170:
 3500              		.loc 16 117 0
 3501 000a 1B01     		lsls	r3, r3, #4
 3502              	.LVL171:
 3503 000c D518     		adds	r5, r2, r3
 3504 000e 6E68     		ldr	r6, [r5, #4]
 3505              	.LVL172:
 118:../Libraries/AQ_Receiver/Receiver_STM32.h ****     if(timer_num != NULL) {
 3506              		.loc 16 118 0
 3507 0010 BEB1     		cbz	r6, .L189
 119:../Libraries/AQ_Receiver/Receiver_STM32.h ****       gpio_set_mode(PIN_MAP[pin].gpio_device, PIN_MAP[pin].gpio_bit, GPIO_AF_INPUT_PD);
 3508              		.loc 16 119 0
 3509 0012 D058     		ldr	r0, [r2, r3]
 3510 0014 297B     		ldrb	r1, [r5, #12]	@ zero_extendqisi2
 3511 0016 0A22     		movs	r2, #10
 3512 0018 FFF7FEFF 		bl	gpio_set_mode
 3513              	.LVL173:
 120:../Libraries/AQ_Receiver/Receiver_STM32.h ****       FrqInit(rcLine, 1500, &FrqData[rcLine], timer_num, PIN_MAP[pin].timer_channel);
 3514              		.loc 16 120 0
 3515 001c 697B     		ldrb	r1, [r5, #13]	@ zero_extendqisi2
 3516 001e 0D4B     		ldr	r3, .L192+8
 3517 0020 0091     		str	r1, [sp, #0]
 3518 0022 3022     		movs	r2, #48
 3519 0024 02FB0432 		mla	r2, r2, r4, r3
 3520 0028 2046     		mov	r0, r4
 3521 002a 40F2DC51 		movw	r1, #1500
 3522 002e 3346     		mov	r3, r6
 3523 0030 FFF7FEFF 		bl	_Z7FrqInitiiPV8tFrqDataP9timer_devi
 121:../Libraries/AQ_Receiver/Receiver_STM32.h ****       timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, PWM_in_handler[rcLine]);
 3524              		.loc 16 121 0
 3525 0034 084A     		ldr	r2, .L192+12
 3526 0036 697B     		ldrb	r1, [r5, #13]	@ zero_extendqisi2
 3527 0038 52F82420 		ldr	r2, [r2, r4, lsl #2]
 3528 003c 3046     		mov	r0, r6
 3529 003e FFF7FEFF 		bl	timer_attach_interrupt
 3530              	.L189:
 3531              	.LBE73:
 115:../Libraries/AQ_Receiver/Receiver_STM32.h ****   for(int rcLine = 0; rcLine < (int)(sizeof(receiverPin) / sizeof(receiverPin[0])); rcLine++) {
 3532              		.loc 16 115 0
 3533 0042 0134     		adds	r4, r4, #1
 3534              	.LVL174:
 3535 0044 082C     		cmp	r4, #8
 3536 0046 DDD1     		bne	.L190
 3537              	.LBE72:
 122:../Libraries/AQ_Receiver/Receiver_STM32.h ****     }
 123:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 124:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3538              		.loc 16 124 0
 3539 0048 7CBD     		pop	{r2, r3, r4, r5, r6, pc}
 3540              	.L193:
 3541 004a 00BF     		.align	2
 3542              	.L192:
 3543 004c 00000000 		.word	.LANCHOR50
 3544 0050 00000000 		.word	PIN_MAP
 3545 0054 00000000 		.word	.LANCHOR51
 3546 0058 00000000 		.word	.LANCHOR52
 3547              		.cfi_endproc
 3548              	.LFE172:
 3550              		.section	.text._Z17PWMInvertPolarityPV8tFrqData,"ax",%progbits
 3551              		.align	1
 3552              		.global	_Z17PWMInvertPolarityPV8tFrqData
 3553              		.thumb
 3554              		.thumb_func
 3556              	_Z17PWMInvertPolarityPV8tFrqData:
 3557              	.LFB173:
 125:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 126:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 127:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWMInvertPolarity(volatile tFrqData *f) {
 3558              		.loc 16 127 0
 3559              		.cfi_startproc
 3560              		@ args = 0, pretend = 0, frame = 0
 3561              		@ frame_needed = 0, uses_anonymous_args = 0
 3562              		@ link register save eliminated.
 3563              	.LVL175:
 128:../Libraries/AQ_Receiver/Receiver_STM32.h ****   f->TimerRegs->CCER ^= f->PolarityMask; // invert polarity
 3564              		.loc 16 128 0
 3565 0000 4368     		ldr	r3, [r0, #4]
 3566 0002 1A6A     		ldr	r2, [r3, #32]
 3567 0004 416A     		ldr	r1, [r0, #36]
 3568 0006 4A40     		eors	r2, r2, r1
 3569 0008 1A62     		str	r2, [r3, #32]
 129:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3570              		.loc 16 129 0
 3571 000a 7047     		bx	lr
 3572              		.cfi_endproc
 3573              	.LFE173:
 3575              		.section	.text._Z9FrqChangePV8tFrqData,"ax",%progbits
 3576              		.align	1
 3577              		.global	_Z9FrqChangePV8tFrqData
 3578              		.thumb
 3579              		.thumb_func
 3581              	_Z9FrqChangePV8tFrqData:
 3582              	.LFB174:
 130:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 131:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqChange(volatile tFrqData *f) {
 3583              		.loc 16 131 0
 3584              		.cfi_startproc
 3585              		@ args = 0, pretend = 0, frame = 0
 3586              		@ frame_needed = 0, uses_anonymous_args = 0
 3587              	.LVL176:
 3588              	.LBB74:
 132:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 133:../Libraries/AQ_Receiver/Receiver_STM32.h ****   timer_gen_reg_map *timer = f->TimerRegs;
 3589              		.loc 16 133 0
 3590 0000 4168     		ldr	r1, [r0, #4]
 3591              	.LVL177:
 134:../Libraries/AQ_Receiver/Receiver_STM32.h ****   uint16_t c = *(f->Timer_ccr);
 3592              		.loc 16 134 0
 3593 0002 8368     		ldr	r3, [r0, #8]
 3594 0004 1B68     		ldr	r3, [r3, #0]
 3595              	.LVL178:
 135:../Libraries/AQ_Receiver/Receiver_STM32.h ****   bool rising = (timer->CCER & f->PolarityMask) == 0;
 3596              		.loc 16 135 0
 3597 0006 0A6A     		ldr	r2, [r1, #32]
 3598 0008 416A     		ldr	r1, [r0, #36]
 3599              	.LVL179:
 3600 000a 1142     		tst	r1, r2
 3601              	.LBB75:
 136:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 137:../Libraries/AQ_Receiver/Receiver_STM32.h ****   if(f->Valid) {
 3602              		.loc 16 137 0
 3603 000c 816A     		ldr	r1, [r0, #40]
 3604              	.LBE75:
 3605              	.LBE74:
 131:../Libraries/AQ_Receiver/Receiver_STM32.h **** void FrqChange(volatile tFrqData *f) {
 3606              		.loc 16 131 0
 3607 000e 10B5     		push	{r4, lr}
 3608              	.LCFI35:
 3609              		.cfi_def_cfa_offset 8
 3610              		.cfi_offset 14, -4
 3611              		.cfi_offset 4, -8
 3612              	.LBB79:
 135:../Libraries/AQ_Receiver/Receiver_STM32.h ****   bool rising = (timer->CCER & f->PolarityMask) == 0;
 3613              		.loc 16 135 0
 3614 0010 14BF     		ite	ne
 3615 0012 0022     		movne	r2, #0
 3616 0014 0122     		moveq	r2, #1
 3617              	.LVL180:
 3618              	.LBB78:
 3619              		.loc 16 137 0
 3620 0016 91B1     		cbz	r1, .L196
 3621              	.LVL181:
 3622              	.LBB76:
 138:../Libraries/AQ_Receiver/Receiver_STM32.h ****     if(rising) {
 3623              		.loc 16 138 0
 3624 0018 0AB1     		cbz	r2, .L197
 139:../Libraries/AQ_Receiver/Receiver_STM32.h ****       f->RiseTime = c;
 3625              		.loc 16 139 0
 3626 001a C382     		strh	r3, [r0, #22]	@ movhi
 3627 001c 13E0     		b	.L198
 3628              	.L197:
 3629              	.LBB77:
 140:../Libraries/AQ_Receiver/Receiver_STM32.h ****     } 
 141:../Libraries/AQ_Receiver/Receiver_STM32.h ****     else {
 142:../Libraries/AQ_Receiver/Receiver_STM32.h ****       uint16_t highTime = c - f->RiseTime;
 3630              		.loc 16 142 0
 3631 001e C48A     		ldrh	r4, [r0, #22]
 3632 0020 191B     		subs	r1, r3, r4
 3633 0022 1FFA81FC 		uxth	ip, r1
 3634              	.LVL182:
 143:../Libraries/AQ_Receiver/Receiver_STM32.h ****       if(highTime > 900 && highTime < 2100) {
 3635              		.loc 16 143 0
 3636 0026 ACF56073 		sub	r3, ip, #896
 3637              	.LVL183:
 3638 002a 5C1F     		subs	r4, r3, #5
 3639 002c A1B2     		uxth	r1, r4
 3640 002e 40F2AE44 		movw	r4, #1198
 3641 0032 A142     		cmp	r1, r4
 144:../Libraries/AQ_Receiver/Receiver_STM32.h ****         f->HighTime = highTime;
 3642              		.loc 16 144 0
 3643 0034 94BF     		ite	ls
 3644 0036 A0F814C0 		strhls	ip, [r0, #20]	@ movhi
 145:../Libraries/AQ_Receiver/Receiver_STM32.h ****       } 
 146:../Libraries/AQ_Receiver/Receiver_STM32.h ****       else {
 147:../Libraries/AQ_Receiver/Receiver_STM32.h ****         f->Valid = false;
 3645              		.loc 16 147 0
 3646 003a 8262     		strhi	r2, [r0, #40]
 3647 003c 03E0     		b	.L198
 3648              	.LVL184:
 3649              	.L196:
 3650              	.LBE77:
 3651              	.LBE76:
 148:../Libraries/AQ_Receiver/Receiver_STM32.h ****       }
 149:../Libraries/AQ_Receiver/Receiver_STM32.h ****     }
 150:../Libraries/AQ_Receiver/Receiver_STM32.h ****   } 
 151:../Libraries/AQ_Receiver/Receiver_STM32.h ****   else if(rising) {
 3652              		.loc 16 151 0
 3653 003e 12B1     		cbz	r2, .L198
 152:../Libraries/AQ_Receiver/Receiver_STM32.h ****     // rising edge, store start time
 153:../Libraries/AQ_Receiver/Receiver_STM32.h ****     f->RiseTime = c;
 154:../Libraries/AQ_Receiver/Receiver_STM32.h ****     f->Valid = true;
 3654              		.loc 16 154 0
 3655 0040 0122     		movs	r2, #1
 153:../Libraries/AQ_Receiver/Receiver_STM32.h ****     f->RiseTime = c;
 3656              		.loc 16 153 0
 3657 0042 C382     		strh	r3, [r0, #22]	@ movhi
 3658              		.loc 16 154 0
 3659 0044 8262     		str	r2, [r0, #40]
 3660              	.LVL185:
 3661              	.L198:
 3662              	.LBE78:
 3663              	.LBE79:
 155:../Libraries/AQ_Receiver/Receiver_STM32.h ****   }
 156:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 157:../Libraries/AQ_Receiver/Receiver_STM32.h ****   PWMInvertPolarity(f);
 158:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3664              		.loc 16 158 0
 3665 0046 BDE81040 		pop	{r4, lr}
 3666              	.LBB80:
 157:../Libraries/AQ_Receiver/Receiver_STM32.h ****   PWMInvertPolarity(f);
 3667              		.loc 16 157 0
 3668 004a FFF7FEBF 		b	_Z17PWMInvertPolarityPV8tFrqData
 3669              	.LVL186:
 3670              	.LBE80:
 3671              		.cfi_endproc
 3672              	.LFE174:
 3674              		.section	.text._Z14IrqChangeValuei,"ax",%progbits
 3675              		.align	1
 3676              		.global	_Z14IrqChangeValuei
 3677              		.thumb
 3678              		.thumb_func
 3680              	_Z14IrqChangeValuei:
 3681              	.LFB175:
 159:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 160:../Libraries/AQ_Receiver/Receiver_STM32.h **** // hide the class details from the interrupt handler
 161:../Libraries/AQ_Receiver/Receiver_STM32.h **** void IrqChangeValue(int chan) {
 3682              		.loc 16 161 0
 3683              		.cfi_startproc
 3684              		@ args = 0, pretend = 0, frame = 0
 3685              		@ frame_needed = 0, uses_anonymous_args = 0
 3686              		@ link register save eliminated.
 3687              	.LVL187:
 162:../Libraries/AQ_Receiver/Receiver_STM32.h ****   FrqChange(&FrqData[chan]);
 3688              		.loc 16 162 0
 3689 0000 024B     		ldr	r3, .L201
 3690 0002 3022     		movs	r2, #48
 3691 0004 02FB0030 		mla	r0, r2, r0, r3
 3692              	.LVL188:
 163:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3693              		.loc 16 163 0
 162:../Libraries/AQ_Receiver/Receiver_STM32.h ****   FrqChange(&FrqData[chan]);
 3694              		.loc 16 162 0
 3695 0008 FFF7FEBF 		b	_Z9FrqChangePV8tFrqData
 3696              	.L202:
 3697              		.align	2
 3698              	.L201:
 3699 000c 00000000 		.word	.LANCHOR51
 3700              		.cfi_endproc
 3701              	.LFE175:
 3703              		.section	.text._Z8PWM_in_7v,"ax",%progbits
 3704              		.align	1
 3705              		.global	_Z8PWM_in_7v
 3706              		.thumb
 3707              		.thumb_func
 3709              	_Z8PWM_in_7v:
 3710              	.LFB183:
 164:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 165:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 166:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Receiver/Receiver_STM32.h **** // definition of interrupt handler functions, one for each channel
 168:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_0() { IrqChangeValue(0); }
 169:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_1() { IrqChangeValue(1); }
 170:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_2() { IrqChangeValue(2); }
 171:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_3() { IrqChangeValue(3); }
 172:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_4() { IrqChangeValue(4); }
 173:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_5() { IrqChangeValue(5); }
 174:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_6() { IrqChangeValue(6); }
 175:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_7() { IrqChangeValue(7); }
 3711              		.loc 16 175 0
 3712              		.cfi_startproc
 3713              		@ args = 0, pretend = 0, frame = 0
 3714              		@ frame_needed = 0, uses_anonymous_args = 0
 3715              		@ link register save eliminated.
 3716              		.loc 16 175 0
 3717 0000 0720     		movs	r0, #7
 3718 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3719              		.cfi_endproc
 3720              	.LFE183:
 3722              		.section	.text._Z8PWM_in_6v,"ax",%progbits
 3723              		.align	1
 3724              		.global	_Z8PWM_in_6v
 3725              		.thumb
 3726              		.thumb_func
 3728              	_Z8PWM_in_6v:
 3729              	.LFB182:
 174:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_6() { IrqChangeValue(6); }
 3730              		.loc 16 174 0
 3731              		.cfi_startproc
 3732              		@ args = 0, pretend = 0, frame = 0
 3733              		@ frame_needed = 0, uses_anonymous_args = 0
 3734              		@ link register save eliminated.
 174:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_6() { IrqChangeValue(6); }
 3735              		.loc 16 174 0
 3736 0000 0620     		movs	r0, #6
 3737 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3738              		.cfi_endproc
 3739              	.LFE182:
 3741              		.section	.text._Z8PWM_in_5v,"ax",%progbits
 3742              		.align	1
 3743              		.global	_Z8PWM_in_5v
 3744              		.thumb
 3745              		.thumb_func
 3747              	_Z8PWM_in_5v:
 3748              	.LFB181:
 173:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_5() { IrqChangeValue(5); }
 3749              		.loc 16 173 0
 3750              		.cfi_startproc
 3751              		@ args = 0, pretend = 0, frame = 0
 3752              		@ frame_needed = 0, uses_anonymous_args = 0
 3753              		@ link register save eliminated.
 173:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_5() { IrqChangeValue(5); }
 3754              		.loc 16 173 0
 3755 0000 0520     		movs	r0, #5
 3756 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3757              		.cfi_endproc
 3758              	.LFE181:
 3760              		.section	.text._Z8PWM_in_4v,"ax",%progbits
 3761              		.align	1
 3762              		.global	_Z8PWM_in_4v
 3763              		.thumb
 3764              		.thumb_func
 3766              	_Z8PWM_in_4v:
 3767              	.LFB180:
 172:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_4() { IrqChangeValue(4); }
 3768              		.loc 16 172 0
 3769              		.cfi_startproc
 3770              		@ args = 0, pretend = 0, frame = 0
 3771              		@ frame_needed = 0, uses_anonymous_args = 0
 3772              		@ link register save eliminated.
 172:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_4() { IrqChangeValue(4); }
 3773              		.loc 16 172 0
 3774 0000 0420     		movs	r0, #4
 3775 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3776              		.cfi_endproc
 3777              	.LFE180:
 3779              		.section	.text._Z8PWM_in_3v,"ax",%progbits
 3780              		.align	1
 3781              		.global	_Z8PWM_in_3v
 3782              		.thumb
 3783              		.thumb_func
 3785              	_Z8PWM_in_3v:
 3786              	.LFB179:
 171:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_3() { IrqChangeValue(3); }
 3787              		.loc 16 171 0
 3788              		.cfi_startproc
 3789              		@ args = 0, pretend = 0, frame = 0
 3790              		@ frame_needed = 0, uses_anonymous_args = 0
 3791              		@ link register save eliminated.
 171:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_3() { IrqChangeValue(3); }
 3792              		.loc 16 171 0
 3793 0000 0320     		movs	r0, #3
 3794 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3795              		.cfi_endproc
 3796              	.LFE179:
 3798              		.section	.text._Z8PWM_in_2v,"ax",%progbits
 3799              		.align	1
 3800              		.global	_Z8PWM_in_2v
 3801              		.thumb
 3802              		.thumb_func
 3804              	_Z8PWM_in_2v:
 3805              	.LFB178:
 170:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_2() { IrqChangeValue(2); }
 3806              		.loc 16 170 0
 3807              		.cfi_startproc
 3808              		@ args = 0, pretend = 0, frame = 0
 3809              		@ frame_needed = 0, uses_anonymous_args = 0
 3810              		@ link register save eliminated.
 170:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_2() { IrqChangeValue(2); }
 3811              		.loc 16 170 0
 3812 0000 0220     		movs	r0, #2
 3813 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3814              		.cfi_endproc
 3815              	.LFE178:
 3817              		.section	.text._Z8PWM_in_1v,"ax",%progbits
 3818              		.align	1
 3819              		.global	_Z8PWM_in_1v
 3820              		.thumb
 3821              		.thumb_func
 3823              	_Z8PWM_in_1v:
 3824              	.LFB177:
 169:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_1() { IrqChangeValue(1); }
 3825              		.loc 16 169 0
 3826              		.cfi_startproc
 3827              		@ args = 0, pretend = 0, frame = 0
 3828              		@ frame_needed = 0, uses_anonymous_args = 0
 3829              		@ link register save eliminated.
 169:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_1() { IrqChangeValue(1); }
 3830              		.loc 16 169 0
 3831 0000 0120     		movs	r0, #1
 3832 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3833              		.cfi_endproc
 3834              	.LFE177:
 3836              		.section	.text._Z8PWM_in_0v,"ax",%progbits
 3837              		.align	1
 3838              		.global	_Z8PWM_in_0v
 3839              		.thumb
 3840              		.thumb_func
 3842              	_Z8PWM_in_0v:
 3843              	.LFB176:
 168:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_0() { IrqChangeValue(0); }
 3844              		.loc 16 168 0
 3845              		.cfi_startproc
 3846              		@ args = 0, pretend = 0, frame = 0
 3847              		@ frame_needed = 0, uses_anonymous_args = 0
 3848              		@ link register save eliminated.
 168:../Libraries/AQ_Receiver/Receiver_STM32.h **** void PWM_in_0() { IrqChangeValue(0); }
 3849              		.loc 16 168 0
 3850 0000 0020     		movs	r0, #0
 3851 0002 FFF7FEBF 		b	_Z14IrqChangeValuei
 3852              		.cfi_endproc
 3853              	.LFE176:
 3855              		.section	.text._Z18initializeReceiveri,"ax",%progbits
 3856              		.align	1
 3857              		.global	_Z18initializeReceiveri
 3858              		.thumb
 3859              		.thumb_func
 3861              	_Z18initializeReceiveri:
 3862              	.LFB184:
 176:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 177:../Libraries/AQ_Receiver/Receiver_STM32.h **** voidFuncPtr PWM_in_handler[] = { PWM_in_0, PWM_in_1, PWM_in_2, PWM_in_3, PWM_in_4, PWM_in_5, PWM_in
 178:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 179:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 180:../Libraries/AQ_Receiver/Receiver_STM32.h **** ///////////////////////////////////////////////////////////////////////////////
 181:../Libraries/AQ_Receiver/Receiver_STM32.h **** // interface part starts here
 182:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 183:../Libraries/AQ_Receiver/Receiver_STM32.h **** void initializeReceiver(int nbChannel = 8) {
 3863              		.loc 16 183 0
 3864              		.cfi_startproc
 3865              		@ args = 0, pretend = 0, frame = 0
 3866              		@ frame_needed = 0, uses_anonymous_args = 0
 3867              	.LVL189:
 3868 0000 08B5     		push	{r3, lr}
 3869              	.LCFI36:
 3870              		.cfi_def_cfa_offset 8
 3871              		.cfi_offset 14, -4
 3872              		.cfi_offset 3, -8
 184:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 185:../Libraries/AQ_Receiver/Receiver_STM32.h ****     initializeReceiverParam(nbChannel);
 3873              		.loc 16 185 0
 3874 0002 FFF7FEFF 		bl	_Z23initializeReceiverParami
 3875              	.LVL190:
 186:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	InitFrqMeasurement();
 187:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3876              		.loc 16 187 0
 3877 0006 BDE80840 		pop	{r3, lr}
 186:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	InitFrqMeasurement();
 3878              		.loc 16 186 0
 3879 000a FFF7FEBF 		b	_Z18InitFrqMeasurementv
 3880              		.cfi_endproc
 3881              	.LFE184:
 3883              		.section	.text._Z18getRawChannelValueh,"ax",%progbits
 3884              		.align	1
 3885              		.global	_Z18getRawChannelValueh
 3886              		.thumb
 3887              		.thumb_func
 3889              	_Z18getRawChannelValueh:
 3890              	.LFB185:
 188:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 189:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 190:../Libraries/AQ_Receiver/Receiver_STM32.h **** int getRawChannelValue(const byte channel) {
 3891              		.loc 16 190 0
 3892              		.cfi_startproc
 3893              		@ args = 0, pretend = 0, frame = 0
 3894              		@ frame_needed = 0, uses_anonymous_args = 0
 3895              		@ link register save eliminated.
 3896              	.LVL191:
 3897              	.LBB81:
 191:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	int chan = ReceiverChannelMap[channel];
 3898              		.loc 16 191 0
 3899 0000 064B     		ldr	r3, .L215
 3900 0002 1B5C     		ldrb	r3, [r3, r0]	@ zero_extendqisi2
 3901              	.LVL192:
 3902              	.LBB82:
 192:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	if(chan < (int)sizeof(receiverPin)) {
 3903              		.loc 16 192 0
 3904 0004 072B     		cmp	r3, #7
 3905 0006 06DC     		bgt	.L214
 3906              	.LBB83:
 193:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		volatile tFrqData *f = &FrqData[chan];
 3907              		.loc 16 193 0
 3908 0008 054A     		ldr	r2, .L215+4
 3909 000a 3020     		movs	r0, #48
 3910              	.LVL193:
 3911 000c 00FB0321 		mla	r1, r0, r3, r2
 3912              	.LVL194:
 194:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		uint16_t PulsLength = f->HighTime;
 3913              		.loc 16 194 0
 3914 0010 888A     		ldrh	r0, [r1, #20]
 3915 0012 80B2     		uxth	r0, r0
 195:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		return PulsLength;
 3916              		.loc 16 195 0
 3917 0014 7047     		bx	lr
 3918              	.LVL195:
 3919              	.L214:
 3920              	.LBE83:
 196:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	} else {
 197:../Libraries/AQ_Receiver/Receiver_STM32.h **** 		return 1500;
 3921              		.loc 16 197 0
 3922 0016 40F2DC50 		movw	r0, #1500
 3923              	.LVL196:
 3924              	.LBE82:
 3925              	.LBE81:
 198:../Libraries/AQ_Receiver/Receiver_STM32.h **** 	}
 199:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 3926              		.loc 16 199 0
 3927 001a 7047     		bx	lr
 3928              	.L216:
 3929              		.align	2
 3930              	.L215:
 3931 001c 00000000 		.word	.LANCHOR53
 3932 0020 00000000 		.word	.LANCHOR51
 3933              		.cfi_endproc
 3934              	.LFE185:
 3936              		.section	.text._Z12readReceiverv,"ax",%progbits
 3937              		.align	1
 3938              		.global	_Z12readReceiverv
 3939              		.thumb
 3940              		.thumb_func
 3942              	_Z12readReceiverv:
 3943              	.LFB124:
  89:../Libraries/AQ_Receiver/Receiver.h **** {
 3944              		.loc 6 89 0
 3945              		.cfi_startproc
 3946              		@ args = 0, pretend = 0, frame = 0
 3947              		@ frame_needed = 0, uses_anonymous_args = 0
 3948              	.LVL197:
 3949 0000 70B5     		push	{r4, r5, r6, lr}
 3950              	.LCFI37:
 3951              		.cfi_def_cfa_offset 16
 3952              		.cfi_offset 14, -4
 3953              		.cfi_offset 6, -8
 3954              		.cfi_offset 5, -12
 3955              		.cfi_offset 4, -16
 3956              	.LBB84:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3957              		.loc 6 90 0
 3958 0002 0024     		movs	r4, #0
 3959              	.LBE84:
  89:../Libraries/AQ_Receiver/Receiver.h **** {
 3960              		.loc 6 89 0
 3961 0004 2DED028B 		fstmfdd	sp!, {d8}
 3962              	.LCFI38:
 3963              		.cfi_def_cfa_offset 24
 3964              		.cfi_offset 80, -24
 3965              	.LBB85:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 3966              		.loc 6 90 0
 3967 0008 33E0     		b	.L218
 3968              	.LVL198:
 3969              	.L219:
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3970              		.loc 6 93 0 discriminator 2
 3971 000a 3048     		ldr	r0, .L224
 3972 000c A600     		lsls	r6, r4, #2
 3973 000e 8119     		adds	r1, r0, r6
 3974 0010 2046     		mov	r0, r4
 3975 0012 91ED008A 		flds	s16, [r1, #0]
 3976 0016 FFF7FEFF 		bl	_Z18getRawChannelValueh
 3977 001a 2D4B     		ldr	r3, .L224+4
 3978 001c 02EE900A 		fmsr	s5, r0	@ int
 3979 0020 9A19     		adds	r2, r3, r6
 3980 0022 92ED002A 		flds	s4, [r2, #0]
 3981 0026 B8EEE27A 		fsitos	s14, s5
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3982              		.loc 6 95 0 discriminator 2
 3983 002a 55F82420 		ldr	r2, [r5, r4, lsl #2]
 3984 002e 294B     		ldr	r3, .L224+8
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3985              		.loc 6 93 0 discriminator 2
 3986 0030 2948     		ldr	r0, .L224+12
 3987 0032 08EE072A 		fmacs	s4, s16, s14
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3988              		.loc 6 95 0 discriminator 2
 3989 0036 01EE102A 		fmsr	s2, r2	@ int
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3990              		.loc 6 93 0 discriminator 2
 3991 003a FDEEC21A 		ftosizs	s3, s4
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3992              		.loc 6 95 0 discriminator 2
 3993 003e 9E19     		adds	r6, r3, r6
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3994              		.loc 6 93 0 discriminator 2
 3995 0040 11EE901A 		fmrs	r1, s3	@ int
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 3996              		.loc 6 95 0 discriminator 2
 3997 0044 F8EEE17A 		fsitos	s15, s3
 3998 0048 F8EEC10A 		fsitos	s1, s2
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 3999              		.loc 6 93 0 discriminator 2
 4000 004c 40F82410 		str	r1, [r0, r4, lsl #2]
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 4001              		.loc 6 95 0 discriminator 2
 4002 0050 3268     		ldr	r2, [r6, #0]	@ float
 4003 0052 17EE900A 		fmrs	r0, s15
 4004 0056 10EE901A 		fmrs	r1, s1
 4005 005a FFF7FEFF 		bl	_Z12filterSmoothfff
 4006 005e 00EE100A 		fmsr	s0, r0
 4007 0062 BDEEC06A 		ftosizs	s12, s0
 4008 0066 16EE100A 		fmrs	r0, s12	@ int
 4009 006a 45F82400 		str	r0, [r5, r4, lsl #2]
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 4010              		.loc 6 90 0 discriminator 2
 4011 006e 0134     		adds	r4, r4, #1
 4012              	.LVL199:
 4013 0070 E4B2     		uxtb	r4, r4
 4014              	.LVL200:
 4015              	.L218:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 4016              		.loc 6 90 0 is_stmt 0 discriminator 1
 4017 0072 1A4D     		ldr	r5, .L224+16
 4018 0074 2A68     		ldr	r2, [r5, #0]
 4019 0076 1A4D     		ldr	r5, .L224+20
 4020 0078 9442     		cmp	r4, r2
 4021 007a C6DB     		blt	.L219
 4022              	.LVL201:
 4023              	.LBE85:
 4024              	.LBB86:
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 4025              		.loc 6 100 0 is_stmt 1
 4026 007c 194C     		ldr	r4, .L224+24
 4027              	.LVL202:
 4028 007e 94ED007A 		flds	s14, [r4, #0]
 4029 0082 0023     		movs	r3, #0
 4030              	.LVL203:
 4031              	.L220:
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 4032              		.loc 6 100 0 is_stmt 0 discriminator 2
 4033 0084 1849     		ldr	r1, .L224+28
 4034 0086 EC58     		ldr	r4, [r5, r3]
 4035 0088 5858     		ldr	r0, [r3, r1]
 4036 008a 1849     		ldr	r1, .L224+32
 4037 008c 241A     		subs	r4, r4, r0
 4038 008e 04EE904A 		fmsr	s9, r4	@ int
 4039 0092 04EE100A 		fmsr	s8, r0	@ int
 4040 0096 F8EEE46A 		fsitos	s13, s9
 4041 009a F8EEC43A 		fsitos	s7, s8
 4042 009e 46EE873A 		fmacs	s7, s13, s14
 4043 00a2 BDEEE33A 		ftosizs	s6, s7
 4044 00a6 13EE100A 		fmrs	r0, s6	@ int
 4045 00aa 5850     		str	r0, [r3, r1]
 4046 00ac 0433     		adds	r3, r3, #4
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 4047              		.loc 6 99 0 is_stmt 1 discriminator 2
 4048 00ae 0C2B     		cmp	r3, #12
 4049 00b0 E8D1     		bne	.L220
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 4050              		.loc 6 99 0 is_stmt 0
 4051 00b2 0323     		movs	r3, #3
 4052 00b4 05E0     		b	.L221
 4053              	.LVL204:
 4054              	.L222:
 4055              	.LBE86:
 4056              	.LBB87:
 104:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 4057              		.loc 6 104 0 is_stmt 1 discriminator 2
 4058 00b6 55F82300 		ldr	r0, [r5, r3, lsl #2]
 4059 00ba 41F82300 		str	r0, [r1, r3, lsl #2]
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 4060              		.loc 6 103 0 discriminator 2
 4061 00be 0133     		adds	r3, r3, #1
 4062              	.LVL205:
 4063 00c0 DBB2     		uxtb	r3, r3
 4064              	.LVL206:
 4065              	.L221:
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 4066              		.loc 6 103 0 is_stmt 0 discriminator 1
 4067 00c2 9342     		cmp	r3, r2
 4068 00c4 F7DB     		blt	.L222
 4069              	.LBE87:
 106:../Libraries/AQ_Receiver/Receiver.h **** }
 4070              		.loc 6 106 0 is_stmt 1
 4071 00c6 BDEC028B 		fldmfdd	sp!, {d8}
 4072 00ca 70BD     		pop	{r4, r5, r6, pc}
 4073              	.L225:
 4074              		.align	2
 4075              	.L224:
 4076 00cc 00000000 		.word	.LANCHOR4
 4077 00d0 00000000 		.word	.LANCHOR5
 4078 00d4 00000000 		.word	.LANCHOR6
 4079 00d8 00000000 		.word	.LANCHOR54
 4080 00dc 00000000 		.word	.LANCHOR0
 4081 00e0 00000000 		.word	.LANCHOR2
 4082 00e4 00000000 		.word	.LANCHOR55
 4083 00e8 00000000 		.word	.LANCHOR3
 4084 00ec 00000000 		.word	.LANCHOR1
 4085              		.cfi_endproc
 4086              	.LFE124:
 4088              		.section	.text._Z15setChannelValuehi,"ax",%progbits
 4089              		.align	1
 4090              		.global	_Z15setChannelValuehi
 4091              		.thumb
 4092              		.thumb_func
 4094              	_Z15setChannelValuehi:
 4095              	.LFB186:
 200:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 201:../Libraries/AQ_Receiver/Receiver_STM32.h **** 
 202:../Libraries/AQ_Receiver/Receiver_STM32.h **** void setChannelValue(byte channel,int value) {
 4096              		.loc 16 202 0
 4097              		.cfi_startproc
 4098              		@ args = 0, pretend = 0, frame = 0
 4099              		@ frame_needed = 0, uses_anonymous_args = 0
 4100              		@ link register save eliminated.
 4101              	.LVL207:
 203:../Libraries/AQ_Receiver/Receiver_STM32.h **** }
 4102              		.loc 16 203 0
 4103 0000 7047     		bx	lr
 4104              		.cfi_endproc
 4105              	.LFE186:
 4107              		.section	.text._Z11writeMotorsv,"ax",%progbits
 4108              		.align	1
 4109              		.global	_Z11writeMotorsv
 4110              		.thumb
 4111              		.thumb_func
 4113              	_Z11writeMotorsv:
 4114              	.LFB189:
 4115              		.file 17 "../Libraries/AQ_Motors/Motors_STM32.h"
   1:../Libraries/AQ_Motors/Motors_STM32.h **** #ifndef _AEROQUAD_MOTORS_STM32_H_
   2:../Libraries/AQ_Motors/Motors_STM32.h **** #define _AEROQUAD_MOTORS_STM32_H_
   3:../Libraries/AQ_Motors/Motors_STM32.h **** 
   4:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_Motors/Motors_STM32.h **** 
   6:../Libraries/AQ_Motors/Motors_STM32.h **** #include "Motors.h"
   7:../Libraries/AQ_Motors/Motors_STM32.h **** 
   8:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
   9:../Libraries/AQ_Motors/Motors_STM32.h **** // definition section
  10:../Libraries/AQ_Motors/Motors_STM32.h **** 
  11:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined (USE_400HZ_ESC)
  12:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_FREQUENCY 400   // in Hz
  13:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  14:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_FREQUENCY 300   // in Hz
  15:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  16:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_PERIODE     (1000000/PWM_FREQUENCY)
  17:../Libraries/AQ_Motors/Motors_STM32.h **** 
  18:../Libraries/AQ_Motors/Motors_STM32.h **** #ifdef MOTORS_STM32_TRI
  19:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_SERVO_FREQUENCY 50 // Hz 
  20:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_SERVO_PERIODE   (1000000/PWM_SERVO_FREQUENCY)
  21:../Libraries/AQ_Motors/Motors_STM32.h ****   #define STM32_MOTOR_MAP stm32_motor_mapping_tri
  22:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  23:../Libraries/AQ_Motors/Motors_STM32.h ****   #define STM32_MOTOR_MAP stm32_motor_mapping
  24:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  25:../Libraries/AQ_Motors/Motors_STM32.h **** 
  26:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
  27:../Libraries/AQ_Motors/Motors_STM32.h **** // code section
  28:../Libraries/AQ_Motors/Motors_STM32.h **** 
  29:../Libraries/AQ_Motors/Motors_STM32.h **** static int _stm32_motor_number;
  30:../Libraries/AQ_Motors/Motors_STM32.h **** 
  31:../Libraries/AQ_Motors/Motors_STM32.h **** // global section
  32:../Libraries/AQ_Motors/Motors_STM32.h **** 
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
  34:../Libraries/AQ_Motors/Motors_STM32.h ****  
  35:../Libraries/AQ_Motors/Motors_STM32.h ****   int motor;
  36:../Libraries/AQ_Motors/Motors_STM32.h **** 
  37:../Libraries/AQ_Motors/Motors_STM32.h ****   _stm32_motor_number = sizeof(STM32_MOTOR_MAP)/sizeof(STM32_MOTOR_MAP[0]);
  38:../Libraries/AQ_Motors/Motors_STM32.h ****   if(numbers < _stm32_motor_number) {
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     _stm32_motor_number = numbers;
  40:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  41:../Libraries/AQ_Motors/Motors_STM32.h ****   
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
  43:../Libraries/AQ_Motors/Motors_STM32.h **** 
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
  45:../Libraries/AQ_Motors/Motors_STM32.h **** 
  46:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_prescaler(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, prescaler);
  47:../Libraries/AQ_Motors/Motors_STM32.h **** 
  48:../Libraries/AQ_Motors/Motors_STM32.h **** #ifdef MOTORS_STM32_TRI
  49:../Libraries/AQ_Motors/Motors_STM32.h ****     // on Tri mode motor 0 is a servo and thus has slower update rate
  50:../Libraries/AQ_Motors/Motors_STM32.h ****     if (motor == 0) {
  51:../Libraries/AQ_Motors/Motors_STM32.h ****       timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_SERVO_PERIODE);
  52:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  53:../Libraries/AQ_Motors/Motors_STM32.h ****     else {
  54:../Libraries/AQ_Motors/Motors_STM32.h ****       timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
  55:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  56:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  57:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
  58:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  59:../Libraries/AQ_Motors/Motors_STM32.h ****     
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
  61:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  62:../Libraries/AQ_Motors/Motors_STM32.h ****   
  63:../Libraries/AQ_Motors/Motors_STM32.h ****   // sync timer
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  67:../Libraries/AQ_Motors/Motors_STM32.h ****   
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
  69:../Libraries/AQ_Motors/Motors_STM32.h ****   //Serial.println("motor init done\r\n");
  70:../Libraries/AQ_Motors/Motors_STM32.h **** }
  71:../Libraries/AQ_Motors/Motors_STM32.h **** 
  72:../Libraries/AQ_Motors/Motors_STM32.h **** void writeMotors(void) { // update motor commands on timers
 4116              		.loc 17 72 0
 4117              		.cfi_startproc
 4118              		@ args = 0, pretend = 0, frame = 0
 4119              		@ frame_needed = 0, uses_anonymous_args = 0
 4120              	.LVL208:
 4121 0000 38B5     		push	{r3, r4, r5, lr}
 4122              	.LCFI39:
 4123              		.cfi_def_cfa_offset 16
 4124              		.cfi_offset 14, -4
 4125              		.cfi_offset 5, -8
 4126              		.cfi_offset 4, -12
 4127              		.cfi_offset 3, -16
 4128              	.LBB88:
  73:../Libraries/AQ_Motors/Motors_STM32.h **** 
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4129              		.loc 17 74 0
 4130 0002 0B4D     		ldr	r5, .L230
 4131 0004 0024     		movs	r4, #0
 4132 0006 0EE0     		b	.L228
 4133              	.LVL209:
 4134              	.L229:
  75:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_compare(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PIN_MAP[STM32_MOTOR_MAP[motor]]
 4135              		.loc 17 75 0 discriminator 2
 4136 0008 0A4A     		ldr	r2, .L230+4
 4137 000a 0B48     		ldr	r0, .L230+8
 4138 000c 14F802C0 		ldrb	ip, [r4, r2]	@ zero_extendqisi2
 4139 0010 55F8042F 		ldr	r2, [r5, #4]!
 4140 0014 00EB0C13 		add	r3, r0, ip, lsl #4
 4141 0018 92B2     		uxth	r2, r2
 4142              		.file 18 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   This program is free software: you can redistribute it and/or modify
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   it under the terms of the GNU General Public License as published by
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   the Free Software Foundation, either version 3 of the License, or
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   (at your option) any later version.
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   This program is distributed in the hope that it will be useful,
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   GNU General Public License for more details.
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   You should have received a copy of the GNU General Public License
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /****************************************************************************
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    Before flight, select the different user options for your AeroQuad by
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    editing UserConfiguration.h.
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    If you need additional assistance go to http://www.aeroquad.com/forum.php
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    or talk to us live on IRC #aeroquad
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** *****************************************************************************/
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //***************************************************************************
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //***************Lidar Sensor variable for altitude hold*********************
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //***************************************************************************
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** unsigned long pulseWidth;
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //signed long d;  //d for distance
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //signed long d_corr, d_filt;  //d corrected for for biass offset
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** signed long kal_filt;
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //int t,t_1;
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** float k = 0,out;
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** float kX =0,kY=0;
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** float est_val = 70,est_err = 90; // 70,90
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** float est_valX = 70,est_errX = 90; // 70,90
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** float est_valY = 70,est_errY = 90; // 70,90
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** int pre_value;
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define meas_err 10 // 10 
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define meas_errX 10 // 10 
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define meas_errY 10 // 10 
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define q 0.5 //0.22 //0.25
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define qX 4.5 //0.22 //0.25
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define qY 4.5 //0.22 //0.25
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //#include "ultrasonic_sensor.h"
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** float kal(signed long);
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************************************
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "UserConfiguration.h" // Edit this file first before uploading to the AeroQuad
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // Define Security Checks
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPSNMEA) || defined(UseGPSUBLOX) || defined(UseGPSMTK) || defined(UseGPS406)
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  #define UseGPS
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPSNavigator) && !defined(AltitudeHoldBaro)
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "GpsNavigation NEED AltitudeHoldBaro defined"
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(AutoLanding) && (!defined(AltitudeHoldBaro) || !defined(AltitudeHoldRangeFinder))
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "AutoLanding NEED AltitudeHoldBaro and AltitudeHoldRangeFinder defined"
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(ReceiverSBUS) && defined(SlowTelemetry)
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "Receiver SWBUS and SlowTelemetry are in conflict for Seria2, they can't be used together"
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined (CameraTXControl) && !defined (CameraControl)
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #error "CameraTXControl need to have CameraControl defined"
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <EEPROM.h>
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <Wire.h>
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <GlobalDefined.h>
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "AeroQuad.h"
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "PID.h"
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <AQMath.h>
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include <FourtOrderFilter.h>
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef BattMonitor
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <BatteryMonitorTypes.h>
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********* PLATFORM SPECIFIC SECTION ********************
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********* HARDWARE GENERALIZATION SECTION **************
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef AeroQuadSTM32
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "AeroQuad_STM32.h" 
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // default to 10bit ADC (AVR)
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifndef ADC_NUMBER_OF_BITS		// for STM32 already defined = 12
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #define ADC_NUMBER_OF_BITS 10
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** KINEMATICS DECLARATION **************
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "Kinematics.h"
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // CHR6DM have it's own kinematics, so, initialize in it's scope
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #else
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "Kinematics_ARG.h"
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******************** RECEIVER DECLARATION **************
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(ReceiverHWPPM)
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_HWPPM.h>
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(ReceiverPPM)
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_PPM.h>
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(AeroQuad_Mini) && (defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Conf
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_PPM.h>
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RemotePCReceiver)
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_RemotePC.h>
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(ReceiverSBUS)
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_SBUS.h>
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_328P)
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_328p.h>
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_MEGA)
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_MEGA.h>
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_APM)
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_APM.h>
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_STM32PPM)
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_STM32PPM.h>  
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(RECEIVER_STM32)
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Receiver_STM32.h>  
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseAnalogRSSIReader) 
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <AnalogRSSIReader.h>
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(UseEzUHFRSSIReader)
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <EzUHFRSSIReader.h>
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(UseSBUSRSSIReader)
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <SBUSRSSIReader.h>
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************** MOTORS DECLARATION **************
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(MOTOR_STM32)
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Motors_STM32.h>    
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******* HEADING HOLD MAGNETOMETER DECLARATION **********
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(HMC5843)
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <HeadingFusionProcessorMARG.h>
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Magnetometer_HMC5843.h>
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(SPARKFUN_9DOF_5883L) || defined(SPARKFUN_5883L_BOB) || defined(HMC5883L)
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <HeadingFusionProcessorMARG.h>
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Magnetometer_HMC5883L.h>
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(COMPASS_CHR6DM)
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******* ALTITUDE HOLD BAROMETER DECLARATION ************
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(BMP085)
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <BarometricSensor_BMP085.h>
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(MS5611)
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  #include <BarometricSensor_MS5611.h>
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(XLMAXSONAR)
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <MaxSonarRangeFinder.h>
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************************************************************************
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******** Define this when using Ultrasonic/Lidar Sensor *********************
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************************************************************************
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(AltitudeLidar)             
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #include "lidar_lib.h" //LIDAR library
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    //#include "wiring_pulse.c"    
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif 
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(Lidar2D)
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "Hokuyo.h"
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //*************** BATTERY MONITOR DECLARATION ************
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef BattMonitor
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <BatteryMonitor.h>
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifndef BattCustomConfig
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BattCustomConfig BattDefaultConfig
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   struct BatteryData batteryData[] = {BattCustomConfig};
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //************** CAMERA CONTROL DECLARATION **************
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // used only on mega for now
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(CameraControl_STM32)
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <CameraStabilizer_STM32.h>
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(CameraControl)
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <CameraStabilizer_Aeroquad.h>
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined (CameraTXControl)
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <CameraStabilizer_TXControl.h>
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //******** FLIGHT CONFIGURATION DECLARATION **************
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(quadXConfig)
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlQuadX.h"
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(quadPlusConfig)
 230:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlQuadPlus.h"
 231:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(hexPlusConfig)
 232:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlHexPlus.h"
 233:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(hexXConfig)
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlHexX.h"
 235:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(triConfig)
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlTri.h"
 237:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(quadY4Config)
 238:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlQuadY4.h"
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(hexY6Config)
 240:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlHexY6.h"
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(octoX8Config)
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlOctoX8.h"
 243:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(octoXConfig)
 244:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlOctoX.h"
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #elif defined(octoPlusConfig)
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "FlightControlOctoPlus.h"
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 249:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 250:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** GPS DECLARATION *********************
 251:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 252:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPS)
 253:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if !defined(HeadingMagHold)
 254:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #error We need the magnetometer to use the GPS
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif 
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <GpsAdapter.h>
 257:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "GpsNavigator.h"
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 260:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 261:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** OSD DEVICE DECLARATION **************
 262:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef MAX7456_OSD     // only OSD supported for now is the MAX7456
 264:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <Device_SPI.h>
 265:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "OSDDisplayController.h"
 266:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "MAX7456.h"
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 269:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(SERIAL_LCD)
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "SerialLCD.h"
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 273:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef OSD_SYSTEM_MENU
 274:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if !defined(MAX7456_OSD) && !defined(SERIAL_LCD)
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #error "Menu cannot be used without OSD or LCD"
 276:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "OSDMenu.h"
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 280:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 281:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 282:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //****************** SERIAL PORT DECLARATION *************
 283:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** //********************************************************
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(WirelessTelemetry) 
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT Serial3
 287:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else    // force 328p to use the normal port
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT Serial
 289:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 290:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #else  
 291:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(SERIAL_USES_USB)   // STM32 Maple
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT SerialUSB
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #undef BAUD
 294:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define BAUD
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #else
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #define SERIAL_PORT Serial
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 298:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif  
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 300:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef SlowTelemetry
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <AQ_RSCode.h>
 302:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 303:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 304:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #ifdef SoftModem
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include <AQ_SoftModem.h>
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 309:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** // Include this last as it contains objects from above declarations
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "AltitudeControlProcessor.h"
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "PositionControlProcessor.h"
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "FlightControlProcessor.h"
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "FlightCommandProcessor.h"
 314:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "HeadingHoldProcessor.h"
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #include "DataStorage.h"
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(UseGPS) || defined(BattMonitor)
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "LedStatusProcessor.h"
 319:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif  
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #if defined(MavLink)
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "MavLink.h"
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #else
 324:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #include "SerialCom.h"
 325:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** #endif
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * Main setup function, called one time at bootup
 331:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * initialize all system and sub system of the
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * Aeroquad
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void setup() {
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initCommunication();		// does nothing if Mavlink.h is not included 
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
 342:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   boolean firstTimeBoot = false;
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeEEPROM();
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     firstTimeBoot = true;
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 348:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 349:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initPlatform();
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config) || defined(triConfig
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initializeMotors(FOUR_Motors);
 353:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif	
 354:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 355:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
 356:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initReceiverFromEEPROM();
 357:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 358:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Initialize sensors
 359:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // If sensors have a common initialization routine
 360:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // insert it into the gyro class because it executes first
 361:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
 362:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   while (!calibrateGyro()); // this make sure the craft is still befor to continue init process
 363:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
 364:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (firstTimeBoot) {
 365:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     computeAccelBias();
 366:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
 367:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 368:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   setupFourthOrder();
 369:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initSensorsZeroFromEEPROM();
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Integral Limit for attitude mode
 372:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // This overrides default set in readEEPROM()
 373:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Set for 1/2 max attitude command (+/-0.75 radians)
 374:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Rate integral not used for now
 375:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_XAXIS_PID_IDX].windupGuard = 0.375;
 376:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_YAXIS_PID_IDX].windupGuard = 0.375;
 377:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 378:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Flight angle estimation
 379:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeKinematics();
 380:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 381:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef HeadingMagHold
 382:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= HEADINGHOLD_ENABLED;
 383:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeMagnetometer();
 384:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeHeadingFusion();
 385:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 386:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 387:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Optional Sensors
 388:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 389:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeBaro();
 390:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 391:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 392:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 393:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     inititalizeRangeFinders();
 394:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= RANGE_ENABLED;
 395:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = PID[BARO_ALTITUDE_HOLD_PID_IDX].P*2;
 396:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = PID[BARO_ALTITUDE_HOLD_PID_IDX].I;
 397:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = PID[BARO_ALTITUDE_HOLD_PID_IDX].D;
 398:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard;
 399:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 400:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 401:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef BattMonitor
 402:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeBatteryMonitor(sizeof(batteryData) / sizeof(struct BatteryData), batteryMonitorAlarmV
 403:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= BATTMONITOR_ENABLED;
 404:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 405:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 406:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(CameraControl)
 407:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeCameraStabilization();
 408:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= CAMERASTABLE_ENABLED;
 409:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 410:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 411:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(MAX7456_OSD)
 412:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeSPI();
 413:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeOSD();
 414:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 415:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 416:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(SERIAL_LCD)
 417:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     InitSerialLCD();
 418:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 419:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 420:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(BinaryWrite) || defined(BinaryWritePID)
 421:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef OpenlogBinaryWrite
 422:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       binaryPort = &Serial1;
 423:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       binaryPort->begin(115200);
 424:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       delay(1000);
 425:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #else
 426:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      binaryPort = &Serial;
 427:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 428:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 429:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 430:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseGPS)
 431:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeGps();
 432:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif 
 433:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(Lidar2D)
 434:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Init_Hokuyo();
 435:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 436:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef SlowTelemetry
 437:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initSlowTelemetry();
 438:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 439:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 440:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   previousTime = micros();
 441:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
 442:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   safetyCheck = 0;
 443:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 444:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /********************************************************
 445:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** ************** Lidar Sensor Pin declaration*************
 446:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** ********************************************************/ 
 447:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*
 448:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     begin(int configuration, bool fasti2c, char lidarliteAddress)
 449:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Starts the sensor and I2C.
 450:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Parameters
 451:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     ----------------------------------------------------------------------------
 452:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     configuration: Default 0. Selects one of several preset configurations.
 453:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     fasti2c: Default 100 kHz. I2C base frequency.
 454:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       If true I2C frequency is set to 400kHz.
 455:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     lidarliteAddress: Default 0x62. Fill in new address here if changed. See
 456:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       operating manual for instructions.
 457:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   */
 458:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   myLidarLite.begin(0, false); // Set configuration to default and I2C to 100 kHz
 459:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 460:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /*
 461:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     configure(int configuration, char lidarliteAddress)
 462:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Selects one of several preset configurations.
 463:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Parameters
 464:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     ----------------------------------------------------------------------------
 465:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     configuration:  Default 0.
 466:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       0: Default mode, balanced performance.
 467:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       1: Short range, high speed. Uses 0x1d maximum acquisition count.
 468:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       2: Default range, higher speed short range. Turns on quick termination
 469:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           detection for faster measurements at short range (with decreased
 470:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           accuracy)
 471:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       3: Maximum range. Uses 0xff maximum acquisition count.
 472:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       4: High sensitivity detection. Overrides default valid measurement detection
 473:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           algorithm, and uses a threshold value for high sensitivity and noise.
 474:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       5: Low sensitivity detection. Overrides default valid measurement detection
 475:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           algorithm, and uses a threshold value for low sensitivity and noise.
 476:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     lidarliteAddress: Default 0x62. Fill in new address here if changed. See
 477:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       operating manual for instructions.
 478:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   */
 479:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** myLidarLite.configure(0); // Change this number to try out alternate configurations
 480:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 481:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 482:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 483:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 100Hz task
 484:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
 486:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //SERIAL_PRINT("A");
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 488:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hundredHZpreviousTime = currentTime;
 489:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 490:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateGyroRate();
 491:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateMetersPerSec();
 492:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 493:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 494:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 495:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 496:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   calculateKinematics(gyroRate[XAXIS], gyroRate[YAXIS], gyroRate[ZAXIS], filteredAccel[XAXIS], filt
 498:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 499:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     zVelocity = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + isq(fi
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (!runtimaZBiasInitialized) {
 502:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimeZBias = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + i
 503:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimaZBiasInitialized = true;
 504:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 505:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity += zVelocity;
 506:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity = (velocityCompFilter1 * zVelocity) + (velocityCompFilter2 * estimatedZVeloc
 507:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif    
 508:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 509:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    #if defined(AltitudeLidar) 
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         estimatedAltitude = alt_read();
 511:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         //estimatedAltitude *= (cos(kinematicsAngle[YAXIS])*(cos(kinematicsAngle[XAXIS])));
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         if((estimatedAltitude-prevAltitude)>0){  //up motion
 513:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           zDirection = 1;
 514:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         }
 515:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         else if ((estimatedAltitude-prevAltitude)<0){  //down motion
 516:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           zDirection =0;
 517:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         }
 518:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         prevAltitude=estimatedAltitude;
 519:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #elif defined(AltitudeHoldBaro)
 520:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureBaroSum(); 
 521:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  //  50 Hz tasks
 522:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       evaluateBaroAltitude();
 523:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 524:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 525:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         
 526:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   processFlightControl();
 527:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 528:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 529:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(BinaryWrite)
 530:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (fastTransfer == ON) {
 531:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       // write out fastTelemetry to Configurator or openLog
 532:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       fastTelemetry();
 533:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 534:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif      
 535:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 536:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef SlowTelemetry
 537:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     updateSlowTelemetry100Hz();
 538:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 539:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 540:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseGPS)
 541:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     updateGps();
 542:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif      
 543:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 544:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(CameraControl)
 545:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
 546:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #if defined CameraTXControl
 547:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       processCameraTXControl();
 548:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 549:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif       
 550:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 551:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 552:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 553:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 554:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 50Hz task
 555:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 556:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process50HzTask() {
 557:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 558:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   fiftyHZpreviousTime = currentTime;
 559:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 560:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Reads external pilot commands and performs functions based on stick configuration
 561:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readPilotCommands(); 
 562:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 563:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseAnalogRSSIReader) || defined(UseEzUHFRSSIReader) || defined(UseSBUSRSSIReader)
 564:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     readRSSI();
 565:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 566:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 567:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 568:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     updateRangeFinders();
 569:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 570:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 571:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(UseGPS)
 572:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (haveAGpsLock() && !isHomeBaseInitialized()) {
 573:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       initHomeBase();
 574:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 575:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif      
 576:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 577:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 578:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 579:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 10Hz task
 580:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 581:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask1() {
 582:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 583:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(HeadingMagHold)
 584:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 585:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
 586:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     tenHZpreviousTime = currentTime;
 587:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      
 588:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureMagnetometer(kinematicsAngle[XAXIS], kinematicsAngle[YAXIS]);
 589:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 590:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     calculateHeading();
 591:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 592:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 593:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 594:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(Lidar2D)
 595:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 596:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   Hokuyo_Read();
 597:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 598:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****    //first check weather kinematicAngles are in rads or not    --CHECKED
 599:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //PrintValueComma(count);
 600:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //distance2D[plus_X] =int(float(distance2D[plus_X])*cos(kinematicsAngle[XAXIS]));  //roll angle
 601:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //distance2D[minus_X] =distance2D[minus_X]*cos(kinematicsAngle[XAXIS]); //roll angle
 602:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //distance2D[plus_Y] =int(float(distance2D[plus_Y])*cos(kinematicsAngle[YAXIS])); //pitch angle 
 603:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //PrintValueComma(distance2D[plus_X]);
 604:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //PrintValueComma(distance2D[plus_Y]);
 605:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_XRaw = distance2D[plus_X];
 606:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_YRaw = distance2D[plus_Y];
 607:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if(distance2D[plus_X] !=0){
 608:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     LastNonZeroRoll = distance2D[plus_X];
 609:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 610:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   else if(distance2D[plus_X] ==0){
 611:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     distance2D[plus_X] =LastNonZeroRoll;
 612:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 613:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 614:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if(distance2D[plus_Y] !=0){
 615:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     LastNonZeroPitch = distance2D[plus_Y];
 616:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 617:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   else if(distance2D[plus_Y] ==0){
 618:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     distance2D[plus_Y] =LastNonZeroPitch;
 619:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }  
 620:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_X] =kal_hokuyoX(distance2D[plus_X]);  //roll
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_Y] =kal_hokuyoY(distance2D[plus_Y]);  //pitch
 622:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_X] - prevRoll)>0){
 623:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     RollVelocityDirection = 0;    //in -ve X(roll)
 624:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 625:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   else{
 626:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     RollVelocityDirection = 1;  //in +ve X
 627:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 628:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   prevRoll = distance2D[plus_X];
 629:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 630:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_Y]-prevPitch)>0){
 631:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PitchVelocityDirection = 0;  //in  -ve Y(pitch)
 632:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 633:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   else{
 634:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PitchVelocityDirection = 1;  // in +ver Y
 635:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 636:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   prevPitch = distance2D[plus_Y];
 637:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 638:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 639:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   /*
 640:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PrintValueComma(kinematicsAngle[YAXIS]);
 641:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PrintValueComma(cos(kinematicsAngle[YAXIS]));
 642:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PrintValueComma(kinematicsAngle[XAXIS]);
 643:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   SERIAL_PRINTLN(cos(kinematicsAngle[XAXIS])); */  
 644:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   //SERIAL_PRINTLN(distance2D[plus_Y]);
 645:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 646:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 647:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 648:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 649:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 650:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * low priority 10Hz task 2
 651:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 652:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask2() {
 653:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 654:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   lowPriorityTenHZpreviousTime = currentTime;
 655:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 656:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #if defined(BattMonitor)
 657:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     measureBatteryVoltage(G_Dt*1000.0);
 658:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 659:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 660:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // Listen for configuration commands and reports telemetry
 661:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readSerialCommand();
 662:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   sendSerialTelemetry();
 663:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 664:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 665:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 666:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * low priority 10Hz task 3
 667:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 668:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask3() {
 669:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 670:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     lowPriorityTenHZpreviousTime2 = currentTime;
 671:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 672:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef OSD_SYSTEM_MENU
 673:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       updateOSDMenu();
 674:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 675:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 676:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef MAX7456_OSD
 677:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       updateOSD();
 678:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 679:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 680:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #if defined(UseGPS) || defined(BattMonitor)
 681:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       processLedStatus();
 682:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 683:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 684:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #ifdef SlowTelemetry
 685:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       updateSlowTelemetry10Hz();
 686:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     #endif
 687:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 688:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 689:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 690:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * 1Hz task 
 691:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 692:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process1HzTask() {
 693:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #ifdef MavLink
 694:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - oneHZpreviousTime) / 1000000.0;
 695:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     oneHZpreviousTime = currentTime;
 696:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 697:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     sendSerialHeartbeat();  
 698:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   #endif
 699:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 700:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 701:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** /*******************************************************************
 702:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  * Main loop funtions
 703:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****  ******************************************************************/
 704:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void loop () {
 705:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 706:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 707:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 708:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   measureCriticalSensors();
 709:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 710:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // ================================================================
 711:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // 100Hz task loop
 712:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   // ================================================================
 713:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (deltaTime >= 10000) {
 714:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 715:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     frameCounter++;
 716:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 717:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     process100HzTask();
 718:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 719:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
 720:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // 50Hz task loop
 721:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
 722:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
 723:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process50HzTask();
 724:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 725:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** 
 726:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
 727:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // 10Hz task loop
 728:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
 729:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
 730:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask1();
 731:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 732:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
 733:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask2();
 734:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 735:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
 736:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask3();
 737:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 738:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 739:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
 740:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // 1Hz task loop
 741:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     // ================================================================
 742:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_1HZ == 0) {  //   1 Hz tasks
 743:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process1HzTask();
 744:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     }
 745:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     
 746:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     previousTime = currentTime;
 747:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 748:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   
 749:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (frameCounter >= 100) {
 750:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       frameCounter = 0;
 751:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   }
 752:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 4143              		.loc 18 752 0 discriminator 2
 4144 001a 5968     		ldr	r1, [r3, #4]
 4145              		.loc 17 75 0 discriminator 2
 4146 001c 0868     		ldr	r0, [r1, #0]
 4147 001e 597B     		ldrb	r1, [r3, #13]	@ zero_extendqisi2
 4148 0020 FFF7FEFF 		bl	timer_set_compare.isra.2
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4149              		.loc 17 74 0 discriminator 2
 4150 0024 0134     		adds	r4, r4, #1
 4151              	.LVL210:
 4152              	.L228:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4153              		.loc 17 74 0 is_stmt 0 discriminator 1
 4154 0026 0549     		ldr	r1, .L230+12
 4155 0028 0B68     		ldr	r3, [r1, #0]
 4156 002a 9C42     		cmp	r4, r3
 4157 002c ECDB     		blt	.L229
 4158              	.LBE88:
  76:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  77:../Libraries/AQ_Motors/Motors_STM32.h **** }
 4159              		.loc 17 77 0 is_stmt 1
 4160 002e 38BD     		pop	{r3, r4, r5, pc}
 4161              	.L231:
 4162              		.align	2
 4163              	.L230:
 4164 0030 FCFFFFFF 		.word	.LANCHOR56-4
 4165 0034 00000000 		.word	.LANCHOR57
 4166 0038 00000000 		.word	PIN_MAP
 4167 003c 00000000 		.word	.LANCHOR58
 4168              		.cfi_endproc
 4169              	.LFE189:
 4171              		.section	.text._Z16commandAllMotorsi,"ax",%progbits
 4172              		.align	1
 4173              		.global	_Z16commandAllMotorsi
 4174              		.thumb
 4175              		.thumb_func
 4177              	_Z16commandAllMotorsi:
 4178              	.LFB190:
  78:../Libraries/AQ_Motors/Motors_STM32.h **** 
  79:../Libraries/AQ_Motors/Motors_STM32.h **** void commandAllMotors(int _motorCommand) {   // Send same command to all motors
 4179              		.loc 17 79 0
 4180              		.cfi_startproc
 4181              		@ args = 0, pretend = 0, frame = 0
 4182              		@ frame_needed = 0, uses_anonymous_args = 0
 4183              	.LVL211:
 4184 0000 38B5     		push	{r3, r4, r5, lr}
 4185              	.LCFI40:
 4186              		.cfi_def_cfa_offset 16
 4187              		.cfi_offset 14, -4
 4188              		.cfi_offset 5, -8
 4189              		.cfi_offset 4, -12
 4190              		.cfi_offset 3, -16
 4191              		.loc 17 79 0
 4192 0002 0546     		mov	r5, r0
 4193              	.LBB89:
  80:../Libraries/AQ_Motors/Motors_STM32.h **** 
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4194              		.loc 17 81 0
 4195 0004 0024     		movs	r4, #0
 4196 0006 0BE0     		b	.L233
 4197              	.LVL212:
 4198              	.L234:
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_compare(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PIN_MAP[STM32_MOTOR_MAP[motor]]
 4199              		.loc 17 82 0 discriminator 2
 4200 0008 084B     		ldr	r3, .L235
 4201 000a 0948     		ldr	r0, .L235+4
 4202 000c E15C     		ldrb	r1, [r4, r3]	@ zero_extendqisi2
 4203 000e 00EB0113 		add	r3, r0, r1, lsl #4
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4204              		.loc 17 81 0 discriminator 2
 4205 0012 0134     		adds	r4, r4, #1
 4206              	.LVL213:
 4207              		.loc 18 752 0 discriminator 2
 4208 0014 5A68     		ldr	r2, [r3, #4]
 4209              		.loc 17 82 0 discriminator 2
 4210 0016 597B     		ldrb	r1, [r3, #13]	@ zero_extendqisi2
 4211 0018 1068     		ldr	r0, [r2, #0]
 4212 001a AAB2     		uxth	r2, r5
 4213 001c FFF7FEFF 		bl	timer_set_compare.isra.2
 4214              	.LVL214:
 4215              	.L233:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 4216              		.loc 17 81 0 discriminator 1
 4217 0020 0448     		ldr	r0, .L235+8
 4218 0022 0268     		ldr	r2, [r0, #0]
 4219 0024 9442     		cmp	r4, r2
 4220 0026 EFDB     		blt	.L234
 4221              	.LBE89:
  83:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  84:../Libraries/AQ_Motors/Motors_STM32.h **** }
 4222              		.loc 17 84 0
 4223 0028 38BD     		pop	{r3, r4, r5, pc}
 4224              	.L236:
 4225 002a 00BF     		.align	2
 4226              	.L235:
 4227 002c 00000000 		.word	.LANCHOR57
 4228 0030 00000000 		.word	PIN_MAP
 4229 0034 00000000 		.word	.LANCHOR58
 4230              		.cfi_endproc
 4231              	.LFE190:
 4233              		.section	.text._Z16initializeMotors9NB_Motors,"ax",%progbits
 4234              		.align	1
 4235              		.global	_Z16initializeMotors9NB_Motors
 4236              		.thumb
 4237              		.thumb_func
 4239              	_Z16initializeMotors9NB_Motors:
 4240              	.LFB188:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 4241              		.loc 17 33 0
 4242              		.cfi_startproc
 4243              		@ args = 0, pretend = 0, frame = 0
 4244              		@ frame_needed = 0, uses_anonymous_args = 0
 4245              	.LVL215:
 4246 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4247              	.LCFI41:
 4248              		.cfi_def_cfa_offset 24
 4249              		.cfi_offset 14, -4
 4250              		.cfi_offset 7, -8
 4251              		.cfi_offset 6, -12
 4252              		.cfi_offset 5, -16
 4253              		.cfi_offset 4, -20
 4254              		.cfi_offset 3, -24
 4255 0002 1E4D     		ldr	r5, .L243
 4256              	.LBB103:
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     _stm32_motor_number = numbers;
 4257              		.loc 17 39 0
 4258 0004 0728     		cmp	r0, #7
 4259 0006 C8BF     		it	gt
 4260 0008 0820     		movgt	r0, #8
 4261              	.LVL216:
 4262 000a 2860     		str	r0, [r5, #0]
 4263              	.LBE103:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 4264              		.loc 17 33 0
 4265 000c 0024     		movs	r4, #0
 4266 000e 18E0     		b	.L239
 4267              	.LVL217:
 4268              	.L240:
 4269              	.LBB122:
 4270              	.LBB104:
 4271              	.LBB105:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4272              		.loc 17 44 0 discriminator 2
 4273 0010 1B4E     		ldr	r6, .L243+4
 4274 0012 1C4F     		ldr	r7, .L243+8
 4275 0014 A65D     		ldrb	r6, [r4, r6]	@ zero_extendqisi2
 4276 0016 07EB0617 		add	r7, r7, r6, lsl #4
 4277              	.LBE105:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4278              		.loc 17 42 0 discriminator 2
 4279 001a 0134     		adds	r4, r4, #1
 4280              	.LVL218:
 4281              	.LBB114:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4282              		.loc 17 44 0 discriminator 2
 4283 001c 7868     		ldr	r0, [r7, #4]
 4284 001e 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 4285 0020 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 4286              	.LVL219:
 4287 0024 1849     		ldr	r1, .L243+12
 4288              		.loc 18 752 0 discriminator 2
 4289 0026 7B68     		ldr	r3, [r7, #4]
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4290              		.loc 17 44 0 discriminator 2
 4291 0028 B0FBF1F2 		udiv	r2, r0, r1
 4292              		.loc 18 752 0 discriminator 2
 4293 002c 1B68     		ldr	r3, [r3, #0]
 4294              	.LVL220:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 4295              		.loc 17 44 0 discriminator 2
 4296 002e 511E     		subs	r1, r2, #1
 4297              	.LBB106:
 4298              	.LBB107:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4299              		.loc 3 682 0 discriminator 2
 4300 0030 88B2     		uxth	r0, r1
 4301              	.LVL221:
 4302              	.LBE107:
 4303              	.LBE106:
 4304              	.LBB109:
 4305              	.LBB110:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 4306              		.loc 3 700 0 discriminator 2
 4307 0032 40F6C412 		movw	r2, #2500
 4308              	.LBE110:
 4309              	.LBE109:
 4310              	.LBB112:
 4311              	.LBB108:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 4312              		.loc 3 682 0 discriminator 2
 4313 0036 9862     		str	r0, [r3, #40]
 4314              	.LVL222:
 4315              	.LBE108:
 4316              	.LBE112:
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
 4317              		.loc 17 60 0 discriminator 2
 4318 0038 0721     		movs	r1, #7
 4319              	.LVL223:
 4320              	.LBB113:
 4321              	.LBB111:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 4322              		.loc 3 700 0 discriminator 2
 4323 003a DA62     		str	r2, [r3, #44]
 4324              	.LBE111:
 4325              	.LBE113:
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
 4326              		.loc 17 60 0 discriminator 2
 4327 003c 3046     		mov	r0, r6
 4328 003e FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 4329              	.LVL224:
 4330              	.L239:
 4331              	.LBE114:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4332              		.loc 17 42 0 discriminator 1
 4333 0042 2968     		ldr	r1, [r5, #0]
 4334 0044 8C42     		cmp	r4, r1
 4335 0046 E3DB     		blt	.L240
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4336              		.loc 17 42 0 is_stmt 0
 4337 0048 0023     		movs	r3, #0
 4338 004a 0EE0     		b	.L241
 4339              	.LVL225:
 4340              	.L242:
 4341              	.LBE104:
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
 4342              		.loc 17 65 0 is_stmt 1 discriminator 2
 4343 004c 0C48     		ldr	r0, .L243+4
 4344 004e 0D4A     		ldr	r2, .L243+8
 4345 0050 13F800C0 		ldrb	ip, [r3, r0]	@ zero_extendqisi2
 4346 0054 02EB0C12 		add	r2, r2, ip, lsl #4
 4347              	.LBB115:
 4348              		.loc 18 752 0 discriminator 2
 4349 0058 5068     		ldr	r0, [r2, #4]
 4350 005a 0268     		ldr	r2, [r0, #0]
 4351              	.LVL226:
 4352              	.LBE115:
 4353              	.LBB116:
 4354              	.LBB117:
 4355              	.LBB118:
 4356              	.LBB119:
 4357              	.LBB120:
 4358              	.LBB121:
 4359              		.file 19 "../Libmaple/libmaple/libmaple/bitband.h"
   1:../Libmaple/libmaple/libmaple/bitband.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/bitband.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/bitband.h ****  *
   4:../Libmaple/libmaple/libmaple/bitband.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/bitband.h ****  *
   6:../Libmaple/libmaple/libmaple/bitband.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/bitband.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/bitband.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/bitband.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/bitband.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/bitband.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/bitband.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/bitband.h ****  *
  14:../Libmaple/libmaple/libmaple/bitband.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/bitband.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/bitband.h ****  *
  17:../Libmaple/libmaple/libmaple/bitband.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/bitband.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/bitband.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/bitband.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/bitband.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/bitband.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/bitband.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/bitband.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/bitband.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/bitband.h **** 
  27:../Libmaple/libmaple/libmaple/bitband.h **** /**
  28:../Libmaple/libmaple/libmaple/bitband.h ****  * @file bitband.h
  29:../Libmaple/libmaple/libmaple/bitband.h ****  *
  30:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Bit-banding utility functions
  31:../Libmaple/libmaple/libmaple/bitband.h ****  */
  32:../Libmaple/libmaple/libmaple/bitband.h **** 
  33:../Libmaple/libmaple/libmaple/bitband.h **** #include "libmaple_types.h"
  34:../Libmaple/libmaple/libmaple/bitband.h **** 
  35:../Libmaple/libmaple/libmaple/bitband.h **** #ifndef _BITBAND_H_
  36:../Libmaple/libmaple/libmaple/bitband.h **** #define _BITBAND_H_
  37:../Libmaple/libmaple/libmaple/bitband.h **** 
  38:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_REF      0x20000000
  39:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_BASE     0x22000000
  40:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_REF      0x40000000
  41:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_BASE     0x42000000
  42:../Libmaple/libmaple/libmaple/bitband.h **** 
  43:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void*,
  44:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  45:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  46:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32);
  47:../Libmaple/libmaple/libmaple/bitband.h **** 
  48:../Libmaple/libmaple/libmaple/bitband.h **** /**
  49:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  50:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a volatile SRAM address.
  51:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded SRAM region
  52:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  53:../Libmaple/libmaple/libmaple/bitband.h ****  */
  54:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_sramp(volatile void *address, uint32 bit) {
  55:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_SRAM_BASE, BB_SRAM_REF);
  56:../Libmaple/libmaple/libmaple/bitband.h **** }
  57:../Libmaple/libmaple/libmaple/bitband.h **** 
  58:../Libmaple/libmaple/libmaple/bitband.h **** /**
  59:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the SRAM bit-band region.
  60:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to read from
  61:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  62:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  63:../Libmaple/libmaple/libmaple/bitband.h ****  */
  64:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_sram_get_bit(volatile void *address, uint32 bit) {
  65:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_sramp(address, bit);
  66:../Libmaple/libmaple/libmaple/bitband.h **** }
  67:../Libmaple/libmaple/libmaple/bitband.h **** 
  68:../Libmaple/libmaple/libmaple/bitband.h **** /**
  69:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the SRAM bit-band region.
  70:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to write to
  71:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
  72:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
  73:../Libmaple/libmaple/libmaple/bitband.h ****  */
  74:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_sram_set_bit(volatile void *address,
  75:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
  76:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
  77:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_sramp(address, bit) = val;
  78:../Libmaple/libmaple/libmaple/bitband.h **** }
  79:../Libmaple/libmaple/libmaple/bitband.h **** 
  80:../Libmaple/libmaple/libmaple/bitband.h **** /**
  81:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  82:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a peripheral address.
  83:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded peripheral region
  84:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  85:../Libmaple/libmaple/libmaple/bitband.h ****  */
  86:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_perip(volatile void *address, uint32 bit) {
  87:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_PERI_BASE, BB_PERI_REF);
  88:../Libmaple/libmaple/libmaple/bitband.h **** }
  89:../Libmaple/libmaple/libmaple/bitband.h **** 
  90:../Libmaple/libmaple/libmaple/bitband.h **** /**
  91:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the peripheral bit-band region.
  92:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to read from
  93:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  94:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  95:../Libmaple/libmaple/libmaple/bitband.h ****  */
  96:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_peri_get_bit(volatile void *address, uint32 bit) {
  97:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_perip(address, bit);
  98:../Libmaple/libmaple/libmaple/bitband.h **** }
  99:../Libmaple/libmaple/libmaple/bitband.h **** 
 100:../Libmaple/libmaple/libmaple/bitband.h **** /**
 101:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the peripheral bit-band region.
 102:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to write to
 103:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
 104:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
 105:../Libmaple/libmaple/libmaple/bitband.h ****  */
 106:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_peri_set_bit(volatile void *address,
 107:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
 108:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
 109:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_perip(address, bit) = val;
 110:../Libmaple/libmaple/libmaple/bitband.h **** }
 111:../Libmaple/libmaple/libmaple/bitband.h **** 
 112:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void *address,
 113:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bit,
 114:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_base,
 115:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_ref) {
 116:../Libmaple/libmaple/libmaple/bitband.h ****     return (volatile uint32*)(bb_base + ((uint32)address - bb_ref) * 32 +
 117:../Libmaple/libmaple/libmaple/bitband.h ****                               bit * 4);
 4360              		.loc 19 117 0 discriminator 2
 4361 005c 5001     		lsls	r0, r2, #5
 4362 005e 00F18442 		add	r2, r0, #1107296256
 4363              	.LBE121:
 4364              	.LBE120:
 4365              	.LBE119:
 4366              	.LBE118:
 725:../Libmaple/libmaple/libmaple/timer.h **** 
 726:../Libmaple/libmaple/libmaple/timer.h **** /**
 727:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Generate an update event for the given timer.
 728:../Libmaple/libmaple/libmaple/timer.h ****  *
 729:../Libmaple/libmaple/libmaple/timer.h ****  * Normally, this will cause the prescaler and auto-reload values in
 730:../Libmaple/libmaple/libmaple/timer.h ****  * the PSC and ARR registers to take immediate effect.  However, this
 731:../Libmaple/libmaple/libmaple/timer.h ****  * function will do nothing if the UDIS bit is set in the timer's CR1
 732:../Libmaple/libmaple/libmaple/timer.h ****  * register (UDIS is cleared by default).
 733:../Libmaple/libmaple/libmaple/timer.h ****  *
 734:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device to generate an update for.
 735:../Libmaple/libmaple/libmaple/timer.h ****  */
 736:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_generate_update(timer_dev *dev) {
 737:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->EGR, TIMER_EGR_UG_BIT) = 1;
 4367              		.loc 3 737 0 discriminator 2
 4368 0062 0120     		movs	r0, #1
 4369 0064 C2F88002 		str	r0, [r2, #640]
 4370              	.LBE117:
 4371              	.LBE116:
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4372              		.loc 17 64 0 discriminator 2
 4373 0068 1B18     		adds	r3, r3, r0
 4374              	.LVL227:
 4375              	.L241:
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 4376              		.loc 17 64 0 is_stmt 0 discriminator 1
 4377 006a 8B42     		cmp	r3, r1
 4378 006c EEDB     		blt	.L242
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
 4379              		.loc 17 68 0 is_stmt 1
 4380 006e 4FF47A70 		mov	r0, #1000
 4381              	.LBE122:
  70:../Libraries/AQ_Motors/Motors_STM32.h **** }
 4382              		.loc 17 70 0
 4383 0072 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 4384              	.LBB123:
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
 4385              		.loc 17 68 0
 4386 0076 FFF7FEBF 		b	_Z16commandAllMotorsi
 4387              	.LVL228:
 4388              	.L244:
 4389 007a 00BF     		.align	2
 4390              	.L243:
 4391 007c 00000000 		.word	.LANCHOR58
 4392 0080 00000000 		.word	.LANCHOR57
 4393 0084 00000000 		.word	PIN_MAP
 4394 0088 40420F00 		.word	1000000
 4395              	.LBE123:
 4396              		.cfi_endproc
 4397              	.LFE188:
 4399              		.section	.text._Z11pulseMotorsh,"ax",%progbits
 4400              		.align	1
 4401              		.global	_Z11pulseMotorsh
 4402              		.thumb
 4403              		.thumb_func
 4405              	_Z11pulseMotorsh:
 4406              	.LFB187:
 4407              		.file 20 "../Libraries/AQ_Motors/Motors.h"
   1:../Libraries/AQ_Motors/Motors.h **** /*
   2:../Libraries/AQ_Motors/Motors.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Motors/Motors.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Motors/Motors.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Motors/Motors.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Motors/Motors.h ****  
   7:../Libraries/AQ_Motors/Motors.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Motors/Motors.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Motors/Motors.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Motors/Motors.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Motors/Motors.h **** 
  12:../Libraries/AQ_Motors/Motors.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Motors/Motors.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Motors/Motors.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Motors/Motors.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Motors/Motors.h **** 
  17:../Libraries/AQ_Motors/Motors.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Motors/Motors.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Motors/Motors.h **** */
  20:../Libraries/AQ_Motors/Motors.h **** 
  21:../Libraries/AQ_Motors/Motors.h **** 
  22:../Libraries/AQ_Motors/Motors.h **** #ifndef _AEROQUAD_MOTORS_H_
  23:../Libraries/AQ_Motors/Motors.h **** #define _AEROQUAD_MOTORS_H_
  24:../Libraries/AQ_Motors/Motors.h **** 
  25:../Libraries/AQ_Motors/Motors.h **** #include "Arduino.h"
  26:../Libraries/AQ_Motors/Motors.h **** 
  27:../Libraries/AQ_Motors/Motors.h **** #define MOTOR1 0
  28:../Libraries/AQ_Motors/Motors.h **** #define MOTOR2 1
  29:../Libraries/AQ_Motors/Motors.h **** #define MOTOR3 2
  30:../Libraries/AQ_Motors/Motors.h **** #define MOTOR4 3
  31:../Libraries/AQ_Motors/Motors.h **** #define MOTOR5 4
  32:../Libraries/AQ_Motors/Motors.h **** #define MOTOR6 5
  33:../Libraries/AQ_Motors/Motors.h **** #define MOTOR7 6
  34:../Libraries/AQ_Motors/Motors.h **** #define MOTOR8 7
  35:../Libraries/AQ_Motors/Motors.h **** #define MINCOMMAND 1000
  36:../Libraries/AQ_Motors/Motors.h **** #define MAXCOMMAND 2000
  37:../Libraries/AQ_Motors/Motors.h **** 
  38:../Libraries/AQ_Motors/Motors.h **** enum NB_Motors{
  39:../Libraries/AQ_Motors/Motors.h ****   FOUR_Motors = 4,
  40:../Libraries/AQ_Motors/Motors.h ****   SIX_Motors = 6,
  41:../Libraries/AQ_Motors/Motors.h ****   EIGHT_Motors = 8
  42:../Libraries/AQ_Motors/Motors.h **** };
  43:../Libraries/AQ_Motors/Motors.h **** 
  44:../Libraries/AQ_Motors/Motors.h **** NB_Motors numberOfMotors = FOUR_Motors;
  45:../Libraries/AQ_Motors/Motors.h **** int motorCommand[8] = {0,0,0,0,0,0,0,0};  // LASTMOTOR not know here, so, default at 8 @todo : Kenn
  46:../Libraries/AQ_Motors/Motors.h ****   
  47:../Libraries/AQ_Motors/Motors.h **** void initializeMotors(NB_Motors numbers = FOUR_Motors);
  48:../Libraries/AQ_Motors/Motors.h **** void writeMotors();
  49:../Libraries/AQ_Motors/Motors.h **** void commandAllMotors(int command);
  50:../Libraries/AQ_Motors/Motors.h **** 
  51:../Libraries/AQ_Motors/Motors.h **** void pulseMotors(byte nbPulse) {
 4408              		.loc 20 51 0
 4409              		.cfi_startproc
 4410              		@ args = 0, pretend = 0, frame = 0
 4411              		@ frame_needed = 0, uses_anonymous_args = 0
 4412              	.LVL229:
 4413 0000 38B5     		push	{r3, r4, r5, lr}
 4414              	.LCFI42:
 4415              		.cfi_def_cfa_offset 16
 4416              		.cfi_offset 14, -4
 4417              		.cfi_offset 5, -8
 4418              		.cfi_offset 4, -12
 4419              		.cfi_offset 3, -16
 4420              		.loc 20 51 0
 4421 0002 0546     		mov	r5, r0
 4422              	.LBB124:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4423              		.loc 20 52 0
 4424 0004 0024     		movs	r4, #0
 4425 0006 0FE0     		b	.L246
 4426              	.LVL230:
 4427              	.L247:
  53:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND + 100);
 4428              		.loc 20 53 0 discriminator 2
 4429 0008 40F24C40 		movw	r0, #1100
 4430 000c FFF7FEFF 		bl	_Z16commandAllMotorsi
  54:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4431              		.loc 20 54 0 discriminator 2
 4432 0010 FA20     		movs	r0, #250
 4433 0012 FFF7FEFF 		bl	_Z5delaym
  55:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND);
 4434              		.loc 20 55 0 discriminator 2
 4435 0016 4FF47A70 		mov	r0, #1000
 4436 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
  56:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 4437              		.loc 20 56 0 discriminator 2
 4438 001e FA20     		movs	r0, #250
 4439 0020 FFF7FEFF 		bl	_Z5delaym
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4440              		.loc 20 52 0 discriminator 2
 4441 0024 0134     		adds	r4, r4, #1
 4442              	.LVL231:
 4443 0026 E4B2     		uxtb	r4, r4
 4444              	.LVL232:
 4445              	.L246:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 4446              		.loc 20 52 0 is_stmt 0 discriminator 1
 4447 0028 AC42     		cmp	r4, r5
 4448 002a EDD1     		bne	.L247
 4449              	.LBE124:
  57:../Libraries/AQ_Motors/Motors.h ****   }
  58:../Libraries/AQ_Motors/Motors.h **** }
 4450              		.loc 20 58 0 is_stmt 1
 4451 002c 38BD     		pop	{r3, r4, r5, pc}
 4452              		.cfi_endproc
 4453              	.LFE187:
 4455              		.section	.text._Z15getBaroAltitudev,"ax",%progbits
 4456              		.align	1
 4457              		.global	_Z15getBaroAltitudev
 4458              		.thumb
 4459              		.thumb_func
 4461              	_Z15getBaroAltitudev:
 4462              	.LFB191:
 4463              		.file 21 "../Libraries/AQ_BarometricSensor/BarometricSensor.h"
   1:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** /*
   2:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****  
   7:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   (at your option) any later version. 
  11:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  12:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  17:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** */
  20:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  21:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #ifndef _AQ_BAROMETRIC_SENSOR_
  22:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #define _AQ_BAROMETRIC_SENSOR_
  23:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  24:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #include "Arduino.h"
  25:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** #include "GlobalDefined.h"
  26:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 
  27:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroAltitude      = 0.0; 
  28:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroRawAltitude   = 0.0;
  29:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroGroundAltitude = 0.0;
  30:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** float baroSmoothFactor   = 0.02;
  31:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   
  32:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // **********************************************************************
  33:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // The following function calls must be defined inside any new subclasses
  34:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // **********************************************************************
  35:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void initializeBaro(); 
  36:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureBaro();
  37:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureBaroSum();
  38:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void evaluateBaroAltitude();
  39:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   
  40:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // *********************************************************
  41:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // The following functions are common between all subclasses
  42:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** // *********************************************************
  43:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** const float getBaroAltitude() {
 4464              		.loc 21 43 0
 4465              		.cfi_startproc
 4466              		@ args = 0, pretend = 0, frame = 0
 4467              		@ frame_needed = 0, uses_anonymous_args = 0
 4468              		@ link register save eliminated.
  44:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   return baroAltitude - baroGroundAltitude;
 4469              		.loc 21 44 0
 4470 0000 0548     		ldr	r0, .L249
 4471 0002 064B     		ldr	r3, .L249+4
 4472 0004 90ED007A 		flds	s14, [r0, #0]
 4473 0008 93ED000A 		flds	s0, [r3, #0]
  45:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** }
 4474              		.loc 21 45 0
 4475 000c 77EE407A 		fsubs	s15, s14, s0
 4476 0010 17EE900A 		fmrs	r0, s15
 4477 0014 7047     		bx	lr
 4478              	.L250:
 4479 0016 00BF     		.align	2
 4480              	.L249:
 4481 0018 00000000 		.word	.LANCHOR59
 4482 001c 00000000 		.word	.LANCHOR60
 4483              		.cfi_endproc
 4484              	.LFE191:
 4486              		.section	.text._Z10MS5611crc4Pt,"ax",%progbits
 4487              		.align	1
 4488              		.global	_Z10MS5611crc4Pt
 4489              		.thumb
 4490              		.thumb_func
 4492              	_Z10MS5611crc4Pt:
 4493              	.LFB193:
 4494              		.file 22 "../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h"
   1:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** /*
   2:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   www.AeroQuad.com
   4:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
   7:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   (at your option) any later version.
  11:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  12:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  17:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** */
  20:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  21:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // parts of this code were taken from AN520, an early version of fabio's library and the AQ BMP085 
  22:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  23:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #ifndef _AQ_BAROMETRIC_SENSOR_MS5611_
  24:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define _AQ_BAROMETRIC_SENSOR_MS5611_
  25:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  26:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include "BarometricSensor.h"
  27:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include "Device_I2C.h"
  28:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #include <AQMath.h>
  29:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  30:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  31:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** //#define DEBUG_MS5611
  32:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS5611_I2C_ADDRESS         0x76
  33:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  34:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_PROM_BASE_ADDR  0xA0
  35:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_PROM_REG_COUNT  8     // number of registers in the PROM
  36:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D1_Pressure     0x40
  37:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D2_Temperature  0x50
  38:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_RESET           0x1E
  39:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  40:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // D1 and D2 result size (bytes)
  41:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_D1D2_SIZE       3
  42:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  43:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // OSR (Over Sampling Ratio) constants
  44:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_256         0x00
  45:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_512         0x02
  46:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_1024        0x04
  47:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_2048        0x06
  48:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** #define MS561101BA_OSR_4096        0x08
  49:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  50:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned short MS5611Prom[MS561101BA_PROM_REG_COUNT];
  51:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  52:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long MS5611lastRawTemperature;
  53:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long MS5611lastRawPressure;
  54:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int64_t MS5611_sens=0;
  55:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int64_t MS5611_offset=0;
  56:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  57:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** // taken from AN520
  58:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned char MS5611crc4(unsigned short n_prom[])
  59:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4495              		.loc 22 59 0
 4496              		.cfi_startproc
 4497              		@ args = 0, pretend = 0, frame = 0
 4498              		@ frame_needed = 0, uses_anonymous_args = 0
 4499              	.LVL233:
 4500 0000 30B5     		push	{r4, r5, lr}
 4501              	.LCFI43:
 4502              		.cfi_def_cfa_offset 12
 4503              		.cfi_offset 14, -4
 4504              		.cfi_offset 5, -8
 4505              		.cfi_offset 4, -12
 4506              	.LBB125:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
  61:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short crc_read;            	// original value of the crc
  62:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  63:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	crc_read  = n_prom[7];               	//save read CRC
 4507              		.loc 22 63 0
 4508 0002 C489     		ldrh	r4, [r0, #14]
 4509              	.LVL234:
  64:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = (0xFF00 & (n_prom[7])); 	//CRC byte is replaced by 0
  65:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  66:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int cnt = 0; cnt < 16; cnt++) {   	// operation is performed on bytes
 4510              		.loc 22 66 0
 4511 0004 0022     		movs	r2, #0
  64:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = (0xFF00 & (n_prom[7])); 	//CRC byte is replaced by 0
 4512              		.loc 22 64 0
 4513 0006 24F0FF03 		bic	r3, r4, #255
 4514 000a C381     		strh	r3, [r0, #14]	@ movhi
 4515              	.LVL235:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
 4516              		.loc 22 60 0
 4517 000c 1346     		mov	r3, r2
 4518              	.LVL236:
 4519              	.L257:
 4520 000e 4FEA6201 		asr	r1, r2, #1
 4521              	.LBB126:
 4522              	.LBB127:
  67:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	    // choose LSB or MSB
  68:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if (cnt%2 == 1) {
 4523              		.loc 22 68 0
 4524 0012 12F0010F 		tst	r2, #1
  69:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= (n_prom[cnt>>1]) & 0x00FF;
 4525              		.loc 22 69 0
 4526 0016 15BF     		itete	ne
 4527 0018 10F81110 		ldrbne	r1, [r0, r1, lsl #1]	@ zero_extendqisi2
  70:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		} 
  71:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		else {
  72:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= n_prom[cnt>>1] >> 8;
 4528              		.loc 22 72 0
 4529 001c 30F81110 		ldrheq	r1, [r0, r1, lsl #1]
  69:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			n_rem ^= (n_prom[cnt>>1]) & 0x00FF;
 4530              		.loc 22 69 0
 4531 0020 4B40     		eorne	r3, r1, r3
 4532              	.LVL237:
 4533              		.loc 22 72 0
 4534 0022 83EA1123 		eoreq	r3, r3, r1, lsr #8
 4535              	.LVL238:
 4536              	.LBE127:
 4537              	.LBE126:
  60:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	unsigned short n_rem = 0;               // crc reminder
 4538              		.loc 22 60 0
 4539 0026 0821     		movs	r1, #8
 4540              	.LVL239:
 4541              	.L256:
 4542              	.LBB130:
 4543              	.LBB129:
 4544              	.LBB128:
  73:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
  74:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  75:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		for (int n_bit = 8; n_bit > 0; n_bit--) {
  76:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			if (n_rem & (0x8000)) {
 4545              		.loc 22 76 0
 4546 0028 13F4004F 		tst	r3, #32768
 4547 002c 4FEA4303 		lsl	r3, r3, #1
  77:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 				n_rem = (n_rem << 1) ^ 0x3000;
 4548              		.loc 22 77 0
 4549 0030 1DBF     		ittte	ne
 4550 0032 83F44055 		eorne	r5, r3, #12288
 4551 0036 4FF6FE73 		movwne	r3, #65534
 4552 003a 2B40     		andne	r3, r5, r3
 4553              	.LVL240:
  78:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			} 
  79:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			else {
  80:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 				n_rem = (n_rem << 1);
 4554              		.loc 22 80 0
 4555 003c 9BB2     		uxtheq	r3, r3
 4556              	.LVL241:
  75:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		for (int n_bit = 8; n_bit > 0; n_bit--) {
 4557              		.loc 22 75 0
 4558 003e 0139     		subs	r1, r1, #1
 4559 0040 F2D1     		bne	.L256
 4560              	.LBE128:
 4561              	.LBE129:
  66:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int cnt = 0; cnt < 16; cnt++) {   	// operation is performed on bytes
 4562              		.loc 22 66 0
 4563 0042 0132     		adds	r2, r2, #1
 4564              	.LVL242:
 4565 0044 102A     		cmp	r2, #16
 4566 0046 E2D1     		bne	.L257
 4567              	.LVL243:
 4568              	.LBE130:
  81:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			}
  82:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
  83:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
  84:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  85:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_rem = (n_rem >> 12) & 0xF; // // final 4-bit reminder is CRC code
  86:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  87:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	n_prom[7] = crc_read; // restore the crc_read to its original place
 4569              		.loc 22 87 0
 4570 0048 C481     		strh	r4, [r0, #14]	@ movhi
 4571              	.LBE125:
  88:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  89:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	return (n_rem);
  90:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4572              		.loc 22 90 0
 4573 004a 180B     		lsrs	r0, r3, #12
 4574              	.LVL244:
 4575 004c 30BD     		pop	{r4, r5, pc}
 4576              		.cfi_endproc
 4577              	.LFE193:
 4579              		.section	.text._Z14MS5611readPROMi,"ax",%progbits
 4580              		.align	1
 4581              		.global	_Z14MS5611readPROMi
 4582              		.thumb
 4583              		.thumb_func
 4585              	_Z14MS5611readPROMi:
 4586              	.LFB194:
  91:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
  92:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** int MS5611readPROM(int addr)
  93:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4587              		.loc 22 93 0
 4588              		.cfi_startproc
 4589              		@ args = 0, pretend = 0, frame = 0
 4590              		@ frame_needed = 0, uses_anonymous_args = 0
 4591              	.LVL245:
 4592 0000 70B5     		push	{r4, r5, r6, lr}
 4593              	.LCFI44:
 4594              		.cfi_def_cfa_offset 16
 4595              		.cfi_offset 14, -4
 4596              		.cfi_offset 6, -8
 4597              		.cfi_offset 5, -12
 4598              		.cfi_offset 4, -16
 4599              	.LBB131:
 4600              	.LBB132:
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		sendByteI2C(addr, MS561101BA_PROM_BASE_ADDR + 2*i);
  96:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if(Wire.requestFrom(addr, 2) == 2) {
  97:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
  98:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		} 
  99:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		else {
 100:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			return 0;
 4601              		.loc 22 100 0
 4602 0002 124D     		ldr	r5, .L265
 4603              	.LBE132:
 4604              	.LBE131:
  93:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4605              		.loc 22 93 0
 4606 0004 0646     		mov	r6, r0
 4607 0006 A024     		movs	r4, #160
 4608              	.LVL246:
 4609              	.L262:
 4610              	.LBB135:
 4611              	.LBB133:
  95:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		sendByteI2C(addr, MS561101BA_PROM_BASE_ADDR + 2*i);
 4612              		.loc 22 95 0
 4613 0008 3046     		mov	r0, r6
 4614 000a 2146     		mov	r1, r4
 4615 000c FFF7FEFF 		bl	_Z11sendByteI2Cih
  96:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		if(Wire.requestFrom(addr, 2) == 2) {
 4616              		.loc 22 96 0
 4617 0010 0222     		movs	r2, #2
 4618 0012 0F48     		ldr	r0, .L265+4
 4619 0014 3146     		mov	r1, r6
 4620 0016 FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 4621 001a 0228     		cmp	r0, #2
 4622 001c 13D1     		bne	.L263
  97:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
 4623              		.loc 22 97 0
 4624 001e FFF7FEFF 		bl	_Z11readWordI2Cv
 4625 0022 0234     		adds	r4, r4, #2
 4626 0024 E4B2     		uxtb	r4, r4
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
 4627              		.loc 22 94 0
 4628 0026 B02C     		cmp	r4, #176
  97:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			MS5611Prom[i] = readWordI2C();
 4629              		.loc 22 97 0
 4630 0028 25F8020F 		strh	r0, [r5, #2]!	@ movhi
  94:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	for (int i=0;i<MS561101BA_PROM_REG_COUNT; i++) {
 4631              		.loc 22 94 0
 4632 002c ECD1     		bne	.L262
 4633              	.LBE133:
 101:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		}
 102:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 103:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 104:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	int crc     = MS5611crc4(MS5611Prom);
 4634              		.loc 22 104 0
 4635 002e 094C     		ldr	r4, .L265+8
 4636 0030 2046     		mov	r0, r4
 4637 0032 FFF7FEFF 		bl	_Z10MS5611crc4Pt
 4638              	.LVL247:
 105:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	int crcProm = MS5611Prom[7] & 0xf;
 4639              		.loc 22 105 0
 4640 0036 E189     		ldrh	r1, [r4, #14]
 4641 0038 01F00F03 		and	r3, r1, #15
 100:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 			return 0;
 4642              		.loc 22 100 0
 4643 003c C21A     		subs	r2, r0, r3
 4644 003e 5042     		rsbs	r0, r2, #0
 4645              	.LVL248:
 4646 0040 40EB0200 		adc	r0, r0, r2
 4647 0044 70BD     		pop	{r4, r5, r6, pc}
 4648              	.LVL249:
 4649              	.L263:
 4650              	.LBB134:
 4651 0046 0020     		movs	r0, #0
 4652              	.LBE134:
 4653              	.LBE135:
 106:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 107:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	if(crc == crcProm) {
 108:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 		return 1;
 109:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 110:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	return 0;
 111:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4654              		.loc 22 111 0
 4655 0048 70BD     		pop	{r4, r5, r6, pc}
 4656              	.L266:
 4657 004a 00BF     		.align	2
 4658              	.L265:
 4659 004c FEFFFFFF 		.word	.LANCHOR61-2
 4660 0050 00000000 		.word	Wire
 4661 0054 00000000 		.word	.LANCHOR61
 4662              		.cfi_endproc
 4663              	.LFE194:
 4665              		.section	.text._Z11MS5611reseti,"ax",%progbits
 4666              		.align	1
 4667              		.global	_Z11MS5611reseti
 4668              		.thumb
 4669              		.thumb_func
 4671              	_Z11MS5611reseti:
 4672              	.LFB195:
 112:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 113:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void MS5611reset(int addr) {
 4673              		.loc 22 113 0
 4674              		.cfi_startproc
 4675              		@ args = 0, pretend = 0, frame = 0
 4676              		@ frame_needed = 0, uses_anonymous_args = 0
 4677              		@ link register save eliminated.
 4678              	.LVL250:
 114:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	sendByteI2C(addr, MS561101BA_RESET);
 4679              		.loc 22 114 0
 4680 0000 1E21     		movs	r1, #30
 115:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4681              		.loc 22 115 0
 114:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	sendByteI2C(addr, MS561101BA_RESET);
 4682              		.loc 22 114 0
 4683 0002 FFF7FEBF 		b	_Z11sendByteI2Cih
 4684              	.LVL251:
 4685              		.cfi_endproc
 4686              	.LFE195:
 4688              		.section	.text._Z20MS5611readConversioni,"ax",%progbits
 4689              		.align	1
 4690              		.global	_Z20MS5611readConversioni
 4691              		.thumb
 4692              		.thumb_func
 4694              	_Z20MS5611readConversioni:
 4695              	.LFB196:
 116:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 117:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 118:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 119:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float pressure			 = 0;
 120:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long rawPressure         = 0;
 121:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** long rawTemperature      = 0;
 122:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** byte pressureCount       = 0;
 123:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float pressureFactor     = 1/5.255;
 124:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** boolean isReadPressure   = false;
 125:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float rawPressureSum     = 0;
 126:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** byte rawPressureSumCount = 0;
 127:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 128:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long MS5611readConversion(int addr) {
 4696              		.loc 22 128 0
 4697              		.cfi_startproc
 4698              		@ args = 0, pretend = 0, frame = 0
 4699              		@ frame_needed = 0, uses_anonymous_args = 0
 4700              	.LVL252:
 4701 0000 10B5     		push	{r4, lr}
 4702              	.LCFI45:
 4703              		.cfi_def_cfa_offset 8
 4704              		.cfi_offset 14, -4
 4705              		.cfi_offset 4, -8
 4706              	.LBB136:
 129:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   unsigned long conversion = 0;
 130:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 131:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // start read sequence
 132:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(addr, 0);
 4707              		.loc 22 132 0
 4708 0002 0021     		movs	r1, #0
 4709              	.LBE136:
 128:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long MS5611readConversion(int addr) {
 4710              		.loc 22 128 0
 4711 0004 0446     		mov	r4, r0
 4712              	.LBB137:
 4713              		.loc 22 132 0
 4714 0006 FFF7FEFF 		bl	_Z11sendByteI2Cih
 4715              	.LVL253:
 133:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   Wire.requestFrom(addr, MS561101BA_D1D2_SIZE);
 4716              		.loc 22 133 0
 4717 000a 0322     		movs	r2, #3
 4718 000c 2146     		mov	r1, r4
 4719 000e 0B48     		ldr	r0, .L271
 4720 0010 FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 134:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(Wire.available() == MS561101BA_D1D2_SIZE) {
 4721              		.loc 22 134 0
 4722 0014 0948     		ldr	r0, .L271
 4723 0016 FFF7FEFF 		bl	_ZN7TwoWire9availableEv
 4724 001a 0328     		cmp	r0, #3
 4725 001c 0BD1     		bne	.L270
 135:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     conversion = (readByteI2C() << 16) | (readByteI2C() << 8) | (readByteI2C() << 0);
 4726              		.loc 22 135 0
 4727 001e FFF7FEFF 		bl	_Z11readByteI2Cv
 4728 0022 0446     		mov	r4, r0
 4729              	.LVL254:
 4730 0024 FFF7FEFF 		bl	_Z11readByteI2Cv
 4731 0028 0002     		lsls	r0, r0, #8
 4732 002a 40EA0444 		orr	r4, r0, r4, lsl #16
 4733 002e FFF7FEFF 		bl	_Z11readByteI2Cv
 4734 0032 2043     		orrs	r0, r0, r4
 4735              	.LVL255:
 4736 0034 10BD     		pop	{r4, pc}
 4737              	.LVL256:
 4738              	.L270:
 136:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } 
 137:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   else {
 138:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     conversion = 0;
 4739              		.loc 22 138 0
 4740 0036 0020     		movs	r0, #0
 4741              	.LVL257:
 4742              	.LBE137:
 139:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 140:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 141:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return conversion;
 142:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4743              		.loc 22 142 0
 4744 0038 10BD     		pop	{r4, pc}
 4745              	.L272:
 4746 003a 00BF     		.align	2
 4747              	.L271:
 4748 003c 00000000 		.word	Wire
 4749              		.cfi_endproc
 4750              	.LFE196:
 4752              		.section	.text._Z21requestRawTemperaturev,"ax",%progbits
 4753              		.align	1
 4754              		.global	_Z21requestRawTemperaturev
 4755              		.thumb
 4756              		.thumb_func
 4758              	_Z21requestRawTemperaturev:
 4759              	.LFB197:
 143:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 144:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 145:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void requestRawTemperature() {
 4760              		.loc 22 145 0
 4761              		.cfi_startproc
 4762              		@ args = 0, pretend = 0, frame = 0
 4763              		@ frame_needed = 0, uses_anonymous_args = 0
 4764              		@ link register save eliminated.
 146:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D2_Temperature + MS561101BA_OSR_4096);
 4765              		.loc 22 146 0
 4766 0000 7620     		movs	r0, #118
 4767 0002 5821     		movs	r1, #88
 147:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4768              		.loc 22 147 0
 146:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D2_Temperature + MS561101BA_OSR_4096);
 4769              		.loc 22 146 0
 4770 0004 FFF7FEBF 		b	_Z11sendByteI2Cih
 4771              		.cfi_endproc
 4772              	.LFE197:
 4774              		.section	.text._Z18readRawTemperaturev,"ax",%progbits
 4775              		.align	1
 4776              		.global	_Z18readRawTemperaturev
 4777              		.thumb
 4778              		.thumb_func
 4780              	_Z18readRawTemperaturev:
 4781              	.LFB198:
 148:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 149:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 150:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long readRawTemperature()
 151:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4782              		.loc 22 151 0
 4783              		.cfi_startproc
 4784              		@ args = 0, pretend = 0, frame = 0
 4785              		@ frame_needed = 0, uses_anonymous_args = 0
 4786 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 4787              	.LCFI46:
 4788              		.cfi_def_cfa_offset 32
 4789              		.cfi_offset 14, -4
 4790              		.cfi_offset 9, -8
 4791              		.cfi_offset 8, -12
 4792              		.cfi_offset 7, -16
 4793              		.cfi_offset 6, -20
 4794              		.cfi_offset 5, -24
 4795              		.cfi_offset 4, -28
 4796              		.cfi_offset 3, -32
 4797              	.LBB138:
 152:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // see datasheet page 7 for formulas
 153:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 4798              		.loc 22 153 0
 4799 0004 7620     		movs	r0, #118
 4800 0006 FFF7FEFF 		bl	_Z20MS5611readConversioni
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 4801              		.loc 22 154 0
 4802 000a 1849     		ldr	r1, .L275
 153:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 4803              		.loc 22 153 0
 4804 000c 184A     		ldr	r2, .L275+4
 155:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611_offset  = (((int64_t)MS5611Prom[2]) << 16) + ((MS5611Prom[4] * dT) >> 7);
 4805              		.loc 22 155 0
 4806 000e 8B88     		ldrh	r3, [r1, #4]
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 4807              		.loc 22 154 0
 4808 0010 4C89     		ldrh	r4, [r1, #10]
 153:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawTemperature = MS5611readConversion(MS5611_I2C_ADDRESS);
 4809              		.loc 22 153 0
 4810 0012 1060     		str	r0, [r2, #0]
 4811              		.loc 22 155 0
 4812 0014 4FEA0348 		lsl	r8, r3, #16
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 4813              		.loc 22 154 0
 4814 0018 2402     		lsls	r4, r4, #8
 4815              		.loc 22 155 0
 4816 001a 0B89     		ldrh	r3, [r1, #8]
 4817 001c 154D     		ldr	r5, .L275+8
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 4818              		.loc 22 154 0
 4819 001e 041B     		subs	r4, r0, r4
 4820              		.loc 22 155 0
 4821 0020 A3FB0467 		umull	r6, r7, r3, r4
 154:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   int64_t dT     = MS5611lastRawTemperature - (((long)MS5611Prom[5]) << 8);
 4822              		.loc 22 154 0
 4823 0024 4FEAE47C 		asr	ip, r4, #31
 4824              	.LVL258:
 4825              		.loc 22 155 0
 4826 0028 03FB0C77 		mla	r7, r3, ip, r7
 4827 002c F209     		lsrs	r2, r6, #7
 4828 002e 42EA4762 		orr	r2, r2, r7, lsl #25
 4829 0032 FB11     		asrs	r3, r7, #7
 4830 0034 4FF00009 		mov	r9, #0
 4831 0038 12EB0802 		adds	r2, r2, r8
 4832 003c 43EB0903 		adc	r3, r3, r9
 4833 0040 C5E90023 		strd	r2, [r5]
 156:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611_sens    = (((int64_t)MS5611Prom[1]) << 15) + ((MS5611Prom[3] * dT) >> 8);
 4834              		.loc 22 156 0
 4835 0044 4B88     		ldrh	r3, [r1, #2]
 4836 0046 DE03     		lsls	r6, r3, #15
 4837 0048 CB88     		ldrh	r3, [r1, #6]
 4838 004a 0B49     		ldr	r1, .L275+12
 4839 004c A3FB0445 		umull	r4, r5, r3, r4
 4840              	.LVL259:
 4841 0050 03FB0C55 		mla	r5, r3, ip, r5
 4842 0054 220A     		lsrs	r2, r4, #8
 4843 0056 42EA0562 		orr	r2, r2, r5, lsl #24
 4844 005a 0027     		movs	r7, #0
 4845 005c 2B12     		asrs	r3, r5, #8
 4846 005e 9219     		adds	r2, r2, r6
 4847 0060 43EB0703 		adc	r3, r3, r7
 4848 0064 C1E90023 		strd	r2, [r1]
 4849              	.LBE138:
 157:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 158:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return MS5611lastRawTemperature;
 159:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4850              		.loc 22 159 0
 4851 0068 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 4852              	.L276:
 4853              		.align	2
 4854              	.L275:
 4855 006c 00000000 		.word	.LANCHOR61
 4856 0070 00000000 		.word	.LANCHOR62
 4857 0074 00000000 		.word	.LANCHOR63
 4858 0078 00000000 		.word	.LANCHOR64
 4859              		.cfi_endproc
 4860              	.LFE198:
 4862              		.global	__aeabi_l2f
 4863              		.section	.text._Z15readTemperaturev,"ax",%progbits
 4864              		.align	1
 4865              		.global	_Z15readTemperaturev
 4866              		.thumb
 4867              		.thumb_func
 4869              	_Z15readTemperaturev:
 4870              	.LFB199:
 160:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 161:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 162:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float readTemperature()
 163:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4871              		.loc 22 163 0
 4872              		.cfi_startproc
 4873              		@ args = 0, pretend = 0, frame = 0
 4874              		@ frame_needed = 0, uses_anonymous_args = 0
 4875 0000 38B5     		push	{r3, r4, r5, lr}
 4876              	.LCFI47:
 4877              		.cfi_def_cfa_offset 16
 4878              		.cfi_offset 14, -4
 4879              		.cfi_offset 5, -8
 4880              		.cfi_offset 4, -12
 4881              		.cfi_offset 3, -16
 164:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return ((1<<5)*2000 + (((MS5611lastRawTemperature - ((int64_t)MS5611Prom[5] << 8)) * MS5611Prom[6
 4882              		.loc 22 164 0
 4883 0002 124D     		ldr	r5, .L278
 4884 0004 124B     		ldr	r3, .L278+4
 4885 0006 6C89     		ldrh	r4, [r5, #10]
 4886 0008 1968     		ldr	r1, [r3, #0]
 4887 000a 2002     		lsls	r0, r4, #8
 4888 000c CB17     		asrs	r3, r1, #31
 4889 000e AC89     		ldrh	r4, [r5, #12]
 4890 0010 0A46     		mov	r2, r1
 4891 0012 0021     		movs	r1, #0
 4892 0014 121A     		subs	r2, r2, r0
 4893 0016 63EB0103 		sbc	r3, r3, r1
 4894 001a A2FB0401 		umull	r0, r1, r2, r4
 4895 001e 04FB0311 		mla	r1, r4, r3, r1
 4896 0022 820C     		lsrs	r2, r0, #18
 4897 0024 42EA8132 		orr	r2, r2, r1, lsl #14
 4898 0028 4FF47A40 		mov	r0, #64000
 4899 002c 8B14     		asrs	r3, r1, #18
 4900 002e 0021     		movs	r1, #0
 4901 0030 8018     		adds	r0, r0, r2
 4902 0032 41EB0301 		adc	r1, r1, r3
 4903 0036 FFF7FEFF 		bl	__aeabi_l2f
 165:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4904              		.loc 22 165 0
 4905 003a DFED067A 		flds	s15, .L278+8
 4906 003e 06EE900A 		fmsr	s13, r0
 4907 0042 C6EEA76A 		fdivs	s13, s13, s15
 4908 0046 16EE900A 		fmrs	r0, s13
 4909 004a 38BD     		pop	{r3, r4, r5, pc}
 4910              	.L279:
 4911              		.align	2
 4912              	.L278:
 4913 004c 00000000 		.word	.LANCHOR61
 4914 0050 00000000 		.word	.LANCHOR62
 4915 0054 00004845 		.word	1162346496
 4916              		.cfi_endproc
 4917              	.LFE199:
 4919              		.section	.text._Z18requestRawPressurev,"ax",%progbits
 4920              		.align	1
 4921              		.global	_Z18requestRawPressurev
 4922              		.thumb
 4923              		.thumb_func
 4925              	_Z18requestRawPressurev:
 4926              	.LFB200:
 166:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 167:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void requestRawPressure()
 168:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4927              		.loc 22 168 0
 4928              		.cfi_startproc
 4929              		@ args = 0, pretend = 0, frame = 0
 4930              		@ frame_needed = 0, uses_anonymous_args = 0
 4931              		@ link register save eliminated.
 169:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D1_Pressure + MS561101BA_OSR_4096);
 4932              		.loc 22 169 0
 4933 0000 7620     		movs	r0, #118
 4934 0002 4821     		movs	r1, #72
 170:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4935              		.loc 22 170 0
 169:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   sendByteI2C(MS5611_I2C_ADDRESS, MS561101BA_D1_Pressure + MS561101BA_OSR_4096);
 4936              		.loc 22 169 0
 4937 0004 FFF7FEBF 		b	_Z11sendByteI2Cih
 4938              		.cfi_endproc
 4939              	.LFE200:
 4941              		.section	.text._Z15readRawPressurev,"ax",%progbits
 4942              		.align	1
 4943              		.global	_Z15readRawPressurev
 4944              		.thumb
 4945              		.thumb_func
 4947              	_Z15readRawPressurev:
 4948              	.LFB201:
 171:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 172:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** float readRawPressure()
 173:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** {
 4949              		.loc 22 173 0
 4950              		.cfi_startproc
 4951              		@ args = 0, pretend = 0, frame = 0
 4952              		@ frame_needed = 0, uses_anonymous_args = 0
 4953 0000 38B5     		push	{r3, r4, r5, lr}
 4954              	.LCFI48:
 4955              		.cfi_def_cfa_offset 16
 4956              		.cfi_offset 14, -4
 4957              		.cfi_offset 5, -8
 4958              		.cfi_offset 4, -12
 4959              		.cfi_offset 3, -16
 174:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawPressure = MS5611readConversion(MS5611_I2C_ADDRESS);
 4960              		.loc 22 174 0
 4961 0002 7620     		movs	r0, #118
 4962 0004 FFF7FEFF 		bl	_Z20MS5611readConversioni
 4963 0008 124B     		ldr	r3, .L282
 175:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 176:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   return (((( MS5611lastRawPressure * MS5611_sens) >> 21) - MS5611_offset) >> (15-5)) / ((float)(1<
 4964              		.loc 22 176 0
 4965 000a 1349     		ldr	r1, .L282+4
 174:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611lastRawPressure = MS5611readConversion(MS5611_I2C_ADDRESS);
 4966              		.loc 22 174 0
 4967 000c 1860     		str	r0, [r3, #0]
 4968              		.loc 22 176 0
 4969 000e 0B68     		ldr	r3, [r1, #0]
 4970 0010 4968     		ldr	r1, [r1, #4]
 4971 0012 C217     		asrs	r2, r0, #31
 4972 0014 4143     		muls	r1, r0, r1
 4973 0016 03FB0212 		mla	r2, r3, r2, r1
 4974 001a A3FB0001 		umull	r0, r1, r3, r0
 4975 001e 0F4B     		ldr	r3, .L282+8
 4976 0020 5118     		adds	r1, r2, r1
 4977 0022 D3E90023 		ldrd	r2, [r3]
 4978 0026 440D     		lsrs	r4, r0, #21
 4979 0028 44EAC124 		orr	r4, r4, r1, lsl #11
 4980 002c 4D15     		asrs	r5, r1, #21
 4981 002e A21A     		subs	r2, r4, r2
 4982 0030 65EB0303 		sbc	r3, r5, r3
 4983 0034 900A     		lsrs	r0, r2, #10
 4984 0036 40EA8350 		orr	r0, r0, r3, lsl #22
 4985 003a 9912     		asrs	r1, r3, #10
 4986 003c FFF7FEFF 		bl	__aeabi_l2f
 177:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 4987              		.loc 22 177 0
 4988 0040 DFED077A 		flds	s15, .L282+12
 4989 0044 06EE900A 		fmsr	s13, r0
 4990 0048 66EEA76A 		fmuls	s13, s13, s15
 4991 004c 16EE900A 		fmrs	r0, s13
 4992 0050 38BD     		pop	{r3, r4, r5, pc}
 4993              	.L283:
 4994 0052 00BF     		.align	2
 4995              	.L282:
 4996 0054 00000000 		.word	.LANCHOR65
 4997 0058 00000000 		.word	.LANCHOR64
 4998 005c 00000000 		.word	.LANCHOR63
 4999 0060 0000003D 		.word	1023410176
 5000              		.cfi_endproc
 5001              	.LFE201:
 5003              		.section	.text._Z14measureBaroSumv,"ax",%progbits
 5004              		.align	1
 5005              		.global	_Z14measureBaroSumv
 5006              		.thumb
 5007              		.thumb_func
 5009              	_Z14measureBaroSumv:
 5010              	.LFB204:
 178:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 179:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** bool baroGroundUpdateDone = false;
 180:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** unsigned long baroStartTime;
 181:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 182:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void initializeBaro() {
 183:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 184:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 185:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 186:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 187:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 188:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 189:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611reset(MS5611_I2C_ADDRESS); // reset the device to populate its internal PROM registers
 190:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(3); // some safety time
 191:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611readPROM(MS5611_I2C_ADDRESS) ) {
 193:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  vehicleState |= BARO_DETECTED;
 194:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 195:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   requestRawTemperature(); // setup up next measure() for temperature
 197:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 199:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 200:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum(); // read temperature
 201:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 202:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaro(); // read pressure
 203:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 204:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 205:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 207:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 208:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroAltitude = baroGroundAltitude;
 209:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 210:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 211:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaro() {
 212:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum();
 213:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   evaluateBaroAltitude();
 214:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 215:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 216:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaroSum() {
 5011              		.loc 22 216 0
 5012              		.cfi_startproc
 5013              		@ args = 0, pretend = 0, frame = 0
 5014              		@ frame_needed = 0, uses_anonymous_args = 0
 5015 0000 38B5     		push	{r3, r4, r5, lr}
 5016              	.LCFI49:
 5017              		.cfi_def_cfa_offset 16
 5018              		.cfi_offset 14, -4
 5019              		.cfi_offset 5, -8
 5020              		.cfi_offset 4, -12
 5021              		.cfi_offset 3, -16
 217:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // switch between pressure and temperature measurements
 218:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if (isReadPressure) {
 5022              		.loc 22 218 0
 5023 0002 164C     		ldr	r4, .L289
 5024 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 216:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaroSum() {
 5025              		.loc 22 216 0
 5026 0006 2DED028B 		fstmfdd	sp!, {d8}
 5027              	.LCFI50:
 5028              		.cfi_def_cfa_offset 24
 5029              		.cfi_offset 80, -24
 5030              		.loc 22 218 0
 5031 000a F3B1     		cbz	r3, .L285
 219:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSum += readRawPressure();
 5032              		.loc 22 219 0
 5033 000c 144D     		ldr	r5, .L289+4
 5034 000e 95ED008A 		flds	s16, [r5, #0]
 5035 0012 FFF7FEFF 		bl	_Z15readRawPressurev
 5036 0016 07EE900A 		fmsr	s15, r0
 220:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSumCount++;
 5037              		.loc 22 220 0
 5038 001a 1249     		ldr	r1, .L289+8
 219:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSum += readRawPressure();
 5039              		.loc 22 219 0
 5040 001c 38EE278A 		fadds	s16, s16, s15
 5041 0020 85ED008A 		fsts	s16, [r5, #0]
 5042              		.loc 22 220 0
 5043 0024 0D78     		ldrb	r5, [r1, #0]	@ zero_extendqisi2
 5044 0026 6A1C     		adds	r2, r5, #1
 221:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     if (pressureCount == 20) {
 5045              		.loc 22 221 0
 5046 0028 0F4D     		ldr	r5, .L289+12
 220:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     rawPressureSumCount++;
 5047              		.loc 22 220 0
 5048 002a 0A70     		strb	r2, [r1, #0]
 5049              		.loc 22 221 0
 5050 002c 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 5051 002e 1428     		cmp	r0, #20
 5052 0030 05D1     		bne	.L286
 222:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       requestRawTemperature();
 5053              		.loc 22 222 0
 5054 0032 FFF7FEFF 		bl	_Z21requestRawTemperaturev
 223:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       pressureCount = 0;
 5055              		.loc 22 223 0
 5056 0036 0023     		movs	r3, #0
 5057 0038 2B70     		strb	r3, [r5, #0]
 224:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       isReadPressure = false;
 5058              		.loc 22 224 0
 5059 003a 2370     		strb	r3, [r4, #0]
 5060 003c 01E0     		b	.L287
 5061              	.L286:
 225:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     } 
 226:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	else {
 227:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****       requestRawPressure();
 5062              		.loc 22 227 0
 5063 003e FFF7FEFF 		bl	_Z18requestRawPressurev
 5064              	.L287:
 228:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	}
 229:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     pressureCount++;
 5065              		.loc 22 229 0
 5066 0042 2A78     		ldrb	r2, [r5, #0]	@ zero_extendqisi2
 5067 0044 501C     		adds	r0, r2, #1
 5068 0046 2870     		strb	r0, [r5, #0]
 5069 0048 05E0     		b	.L284
 5070              	.L285:
 230:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } 
 231:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   else { // select must equal TEMPERATURE
 232:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     readRawTemperature();
 5071              		.loc 22 232 0
 5072 004a FFF7FEFF 		bl	_Z18readRawTemperaturev
 233:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     requestRawPressure();
 5073              		.loc 22 233 0
 5074 004e FFF7FEFF 		bl	_Z18requestRawPressurev
 234:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     isReadPressure = true;
 5075              		.loc 22 234 0
 5076 0052 0121     		movs	r1, #1
 5077 0054 2170     		strb	r1, [r4, #0]
 5078              	.L284:
 235:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 236:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5079              		.loc 22 236 0
 5080 0056 BDEC028B 		fldmfdd	sp!, {d8}
 5081 005a 38BD     		pop	{r3, r4, r5, pc}
 5082              	.L290:
 5083              		.align	2
 5084              	.L289:
 5085 005c 00000000 		.word	.LANCHOR66
 5086 0060 00000000 		.word	.LANCHOR67
 5087 0064 00000000 		.word	.LANCHOR68
 5088 0068 00000000 		.word	.LANCHOR69
 5089              		.cfi_endproc
 5090              	.LFE204:
 5092              		.global	__aeabi_dsub
 5093              		.global	__aeabi_dmul
 5094              		.section	.text._Z20evaluateBaroAltitudev,"ax",%progbits
 5095              		.align	1
 5096              		.global	_Z20evaluateBaroAltitudev
 5097              		.thumb
 5098              		.thumb_func
 5100              	_Z20evaluateBaroAltitudev:
 5101              	.LFB205:
 237:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 238:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** bool MS5611_first_read = true;
 239:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 240:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void evaluateBaroAltitude() {
 5102              		.loc 22 240 0
 5103              		.cfi_startproc
 5104              		@ args = 0, pretend = 0, frame = 0
 5105              		@ frame_needed = 0, uses_anonymous_args = 0
 5106 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5107              	.LCFI51:
 5108              		.cfi_def_cfa_offset 24
 5109              		.cfi_offset 14, -4
 5110              		.cfi_offset 7, -8
 5111              		.cfi_offset 6, -12
 5112              		.cfi_offset 5, -16
 5113              		.cfi_offset 4, -20
 5114              		.cfi_offset 3, -24
 5115              	.LBB139:
 241:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 242:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if (rawPressureSumCount == 0) { // it may occur at init time that no pressure has been read yet!
 5116              		.loc 22 242 0
 5117 0002 2D4D     		ldr	r5, .L295+8
 5118 0004 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 5119 0006 002B     		cmp	r3, #0
 5120 0008 51D0     		beq	.L291
 243:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     return;
 244:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 245:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 246:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = rawPressureSum / rawPressureSumCount;
 5121              		.loc 22 246 0
 5122 000a 06EE903A 		fmsr	s13, r3	@ int
 5123 000e 2B4C     		ldr	r4, .L295+12
 5124 0010 2B4B     		ldr	r3, .L295+16
 5125 0012 94ED007A 		flds	s14, [r4, #0]
 5126 0016 F8EEE67A 		fsitos	s15, s13
 5127 001a C7EE277A 		fdivs	s15, s14, s15
 247:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 248:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroRawAltitude = 44330 * (1 - pow(pressure/101325.0, pressureFactor)); // returns absolute baroA
 5128              		.loc 22 248 0
 5129 001e 9FED297A 		flds	s14, .L295+20
 5130 0022 C7EE876A 		fdivs	s13, s15, s14
 246:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = rawPressureSum / rawPressureSumCount;
 5131              		.loc 22 246 0
 5132 0026 C3ED007A 		fsts	s15, [r3, #0]
 5133              		.loc 22 248 0
 5134 002a 16EE900A 		fmrs	r0, s13
 5135 002e FFF7FEFF 		bl	__aeabi_f2d
 5136 0032 254B     		ldr	r3, .L295+24
 5137 0034 0646     		mov	r6, r0
 5138 0036 1868     		ldr	r0, [r3, #0]	@ float
 5139 0038 0F46     		mov	r7, r1
 5140 003a FFF7FEFF 		bl	__aeabi_f2d
 5141 003e 0246     		mov	r2, r0
 5142 0040 0B46     		mov	r3, r1
 5143 0042 3046     		mov	r0, r6
 5144 0044 3946     		mov	r1, r7
 5145 0046 FFF7FEFF 		bl	pow
 5146 004a 0246     		mov	r2, r0
 5147 004c 0B46     		mov	r3, r1
 5148 004e 0020     		movs	r0, #0
 5149 0050 1E49     		ldr	r1, .L295+28
 5150 0052 1F4E     		ldr	r6, .L295+32
 5151 0054 FFF7FEFF 		bl	__aeabi_dsub
 5152 0058 15A3     		adr	r3, .L295
 5153 005a D3E90023 		ldrd	r2, [r3]
 5154 005e FFF7FEFF 		bl	__aeabi_dmul
 5155 0062 FFF7FEFF 		bl	__aeabi_d2f
 5156 0066 1B4B     		ldr	r3, .L295+36
 5157 0068 1860     		str	r0, [r3, #0]	@ float
 249:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // use calculation below in case you need a smaller binary file for CPUs having just 32KB flash R
 250:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // baroRawAltitude = (101325.0-pressure)/4096*346;
 251:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 252:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611_first_read) {
 5158              		.loc 22 252 0
 5159 006a 1B4B     		ldr	r3, .L295+40
 5160 006c 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 5161 006e 19B1     		cbz	r1, .L293
 253:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = baroRawAltitude;
 254:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     MS5611_first_read = false;
 5162              		.loc 22 254 0
 5163 0070 0022     		movs	r2, #0
 253:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = baroRawAltitude;
 5164              		.loc 22 253 0
 5165 0072 3060     		str	r0, [r6, #0]	@ float
 5166              		.loc 22 254 0
 5167 0074 1A70     		strb	r2, [r3, #0]
 5168 0076 05E0     		b	.L294
 5169              	.L293:
 255:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   } 
 256:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   else {
 257:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****     baroAltitude = filterSmooth(baroRawAltitude, baroAltitude, baroSmoothFactor);
 5170              		.loc 22 257 0
 5171 0078 184B     		ldr	r3, .L295+44
 5172 007a 3168     		ldr	r1, [r6, #0]	@ float
 5173 007c 1A68     		ldr	r2, [r3, #0]	@ float
 5174 007e FFF7FEFF 		bl	_Z12filterSmoothfff
 5175 0082 3060     		str	r0, [r6, #0]	@ float
 5176              	.L294:
 258:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   }
 259:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 260:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSum = 0.0;
 5177              		.loc 22 260 0
 5178 0084 0022     		movs	r2, #0
 5179 0086 2260     		str	r2, [r4, #0]	@ float
 261:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSumCount = 0;
 262:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 
 263:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   // set ground altitude after a delay, so sensor has time to heat up
 264:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   const unsigned long updateDelayInSeconds = 10;
 265:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(!baroGroundUpdateDone && (micros()-baroStartTime) > updateDelayInSeconds*1000000) {
 5180              		.loc 22 265 0
 5181 0088 154C     		ldr	r4, .L295+48
 5182 008a 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 261:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   rawPressureSumCount = 0;
 5183              		.loc 22 261 0
 5184 008c 0021     		movs	r1, #0
 5185 008e 2970     		strb	r1, [r5, #0]
 5186              	.LVL260:
 5187              		.loc 22 265 0
 5188 0090 68B9     		cbnz	r0, .L291
 5189              		.loc 22 265 0 is_stmt 0 discriminator 1
 5190 0092 FFF7FEFF 		bl	_ZL6microsv
 5191 0096 1349     		ldr	r1, .L295+52
 5192 0098 0B68     		ldr	r3, [r1, #0]
 5193 009a C3EB000C 		rsb	ip, r3, r0
 5194 009e 1248     		ldr	r0, .L295+56
 5195 00a0 8445     		cmp	ip, r0
 5196 00a2 04D9     		bls	.L291
 266:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundAltitude = baroAltitude;
 5197              		.loc 22 266 0 is_stmt 1 discriminator 4
 5198 00a4 3068     		ldr	r0, [r6, #0]	@ float
 5199 00a6 114B     		ldr	r3, .L295+60
 267:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundUpdateDone = true;
 5200              		.loc 22 267 0 discriminator 4
 5201 00a8 0122     		movs	r2, #1
 266:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  baroGroundAltitude = baroAltitude;
 5202              		.loc 22 266 0 discriminator 4
 5203 00aa 1860     		str	r0, [r3, #0]	@ float
 5204              		.loc 22 267 0 discriminator 4
 5205 00ac 2270     		strb	r2, [r4, #0]
 5206              	.LVL261:
 5207              	.L291:
 5208 00ae F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5209              	.L296:
 5210              		.align	3
 5211              	.L295:
 5212 00b0 00000000 		.word	0
 5213 00b4 40A5E540 		.word	1088791872
 5214 00b8 00000000 		.word	.LANCHOR68
 5215 00bc 00000000 		.word	.LANCHOR67
 5216 00c0 00000000 		.word	.LANCHOR70
 5217 00c4 80E6C547 		.word	1204151936
 5218 00c8 00000000 		.word	.LANCHOR71
 5219 00cc 0000F03F 		.word	1072693248
 5220 00d0 00000000 		.word	.LANCHOR59
 5221 00d4 00000000 		.word	.LANCHOR72
 5222 00d8 00000000 		.word	.LANCHOR73
 5223 00dc 00000000 		.word	.LANCHOR74
 5224 00e0 00000000 		.word	.LANCHOR75
 5225 00e4 00000000 		.word	.LANCHOR76
 5226 00e8 80969800 		.word	10000000
 5227 00ec 00000000 		.word	.LANCHOR60
 5228              	.LBE139:
 5229              		.cfi_endproc
 5230              	.LFE205:
 5232              		.section	.text._Z11measureBarov,"ax",%progbits
 5233              		.align	1
 5234              		.global	_Z11measureBarov
 5235              		.thumb
 5236              		.thumb_func
 5238              	_Z11measureBarov:
 5239              	.LFB203:
 211:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void measureBaro() {
 5240              		.loc 22 211 0
 5241              		.cfi_startproc
 5242              		@ args = 0, pretend = 0, frame = 0
 5243              		@ frame_needed = 0, uses_anonymous_args = 0
 5244 0000 08B5     		push	{r3, lr}
 5245              	.LCFI52:
 5246              		.cfi_def_cfa_offset 8
 5247              		.cfi_offset 14, -4
 5248              		.cfi_offset 3, -8
 212:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum();
 5249              		.loc 22 212 0
 5250 0002 FFF7FEFF 		bl	_Z14measureBaroSumv
 214:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5251              		.loc 22 214 0
 5252 0006 BDE80840 		pop	{r3, lr}
 213:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   evaluateBaroAltitude();
 5253              		.loc 22 213 0
 5254 000a FFF7FEBF 		b	_Z20evaluateBaroAltitudev
 5255              		.cfi_endproc
 5256              	.LFE203:
 5258              		.section	.text._Z17measureGroundBarov,"ax",%progbits
 5259              		.align	1
 5260              		.global	_Z17measureGroundBarov
 5261              		.thumb
 5262              		.thumb_func
 5264              	_Z17measureGroundBarov:
 5265              	.LFB192:
  46:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****  
  47:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureGroundBaro() {
 5266              		.loc 21 47 0
 5267              		.cfi_startproc
 5268              		@ args = 0, pretend = 0, frame = 0
 5269              		@ frame_needed = 0, uses_anonymous_args = 0
 5270              	.LVL262:
 5271 0000 10B5     		push	{r4, lr}
 5272              	.LCFI53:
 5273              		.cfi_def_cfa_offset 8
 5274              		.cfi_offset 14, -4
 5275              		.cfi_offset 4, -8
 5276 0002 2DED028B 		fstmfdd	sp!, {d8}
 5277              	.LCFI54:
 5278              		.cfi_def_cfa_offset 16
 5279              		.cfi_offset 80, -16
  48:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   // measure initial ground pressure (multiple samples)
  49:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   float altSum = 0.0;
 5280              		.loc 21 49 0
 5281 0006 9FED0C8A 		flds	s16, .L301
  47:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** void measureGroundBaro() {
 5282              		.loc 21 47 0
 5283 000a 1924     		movs	r4, #25
 5284              	.LVL263:
 5285              	.L299:
 5286              	.LBB140:
 5287              	.LBB141:
  50:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   for (int i=0; i < 25; i++) {
  51:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****     measureBaro();
 5288              		.loc 21 51 0 discriminator 2
 5289 000c FFF7FEFF 		bl	_Z11measureBarov
  52:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 	altSum += baroRawAltitude;
 5290              		.loc 21 52 0 discriminator 2
 5291 0010 0A4B     		ldr	r3, .L301+4
 5292 0012 D3ED007A 		flds	s15, [r3, #0]
  53:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****     delay(12);
 5293              		.loc 21 53 0 discriminator 2
 5294 0016 0C20     		movs	r0, #12
  52:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** 	altSum += baroRawAltitude;
 5295              		.loc 21 52 0 discriminator 2
 5296 0018 38EE278A 		fadds	s16, s16, s15
 5297              	.LVL264:
 5298              		.loc 21 53 0 discriminator 2
 5299 001c FFF7FEFF 		bl	_Z5delaym
  50:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   for (int i=0; i < 25; i++) {
 5300              		.loc 21 50 0 discriminator 2
 5301 0020 013C     		subs	r4, r4, #1
 5302 0022 F3D1     		bne	.L299
 5303              	.LBE141:
  54:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   }
  55:../Libraries/AQ_BarometricSensor/BarometricSensor.h ****   baroGroundAltitude = altSum / 25;
 5304              		.loc 21 55 0
 5305 0024 B3EE090A 		fconsts	s0, #57
 5306 0028 88EE000A 		fdivs	s0, s16, s0
 5307 002c 0448     		ldr	r0, .L301+8
 5308 002e 80ED000A 		fsts	s0, [r0, #0]
 5309              	.LBE140:
  56:../Libraries/AQ_BarometricSensor/BarometricSensor.h **** }
 5310              		.loc 21 56 0
 5311 0032 BDEC028B 		fldmfdd	sp!, {d8}
 5312 0036 10BD     		pop	{r4, pc}
 5313              	.L302:
 5314              		.align	2
 5315              	.L301:
 5316 0038 00000000 		.word	0
 5317 003c 00000000 		.word	.LANCHOR72
 5318 0040 00000000 		.word	.LANCHOR60
 5319              		.cfi_endproc
 5320              	.LFE192:
 5322              		.section	.text._Z14initializeBarov,"ax",%progbits
 5323              		.align	1
 5324              		.global	_Z14initializeBarov
 5325              		.thumb
 5326              		.thumb_func
 5328              	_Z14initializeBarov:
 5329              	.LFB202:
 182:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** void initializeBaro() {
 5330              		.loc 22 182 0
 5331              		.cfi_startproc
 5332              		@ args = 0, pretend = 0, frame = 0
 5333              		@ frame_needed = 0, uses_anonymous_args = 0
 5334 0000 10B5     		push	{r4, lr}
 5335              	.LCFI55:
 5336              		.cfi_def_cfa_offset 8
 5337              		.cfi_offset 14, -4
 5338              		.cfi_offset 4, -8
 183:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 5339              		.loc 22 183 0
 5340 0002 FFF7FEFF 		bl	_ZL6microsv
 5341 0006 1A4C     		ldr	r4, .L305
 185:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 5342              		.loc 22 185 0
 5343 0008 1A49     		ldr	r1, .L305+4
 183:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroStartTime = micros();
 5344              		.loc 22 183 0
 5345 000a 2060     		str	r0, [r4, #0]
 187:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 5346              		.loc 22 187 0
 5347 000c 1A4A     		ldr	r2, .L305+8
 5348 000e 1B4B     		ldr	r3, .L305+12
 186:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 5349              		.loc 22 186 0
 5350 0010 1B4C     		ldr	r4, .L305+16
 187:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureFactor = 1/5.255;
 5351              		.loc 22 187 0
 5352 0012 1A60     		str	r2, [r3, #0]	@ float
 185:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressure = 0;
 5353              		.loc 22 185 0
 5354 0014 0020     		movs	r0, #0
 5355 0016 0860     		str	r0, [r1, #0]	@ float
 186:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroGroundAltitude = 0;
 5356              		.loc 22 186 0
 5357 0018 2060     		str	r0, [r4, #0]	@ float
 189:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   MS5611reset(MS5611_I2C_ADDRESS); // reset the device to populate its internal PROM registers
 5358              		.loc 22 189 0
 5359 001a 7620     		movs	r0, #118
 5360 001c FFF7FEFF 		bl	_Z11MS5611reseti
 190:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(3); // some safety time
 5361              		.loc 22 190 0
 5362 0020 0320     		movs	r0, #3
 5363 0022 FFF7FEFF 		bl	_Z5delaym
 192:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   if(MS5611readPROM(MS5611_I2C_ADDRESS) ) {
 5364              		.loc 22 192 0
 5365 0026 7620     		movs	r0, #118
 5366 0028 FFF7FEFF 		bl	_Z14MS5611readPROMi
 5367 002c 20B1     		cbz	r0, .L304
 193:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** 	  vehicleState |= BARO_DETECTED;
 5368              		.loc 22 193 0
 5369 002e 154B     		ldr	r3, .L305+20
 5370 0030 1868     		ldr	r0, [r3, #0]
 5371 0032 40F00802 		orr	r2, r0, #8
 5372 0036 1A60     		str	r2, [r3, #0]
 5373              	.L304:
 196:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   requestRawTemperature(); // setup up next measure() for temperature
 5374              		.loc 22 196 0
 5375 0038 FFF7FEFF 		bl	_Z21requestRawTemperaturev
 197:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 5376              		.loc 22 197 0
 5377 003c 1249     		ldr	r1, .L305+24
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 5378              		.loc 22 198 0
 5379 003e 1348     		ldr	r0, .L305+28
 197:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   isReadPressure = false;
 5380              		.loc 22 197 0
 5381 0040 0023     		movs	r3, #0
 5382 0042 0B70     		strb	r3, [r1, #0]
 198:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   pressureCount = 0;
 5383              		.loc 22 198 0
 5384 0044 0370     		strb	r3, [r0, #0]
 199:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5385              		.loc 22 199 0
 5386 0046 0A20     		movs	r0, #10
 5387 0048 FFF7FEFF 		bl	_Z5delaym
 200:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaroSum(); // read temperature
 5388              		.loc 22 200 0
 5389 004c FFF7FEFF 		bl	_Z14measureBaroSumv
 201:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5390              		.loc 22 201 0
 5391 0050 0A20     		movs	r0, #10
 5392 0052 FFF7FEFF 		bl	_Z5delaym
 202:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureBaro(); // read pressure
 5393              		.loc 22 202 0
 5394 0056 FFF7FEFF 		bl	_Z11measureBarov
 203:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   delay(10);
 5395              		.loc 22 203 0
 5396 005a 0A20     		movs	r0, #10
 5397 005c FFF7FEFF 		bl	_Z5delaym
 205:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 5398              		.loc 22 205 0
 5399 0060 FFF7FEFF 		bl	_Z17measureGroundBarov
 206:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   measureGroundBaro();
 5400              		.loc 22 206 0
 5401 0064 FFF7FEFF 		bl	_Z17measureGroundBarov
 208:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h ****   baroAltitude = baroGroundAltitude;
 5402              		.loc 22 208 0
 5403 0068 2168     		ldr	r1, [r4, #0]	@ float
 5404 006a 094A     		ldr	r2, .L305+32
 5405 006c 1160     		str	r1, [r2, #0]	@ float
 209:../Libraries/AQ_BarometricSensor/BarometricSensor_MS5611.h **** }
 5406              		.loc 22 209 0
 5407 006e 10BD     		pop	{r4, pc}
 5408              	.L306:
 5409              		.align	2
 5410              	.L305:
 5411 0070 00000000 		.word	.LANCHOR76
 5412 0074 00000000 		.word	.LANCHOR70
 5413 0078 AEDC423E 		.word	1044569262
 5414 007c 00000000 		.word	.LANCHOR71
 5415 0080 00000000 		.word	.LANCHOR60
 5416 0084 00000000 		.word	.LANCHOR13
 5417 0088 00000000 		.word	.LANCHOR66
 5418 008c 00000000 		.word	.LANCHOR69
 5419 0090 00000000 		.word	.LANCHOR59
 5420              		.cfi_endproc
 5421              	.LFE202:
 5423              		.section	.text._ZN9LIDARLiteC2Ev,"ax",%progbits
 5424              		.align	1
 5425              		.global	_ZN9LIDARLiteC2Ev
 5426              		.thumb
 5427              		.thumb_func
 5429              	_ZN9LIDARLiteC2Ev:
 5430              	.LFB207:
 5431              		.file 23 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   LIDARLite Arduino Library
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   LIDARLite.h
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   This library provides quick access to all the basic functions of LIDAR-Lite
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   via the Arduino interface. Additionally, it can provide a user of any
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   platform with a template for their own application code.
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Copyright (c) 2016 Garmin Ltd. or its subsidiaries.
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Licensed under the Apache License, Version 2.0 (the "License");
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   you may not use this file except in compliance with the License.
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   You may obtain a copy of the License at
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   http://www.apache.org/licenses/LICENSE-2.0
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Unless required by applicable law or agreed to in writing, software
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   distributed under the License is distributed on an "AS IS" BASIS,
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   See the License for the specific language governing permissions and
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   limitations under the License.
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #ifndef LIDARLite_h
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #define LIDARLite_h
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #define LIDARLITE_ADDR_DEFAULT 0x62
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #include <Arduino.h>
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #include <Wire.h>
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #include <stdarg.h>
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** class LIDARLite
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   public:
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       LIDARLite();
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       void begin(int = 0, bool = false, char = LIDARLITE_ADDR_DEFAULT);
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       void configure(int = 0, char = LIDARLITE_ADDR_DEFAULT);
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       void reset(char = LIDARLITE_ADDR_DEFAULT);
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       int distance(bool = true, char = LIDARLITE_ADDR_DEFAULT);
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       void write(char, char, char = LIDARLITE_ADDR_DEFAULT);
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       void read(char, int, byte*, bool, char);
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       void correlationRecordToSerial(char = '\n', int = 256, char = LIDARLITE_ADDR_DEFAULT);
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** };
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** #endif
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** //////////////////////////////////////////////////////////////////////////////////////////////
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Constructor
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Use LIDARLite::begin to initialize.
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** LIDARLite::LIDARLite(){}
 5432              		.loc 23 48 0
 5433              		.cfi_startproc
 5434              		@ args = 0, pretend = 0, frame = 0
 5435              		@ frame_needed = 0, uses_anonymous_args = 0
 5436              		@ link register save eliminated.
 5437              	.LVL265:
 5438              		.loc 23 48 0
 5439 0000 7047     		bx	lr
 5440              		.cfi_endproc
 5441              	.LFE207:
 5443              		.section	.text._ZN9LIDARLite5writeEccc,"ax",%progbits
 5444              		.align	1
 5445              		.global	_ZN9LIDARLite5writeEccc
 5446              		.thumb
 5447              		.thumb_func
 5449              	_ZN9LIDARLite5writeEccc:
 5450              	.LFB213:
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Begin
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Starts the sensor and I2C.
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   configuration: Default 0. Selects one of several preset configurations.
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   fasti2c: Default 100 kHz. I2C base frequency.
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     If true I2C frequency is set to 400kHz.
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   lidarliteAddress: Default 0x62. Fill in new address here if changed. See
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     operating manual for instructions.
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** void LIDARLite::begin(int configuration, bool fasti2c, char lidarliteAddress)
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   //Wire.begin(); // Start I2C
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.begin(Port2Pin('B', 11), Port2Pin('B', 10)); // I2C2_SDA PB11, I2C2_SCL PB10
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*  if(fasti2c)
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     #if ARDUINO >= 157
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       Wire.setClock(400000UL); // Set I2C frequency to 400kHz, for Arduino Due
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     #else
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       TWBR = ((F_CPU / 400000UL) - 16) / 2; // Set I2C frequency to 400kHz
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     #endif 
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     TWBR = ((F_CPU / 400000UL) - 16) / 2; // Set I2C frequency to 400kHz
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   } */
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   configure(configuration, lidarliteAddress); // Configuration settings
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::begin */
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Configure
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Selects one of several preset configurations.
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   configuration:  Default 0.
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     0: Default mode, balanced performance.
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     1: Short range, high speed. Uses 0x1d maximum acquisition count.
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     2: Default range, higher speed short range. Turns on quick termination
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         detection for faster measurements at short range (with decreased
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         accuracy)
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     3: Maximum range. Uses 0xff maximum acquisition count.
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     4: High sensitivity detection. Overrides default valid measurement detection
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         algorithm, and uses a threshold value for high sensitivity and noise.
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     5: Low sensitivity detection. Overrides default valid measurement detection
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         algorithm, and uses a threshold value for low sensitivity and noise.
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   lidarliteAddress: Default 0x62. Fill in new address here if changed. See
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     operating manual for instructions.
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** void LIDARLite::configure(int configuration, char lidarliteAddress)
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   switch (configuration)
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     case 0: // Default mode, balanced performance
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x00,lidarliteAddress); // Default
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     break;
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     case 1: // Short range, high speed
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x1d,lidarliteAddress);
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x00,lidarliteAddress); // Default
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     break;
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     case 2: // Default range, higher speed short range
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x00,lidarliteAddress);
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x00,lidarliteAddress); // Default
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     break;
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     case 3: // Maximum range
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0xff,lidarliteAddress);
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x00,lidarliteAddress); // Default
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     break;
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     case 4: // High sensitivity detection, high erroneous measurements
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x80,lidarliteAddress);
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     break;
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     case 5: // Low sensitivity detection, low erroneous measurements
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0xb0,lidarliteAddress);
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     break;
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::configure */
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Reset
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Reset device. The device reloads default register settings, including the
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   default I2C address. Re-initialization takes approximately 22ms.
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   lidarliteAddress: Default 0x62. Fill in new address here if changed. See
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     operating manual for instructions.
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** void LIDARLite::reset(char lidarliteAddress)
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   write(0x00,0x00,lidarliteAddress);
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::reset */
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Distance
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Take a distance measurement and read the result.
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Process
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   1.  Write 0x04 or 0x03 to register 0x00 to initiate an aquisition.
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   2.  Read register 0x01 (this is handled in the read() command)
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       - if the first bit is "1" then the sensor is busy, loop until the first
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         bit is "0"
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       - if the first bit is "0" then the sensor is ready
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   3.  Read two bytes from register 0x8f and save
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   4.  Shift the first value from 0x8f << 8 and add to second value from 0x8f.
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       The result is the measured distance in centimeters.
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   biasCorrection: Default true. Take aquisition with receiver bias
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     correction. If set to false measurements will be faster. Receiver bias
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     correction must be performed periodically. (e.g. 1 out of every 100
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     readings).
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   lidarliteAddress: Default 0x62. Fill in new address here if changed. See
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     operating manual for instructions.
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** int LIDARLite::distance(bool biasCorrection, char lidarliteAddress)
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   if(biasCorrection)
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // Take acquisition & correlation processing with receiver bias correction
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     write(0x00,0x04,lidarliteAddress);
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   else
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // Take acquisition & correlation processing without receiver bias correction
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     write(0x00,0x03,lidarliteAddress);
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Array to store high and low bytes of distance
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   byte distanceArray[2];
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Read two bytes from register 0x8f (autoincrement for reading 0x0f and 0x10)
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   read(0x8f,2,distanceArray,true,lidarliteAddress);
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Shift high byte and add to low byte
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   int distance = (distanceArray[0] << 8) + distanceArray[1];
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   return(distance);
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::distance */
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Write
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Perform I2C write to device.
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   myAddress: register address to write to.
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   myValue: value to write.
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   lidarliteAddress: Default 0x62. Fill in new address here if changed. See
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     operating manual for instructions.
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** void LIDARLite::write(char myAddress, char myValue, char lidarliteAddress)
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5451              		.loc 23 206 0
 5452              		.cfi_startproc
 5453              		@ args = 0, pretend = 0, frame = 0
 5454              		@ frame_needed = 0, uses_anonymous_args = 0
 5455              	.LVL266:
 5456 0000 38B5     		push	{r3, r4, r5, lr}
 5457              	.LCFI56:
 5458              		.cfi_def_cfa_offset 16
 5459              		.cfi_offset 14, -4
 5460              		.cfi_offset 5, -8
 5461              		.cfi_offset 4, -12
 5462              		.cfi_offset 3, -16
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.beginTransmission((int)lidarliteAddress);
 5463              		.loc 23 207 0
 5464 0002 0B48     		ldr	r0, .L310
 5465              	.LVL267:
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5466              		.loc 23 206 0
 5467 0004 0C46     		mov	r4, r1
 5468              		.loc 23 207 0
 5469 0006 1946     		mov	r1, r3
 5470              	.LVL268:
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5471              		.loc 23 206 0
 5472 0008 1546     		mov	r5, r2
 5473              		.loc 23 207 0
 5474 000a FFF7FEFF 		bl	_ZN7TwoWire17beginTransmissionEi
 5475              	.LVL269:
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.write((int)myAddress); // Set register for write
 5476              		.loc 23 208 0
 5477 000e 2146     		mov	r1, r4
 5478 0010 0748     		ldr	r0, .L310
 5479 0012 FFF7FEFF 		bl	_ZN7TwoWire5writeEi
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.write((int)myValue); // Write myValue to register
 5480              		.loc 23 209 0
 5481 0016 2946     		mov	r1, r5
 5482 0018 0548     		ldr	r0, .L310
 5483 001a FFF7FEFF 		bl	_ZN7TwoWire5writeEi
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // A nack means the device is not responding, report the error over serial
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.endTransmission();
 5484              		.loc 23 212 0
 5485 001e 0448     		ldr	r0, .L310
 5486 0020 FFF7FEFF 		bl	_ZN7TwoWire15endTransmissionEv
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   //int nackCatcher = Wire.endTransmission();
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****  /* if(nackCatcher != 0)
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Serial.println("> nack");
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   } */
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   delay(1); // 1 ms delay for robustness with successive reads and writes
 5487              		.loc 23 219 0
 5488 0024 0120     		movs	r0, #1
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::write */
 5489              		.loc 23 220 0
 5490 0026 BDE83840 		pop	{r3, r4, r5, lr}
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   delay(1); // 1 ms delay for robustness with successive reads and writes
 5491              		.loc 23 219 0
 5492 002a FFF7FEBF 		b	_Z5delaym
 5493              	.L311:
 5494 002e 00BF     		.align	2
 5495              	.L310:
 5496 0030 00000000 		.word	Wire
 5497              		.cfi_endproc
 5498              	.LFE213:
 5500              		.section	.text._ZN9LIDARLite5resetEc,"ax",%progbits
 5501              		.align	1
 5502              		.global	_ZN9LIDARLite5resetEc
 5503              		.thumb
 5504              		.thumb_func
 5506              	_ZN9LIDARLite5resetEc:
 5507              	.LFB211:
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5508              		.loc 23 148 0
 5509              		.cfi_startproc
 5510              		@ args = 0, pretend = 0, frame = 0
 5511              		@ frame_needed = 0, uses_anonymous_args = 0
 5512              		@ link register save eliminated.
 5513              	.LVL270:
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5514              		.loc 23 148 0
 5515 0000 0B46     		mov	r3, r1
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   write(0x00,0x00,lidarliteAddress);
 5516              		.loc 23 149 0
 5517 0002 0021     		movs	r1, #0
 5518              	.LVL271:
 5519 0004 0A46     		mov	r2, r1
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::reset */
 5520              		.loc 23 150 0
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   write(0x00,0x00,lidarliteAddress);
 5521              		.loc 23 149 0
 5522 0006 FFF7FEBF 		b	_ZN9LIDARLite5writeEccc
 5523              	.LVL272:
 5524              		.cfi_endproc
 5525              	.LFE211:
 5527              		.section	.text._ZN9LIDARLite9configureEic,"ax",%progbits
 5528              		.align	1
 5529              		.global	_ZN9LIDARLite9configureEic
 5530              		.thumb
 5531              		.thumb_func
 5533              	_ZN9LIDARLite9configureEic:
 5534              	.LFB210:
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5535              		.loc 23 97 0
 5536              		.cfi_startproc
 5537              		@ args = 0, pretend = 0, frame = 0
 5538              		@ frame_needed = 0, uses_anonymous_args = 0
 5539              	.LVL273:
 5540 0000 70B5     		push	{r4, r5, r6, lr}
 5541              	.LCFI57:
 5542              		.cfi_def_cfa_offset 16
 5543              		.cfi_offset 14, -4
 5544              		.cfi_offset 6, -8
 5545              		.cfi_offset 5, -12
 5546              		.cfi_offset 4, -16
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5547              		.loc 23 97 0
 5548 0002 0546     		mov	r5, r0
 5549 0004 1446     		mov	r4, r2
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   switch (configuration)
 5550              		.loc 23 98 0
 5551 0006 0529     		cmp	r1, #5
 5552 0008 44D8     		bhi	.L313
 5553 000a DFE801F0 		tbb	[pc, r1]
 5554              	.L321:
 5555 000e 03       		.byte	(.L315-.L321)/2
 5556 000f 06       		.byte	(.L316-.L321)/2
 5557 0010 15       		.byte	(.L317-.L321)/2
 5558 0011 1E       		.byte	(.L318-.L321)/2
 5559 0012 21       		.byte	(.L319-.L321)/2
 5560 0013 30       		.byte	(.L320-.L321)/2
 5561              		.align	1
 5562              	.L315:
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 5563              		.loc 23 101 0
 5564 0014 0221     		movs	r1, #2
 5565              	.LVL274:
 5566 0016 8022     		movs	r2, #128
 5567              	.LVL275:
 5568 0018 01E0     		b	.L323
 5569              	.LVL276:
 5570              	.L316:
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x1d,lidarliteAddress);
 5571              		.loc 23 107 0
 5572 001a 0221     		movs	r1, #2
 5573              	.LVL277:
 5574 001c 1D22     		movs	r2, #29
 5575              	.LVL278:
 5576              	.L323:
 5577 001e 2346     		mov	r3, r4
 5578 0020 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 5579              	.LVL279:
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 5580              		.loc 23 108 0
 5581 0024 2846     		mov	r0, r5
 5582 0026 0421     		movs	r1, #4
 5583 0028 0822     		movs	r2, #8
 5584              	.L324:
 5585 002a 2346     		mov	r3, r4
 5586 002c FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x00,lidarliteAddress); // Default
 5587              		.loc 23 109 0
 5588 0030 2846     		mov	r0, r5
 5589 0032 1C21     		movs	r1, #28
 5590 0034 0022     		movs	r2, #0
 5591 0036 28E0     		b	.L322
 5592              	.LVL280:
 5593              	.L317:
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 5594              		.loc 23 113 0
 5595 0038 0221     		movs	r1, #2
 5596              	.LVL281:
 5597 003a 8022     		movs	r2, #128
 5598              	.LVL282:
 5599 003c 2346     		mov	r3, r4
 5600 003e FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x00,lidarliteAddress);
 5601              		.loc 23 114 0
 5602 0042 2846     		mov	r0, r5
 5603 0044 0421     		movs	r1, #4
 5604 0046 0022     		movs	r2, #0
 5605 0048 EFE7     		b	.L324
 5606              	.LVL283:
 5607              	.L318:
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0xff,lidarliteAddress);
 5608              		.loc 23 119 0
 5609 004a 0221     		movs	r1, #2
 5610              	.LVL284:
 5611 004c FF22     		movs	r2, #255
 5612              	.LVL285:
 5613 004e E6E7     		b	.L323
 5614              	.LVL286:
 5615              	.L319:
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 5616              		.loc 23 125 0
 5617 0050 0221     		movs	r1, #2
 5618              	.LVL287:
 5619 0052 8022     		movs	r2, #128
 5620              	.LVL288:
 5621 0054 2346     		mov	r3, r4
 5622 0056 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 5623              		.loc 23 126 0
 5624 005a 2846     		mov	r0, r5
 5625 005c 0421     		movs	r1, #4
 5626 005e 0822     		movs	r2, #8
 5627 0060 2346     		mov	r3, r4
 5628 0062 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0x80,lidarliteAddress);
 5629              		.loc 23 127 0
 5630 0066 2846     		mov	r0, r5
 5631 0068 1C21     		movs	r1, #28
 5632 006a 8022     		movs	r2, #128
 5633 006c 0DE0     		b	.L322
 5634              	.LVL289:
 5635              	.L320:
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x02,0x80,lidarliteAddress); // Default
 5636              		.loc 23 131 0
 5637 006e 0221     		movs	r1, #2
 5638              	.LVL290:
 5639 0070 8022     		movs	r2, #128
 5640              	.LVL291:
 5641 0072 2346     		mov	r3, r4
 5642 0074 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x04,0x08,lidarliteAddress); // Default
 5643              		.loc 23 132 0
 5644 0078 2846     		mov	r0, r5
 5645 007a 0421     		movs	r1, #4
 5646 007c 0822     		movs	r2, #8
 5647 007e 2346     		mov	r3, r4
 5648 0080 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0xb0,lidarliteAddress);
 5649              		.loc 23 133 0
 5650 0084 2846     		mov	r0, r5
 5651 0086 1C21     		movs	r1, #28
 5652 0088 B022     		movs	r2, #176
 5653              	.L322:
 5654 008a 2346     		mov	r3, r4
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::configure */
 5655              		.loc 23 136 0
 5656 008c BDE87040 		pop	{r4, r5, r6, lr}
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       write(0x1c,0xb0,lidarliteAddress);
 5657              		.loc 23 133 0
 5658 0090 FFF7FEBF 		b	_ZN9LIDARLite5writeEccc
 5659              	.LVL292:
 5660              	.L313:
 5661 0094 70BD     		pop	{r4, r5, r6, pc}
 5662              		.cfi_endproc
 5663              	.LFE210:
 5665              		.section	.text._ZN9LIDARLite5beginEibc,"ax",%progbits
 5666              		.align	1
 5667              		.global	_ZN9LIDARLite5beginEibc
 5668              		.thumb
 5669              		.thumb_func
 5671              	_ZN9LIDARLite5beginEibc:
 5672              	.LFB209:
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5673              		.loc 23 62 0
 5674              		.cfi_startproc
 5675              		@ args = 0, pretend = 0, frame = 0
 5676              		@ frame_needed = 0, uses_anonymous_args = 0
 5677              	.LVL293:
 5678 0000 70B5     		push	{r4, r5, r6, lr}
 5679              	.LCFI58:
 5680              		.cfi_def_cfa_offset 16
 5681              		.cfi_offset 14, -4
 5682              		.cfi_offset 6, -8
 5683              		.cfi_offset 5, -12
 5684              		.cfi_offset 4, -16
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.begin(Port2Pin('B', 11), Port2Pin('B', 10)); // I2C2_SDA PB11, I2C2_SCL PB10
 5685              		.loc 23 64 0
 5686 0002 1A22     		movs	r2, #26
 5687              	.LVL294:
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5688              		.loc 23 62 0
 5689 0004 0546     		mov	r5, r0
 5690 0006 0C46     		mov	r4, r1
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.begin(Port2Pin('B', 11), Port2Pin('B', 10)); // I2C2_SDA PB11, I2C2_SCL PB10
 5691              		.loc 23 64 0
 5692 0008 0548     		ldr	r0, .L326
 5693              	.LVL295:
 5694 000a 1B21     		movs	r1, #27
 5695              	.LVL296:
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5696              		.loc 23 62 0
 5697 000c 1E46     		mov	r6, r3
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Wire.begin(Port2Pin('B', 11), Port2Pin('B', 10)); // I2C2_SDA PB11, I2C2_SCL PB10
 5698              		.loc 23 64 0
 5699 000e FFF7FEFF 		bl	_ZN7TwoWire5beginEhh
 5700              	.LVL297:
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   configure(configuration, lidarliteAddress); // Configuration settings
 5701              		.loc 23 74 0
 5702 0012 2846     		mov	r0, r5
 5703 0014 2146     		mov	r1, r4
 5704 0016 3246     		mov	r2, r6
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::begin */
 5705              		.loc 23 75 0
 5706 0018 BDE87040 		pop	{r4, r5, r6, lr}
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   configure(configuration, lidarliteAddress); // Configuration settings
 5707              		.loc 23 74 0
 5708 001c FFF7FEBF 		b	_ZN9LIDARLite9configureEic
 5709              	.L327:
 5710              		.align	2
 5711              	.L326:
 5712 0020 00000000 		.word	Wire
 5713              		.cfi_endproc
 5714              	.LFE209:
 5716              		.section	.text._ZN9LIDARLite4readEciPhbc,"ax",%progbits
 5717              		.align	1
 5718              		.global	_ZN9LIDARLite4readEciPhbc
 5719              		.thumb
 5720              		.thumb_func
 5722              	_ZN9LIDARLite4readEciPhbc:
 5723              	.LFB214:
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Read
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Perform I2C read from device. Will detect an unresponsive device and report
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   the error over serial. The optional busy flag monitoring
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   can be used to read registers that are updated at the end of a distance
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   measurement to obtain the new data.
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 230:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   myAddress: register address to read from.
 231:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   numOfBytes: numbers of bytes to read. Can be 1 or 2.
 232:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   arrayToSave: an array to store the read values.
 233:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   monitorBusyFlag: if true, the routine will repeatedly read the status
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     register until the busy flag (LSB) is 0.
 235:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** void LIDARLite::read(char myAddress, int numOfBytes, byte arrayToSave[2], bool monitorBusyFlag, cha
 237:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5724              		.loc 23 237 0
 5725              		.cfi_startproc
 5726              		@ args = 8, pretend = 0, frame = 0
 5727              		@ frame_needed = 0, uses_anonymous_args = 0
 5728              	.LVL298:
 5729 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 5730              	.LCFI59:
 5731              		.cfi_def_cfa_offset 24
 5732              		.cfi_offset 14, -4
 5733              		.cfi_offset 8, -8
 5734              		.cfi_offset 7, -12
 5735              		.cfi_offset 6, -16
 5736              		.cfi_offset 5, -20
 5737              		.cfi_offset 4, -24
 5738              		.loc 23 237 0
 5739 0004 0D46     		mov	r5, r1
 5740 0006 1446     		mov	r4, r2
 5741 0008 9846     		mov	r8, r3
 5742 000a 9DF81C60 		ldrb	r6, [sp, #28]	@ zero_extendqisi2
 5743              	.LBB142:
 5744              	.LBB143:
 238:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   int busyFlag = 0; // busyFlag monitors when the device is done with a measurement
 5745              		.loc 23 238 0
 5746 000e 9DF81800 		ldrb	r0, [sp, #24]	@ zero_extendqisi2
 5747              	.LVL299:
 5748              	.LBE143:
 5749              	.LBE142:
 5750 0012 42F21077 		movw	r7, #10000
 5751 0016 1BE0     		b	.L329
 5752              	.LVL300:
 5753              	.L332:
 5754              	.LBB146:
 5755              	.LBB144:
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   if(monitorBusyFlag)
 240:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     busyFlag = 1; // Begin read immediately if not monitoring busy flag
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 243:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   int busyCounter = 0; // busyCounter counts number of times busy flag is checked, for timeout
 244:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   while(busyFlag != 0) // Loop until device is not busy
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // Read status register to check busy flag
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Wire.beginTransmission((int)lidarliteAddress);
 5756              		.loc 23 248 0
 5757 0018 2548     		ldr	r0, .L338
 5758              	.LVL301:
 5759 001a 3146     		mov	r1, r6
 5760 001c FFF7FEFF 		bl	_ZN7TwoWire17beginTransmissionEi
 249:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Wire.write(0x01); // Set the status register to be read
 5761              		.loc 23 249 0
 5762 0020 2348     		ldr	r0, .L338
 5763 0022 0121     		movs	r1, #1
 5764 0024 FFF7FEFF 		bl	_ZN7TwoWire5writeEi
 250:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 251:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // A nack means the device is not responding, report the error over serial
 252:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     int nackCatcher = Wire.endTransmission();
 5765              		.loc 23 252 0
 5766 0028 2148     		ldr	r0, .L338
 5767 002a FFF7FEFF 		bl	_ZN7TwoWire15endTransmissionEv
 5768              	.LVL302:
 253:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if(nackCatcher != 0)
 5769              		.loc 23 253 0
 5770 002e 18B1     		cbz	r0, .L330
 254:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     {
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       Serial.println("> nack");
 5771              		.loc 23 255 0
 5772 0030 2048     		ldr	r0, .L338+4
 5773              	.LVL303:
 5774 0032 2149     		ldr	r1, .L338+8
 5775 0034 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 5776              	.L330:
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     }
 257:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Wire.requestFrom((int)lidarliteAddress,1); // Read register 0x01
 5777              		.loc 23 258 0
 5778 0038 0122     		movs	r2, #1
 5779 003a 3146     		mov	r1, r6
 5780 003c 1C48     		ldr	r0, .L338
 5781 003e FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     busyFlag = bitRead(Wire.read(),0); // Assign the LSB of the status register to busyFlag
 5782              		.loc 23 259 0
 5783 0042 1B48     		ldr	r0, .L338
 5784 0044 FFF7FEFF 		bl	_ZN7TwoWire4readEv
 260:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 261:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     busyCounter++; // Increment busyCounter for timeout
 262:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // Handle timeout condition, exit while loop and goto bailout
 264:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if(busyCounter > 9999)
 5785              		.loc 23 264 0
 5786 0048 013F     		subs	r7, r7, #1
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     busyFlag = bitRead(Wire.read(),0); // Assign the LSB of the status register to busyFlag
 5787              		.loc 23 259 0
 5788 004a 00F00100 		and	r0, r0, #1
 5789              	.LVL304:
 5790              		.loc 23 264 0
 5791 004e 29D0     		beq	.L331
 5792              	.LVL305:
 5793              	.L329:
 5794              	.LBE144:
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   while(busyFlag != 0) // Loop until device is not busy
 5795              		.loc 23 245 0 discriminator 1
 5796 0050 0028     		cmp	r0, #0
 5797 0052 E1D1     		bne	.L332
 5798              	.LBB145:
 265:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     {
 266:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       goto bailout;
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     }
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 269:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Device is not busy, begin read
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   if(busyFlag == 0)
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 273:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Wire.beginTransmission((int)lidarliteAddress);
 5799              		.loc 23 273 0
 5800 0054 1648     		ldr	r0, .L338
 5801              	.LVL306:
 5802 0056 3146     		mov	r1, r6
 5803 0058 FFF7FEFF 		bl	_ZN7TwoWire17beginTransmissionEi
 274:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Wire.write((int)myAddress); // Set the register to be read
 5804              		.loc 23 274 0
 5805 005c 1448     		ldr	r0, .L338
 5806 005e 2946     		mov	r1, r5
 5807 0060 FFF7FEFF 		bl	_ZN7TwoWire5writeEi
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 276:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // A nack means the device is not responding, report the error over serial
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     int nackCatcher = Wire.endTransmission();
 5808              		.loc 23 277 0
 5809 0064 1248     		ldr	r0, .L338
 5810 0066 FFF7FEFF 		bl	_ZN7TwoWire15endTransmissionEv
 5811              	.LVL307:
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if(nackCatcher != 0)
 5812              		.loc 23 278 0
 5813 006a 18B1     		cbz	r0, .L333
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     {
 280:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       Serial.println("> nack");
 5814              		.loc 23 280 0
 5815 006c 1148     		ldr	r0, .L338+4
 5816              	.LVL308:
 5817 006e 1249     		ldr	r1, .L338+8
 5818 0070 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 5819              	.L333:
 281:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     }
 282:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 283:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // Perform read of 1 or 2 bytes, save in arrayToSave
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Wire.requestFrom((int)lidarliteAddress, numOfBytes);
 5820              		.loc 23 284 0
 5821 0074 3146     		mov	r1, r6
 5822 0076 2246     		mov	r2, r4
 5823 0078 0D48     		ldr	r0, .L338
 5824 007a FFF7FEFF 		bl	_ZN7TwoWire11requestFromEii
 5825              	.LVL309:
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     int i = 0;
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if(numOfBytes <= Wire.available())
 5826              		.loc 23 286 0
 5827 007e 0C48     		ldr	r0, .L338
 5828 0080 FFF7FEFF 		bl	_ZN7TwoWire9availableEv
 5829 0084 8442     		cmp	r4, r0
 5830 0086 08DD     		ble	.L337
 5831 0088 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5832              	.LVL310:
 5833              	.L336:
 287:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     {
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       while(i < numOfBytes)
 289:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       {
 290:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         arrayToSave[i] = Wire.read();
 5834              		.loc 23 290 0
 5835 008c 0848     		ldr	r0, .L338
 5836 008e FFF7FEFF 		bl	_ZN7TwoWire4readEv
 5837 0092 08F80500 		strb	r0, [r8, r5]
 291:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****         i++;
 5838              		.loc 23 291 0
 5839 0096 0135     		adds	r5, r5, #1
 5840              	.LVL311:
 5841 0098 00E0     		b	.L334
 5842              	.LVL312:
 5843              	.L337:
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if(numOfBytes <= Wire.available())
 5844              		.loc 23 286 0
 5845 009a 0025     		movs	r5, #0
 5846              	.LVL313:
 5847              	.L334:
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       while(i < numOfBytes)
 5848              		.loc 23 288 0 discriminator 1
 5849 009c A542     		cmp	r5, r4
 5850 009e F5DB     		blt	.L336
 5851 00a0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5852              	.LVL314:
 5853              	.L331:
 5854              	.LBE145:
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       }
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     }
 294:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // bailout reports error over serial
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   if(busyCounter > 9999)
 298:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   {
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     bailout:
 300:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       busyCounter = 0;
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       Serial.println("> read failed");
 5855              		.loc 23 301 0
 5856 00a4 0348     		ldr	r0, .L338+4
 5857              	.LVL315:
 5858 00a6 0549     		ldr	r1, .L338+12
 5859              	.LBE146:
 302:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 303:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::read */
 5860              		.loc 23 303 0
 5861 00a8 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 5862              	.LBB147:
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       Serial.println("> read failed");
 5863              		.loc 23 301 0
 5864 00ac FFF7FEBF 		b	_ZN5Print7printlnEPKc
 5865              	.L339:
 5866              		.align	2
 5867              	.L338:
 5868 00b0 00000000 		.word	Wire
 5869 00b4 00000000 		.word	Serial1
 5870 00b8 00000000 		.word	.LC0
 5871 00bc 07000000 		.word	.LC1
 5872              	.LBE147:
 5873              		.cfi_endproc
 5874              	.LFE214:
 5876              		.section	.text._ZN9LIDARLite8distanceEbc,"ax",%progbits
 5877              		.align	1
 5878              		.global	_ZN9LIDARLite8distanceEbc
 5879              		.thumb
 5880              		.thumb_func
 5882              	_ZN9LIDARLite8distanceEbc:
 5883              	.LFB212:
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5884              		.loc 23 175 0
 5885              		.cfi_startproc
 5886              		@ args = 0, pretend = 0, frame = 8
 5887              		@ frame_needed = 0, uses_anonymous_args = 0
 5888              	.LVL316:
 5889 0000 30B5     		push	{r4, r5, lr}
 5890              	.LCFI60:
 5891              		.cfi_def_cfa_offset 12
 5892              		.cfi_offset 14, -4
 5893              		.cfi_offset 5, -8
 5894              		.cfi_offset 4, -12
 5895 0002 0546     		mov	r5, r0
 5896 0004 85B0     		sub	sp, sp, #20
 5897              	.LCFI61:
 5898              		.cfi_def_cfa_offset 32
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5899              		.loc 23 175 0
 5900 0006 1446     		mov	r4, r2
 5901              	.LBB148:
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   if(biasCorrection)
 5902              		.loc 23 176 0
 5903 0008 11B1     		cbz	r1, .L341
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     write(0x00,0x04,lidarliteAddress);
 5904              		.loc 23 179 0
 5905 000a 0021     		movs	r1, #0
 5906              	.LVL317:
 5907 000c 0422     		movs	r2, #4
 5908              	.LVL318:
 5909 000e 00E0     		b	.L343
 5910              	.LVL319:
 5911              	.L341:
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     write(0x00,0x03,lidarliteAddress);
 5912              		.loc 23 184 0
 5913 0010 0322     		movs	r2, #3
 5914              	.LVL320:
 5915              	.L343:
 5916 0012 2346     		mov	r3, r4
 5917 0014 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 5918              	.LVL321:
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   read(0x8f,2,distanceArray,true,lidarliteAddress);
 5919              		.loc 23 189 0
 5920 0018 0123     		movs	r3, #1
 5921 001a 8DE81800 		stmia	sp, {r3, r4}
 5922 001e 2846     		mov	r0, r5
 5923 0020 8F21     		movs	r1, #143
 5924 0022 03AB     		add	r3, sp, #12
 5925 0024 0222     		movs	r2, #2
 5926 0026 FFF7FEFF 		bl	_ZN9LIDARLite4readEciPhbc
 5927              	.LVL322:
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   int distance = (distanceArray[0] << 8) + distanceArray[1];
 5928              		.loc 23 191 0
 5929 002a 9DF80C10 		ldrb	r1, [sp, #12]	@ zero_extendqisi2
 5930 002e 9DF80D30 		ldrb	r3, [sp, #13]	@ zero_extendqisi2
 5931 0032 0802     		lsls	r0, r1, #8
 5932              	.LBE148:
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::distance */
 5933              		.loc 23 193 0
 5934 0034 C018     		adds	r0, r0, r3
 5935 0036 05B0     		add	sp, sp, #20
 5936 0038 30BD     		pop	{r4, r5, pc}
 5937              		.cfi_endproc
 5938              	.LFE212:
 5940              		.section	.text._ZN9LIDARLite25correlationRecordToSerialEcic,"ax",%progbits
 5941              		.align	1
 5942              		.global	_ZN9LIDARLite25correlationRecordToSerialEcic
 5943              		.thumb
 5944              		.thumb_func
 5946              	_ZN9LIDARLite25correlationRecordToSerialEcic:
 5947              	.LFB215:
 304:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** /*------------------------------------------------------------------------------
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Correlation Record To Serial
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   The correlation record used to calculate distance can be read from the device.
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   It has a bipolar wave shape, transitioning from a positive going portion to a
 309:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   roughly symmetrical negative going pulse. The point where the signal crosses
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   zero represents the effective delay for the reference and return signals.
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Process
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   1.  Take a distance reading (there is no correlation record without at least
 314:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       one distance reading being taken)
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   2.  Select memory bank by writing 0xc0 to register 0x5d
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   3.  Set test mode select by writing 0x07 to register 0x40
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   4.  For as many readings as you want to take (max is 1024)
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       1.  Read two bytes from 0xd2
 319:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       2.  The Low byte is the value from the record
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       3.  The high byte is the sign from the record
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   Parameters
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   ------------------------------------------------------------------------------
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   separator: the separator between serial data words
 324:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   numberOfReadings: Default: 256. Maximum of 1024
 325:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   lidarliteAddress: Default 0x62. Fill in new address here if changed. See
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     operating manual for instructions.
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** ------------------------------------------------------------------------------*/
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** void LIDARLite::correlationRecordToSerial(char separator, int numberOfReadings, char lidarliteAddre
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** {
 5948              		.loc 23 329 0
 5949              		.cfi_startproc
 5950              		@ args = 0, pretend = 0, frame = 8
 5951              		@ frame_needed = 0, uses_anonymous_args = 0
 5952              	.LVL323:
 5953 0000 2DE9FF41 		push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 5954              	.LCFI62:
 5955              		.cfi_def_cfa_offset 40
 5956              		.cfi_offset 14, -4
 5957              		.cfi_offset 8, -8
 5958              		.cfi_offset 7, -12
 5959              		.cfi_offset 6, -16
 5960              		.cfi_offset 5, -20
 5961              		.cfi_offset 4, -24
 5962              		.cfi_offset 3, -28
 5963              		.cfi_offset 2, -32
 5964              		.cfi_offset 1, -36
 5965              		.cfi_offset 0, -40
 5966              		.loc 23 329 0
 5967 0004 0546     		mov	r5, r0
 5968 0006 1C46     		mov	r4, r3
 5969 0008 0F46     		mov	r7, r1
 5970 000a 9046     		mov	r8, r2
 5971              	.LBB149:
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** 
 331:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Array to store read values
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   byte correlationArray[2];
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Var to store value of correlation record
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   int correlationValue = 0;
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   //  Selects memory bank
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   write(0x5d,0xc0,lidarliteAddress);
 5972              		.loc 23 336 0
 5973 000c 5D21     		movs	r1, #93
 5974              	.LVL324:
 5975 000e C022     		movs	r2, #192
 5976              	.LVL325:
 5977 0010 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 5978              	.LVL326:
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // Test mode enable
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   write(0x40, 0x07,lidarliteAddress);
 5979              		.loc 23 338 0
 5980 0014 2846     		mov	r0, r5
 5981 0016 4021     		movs	r1, #64
 5982 0018 0722     		movs	r2, #7
 5983 001a 2346     		mov	r3, r4
 5984 001c FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 5985              	.LVL327:
 5986              	.LBB150:
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   for(int i = 0; i<numberOfReadings; i++){
 5987              		.loc 23 339 0
 5988 0020 0026     		movs	r6, #0
 5989 0022 19E0     		b	.L345
 5990              	.LVL328:
 5991              	.L347:
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // Select single byte
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     read(0xd2,2,correlationArray,false,lidarliteAddress);
 5992              		.loc 23 341 0
 5993 0024 0023     		movs	r3, #0
 5994 0026 D221     		movs	r1, #210
 5995 0028 0222     		movs	r2, #2
 5996 002a 8DE81800 		stmia	sp, {r3, r4}
 5997 002e 2846     		mov	r0, r5
 5998 0030 03AB     		add	r3, sp, #12
 5999 0032 FFF7FEFF 		bl	_ZN9LIDARLite4readEciPhbc
 342:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     //  Low byte is the value of the correlation record
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     correlationValue = correlationArray[0];
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     // if upper byte lsb is set, the value is negative
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if((int)correlationArray[1] == 1){
 6000              		.loc 23 345 0
 6001 0036 9DF80D30 		ldrb	r3, [sp, #13]	@ zero_extendqisi2
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     correlationValue = correlationArray[0];
 6002              		.loc 23 343 0
 6003 003a 9DF80C10 		ldrb	r1, [sp, #12]	@ zero_extendqisi2
 6004              	.LVL329:
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       correlationValue |= 0xff00;
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     }
 348:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Serial.print((int)correlationValue);
 6005              		.loc 23 348 0
 6006 003e 0B48     		ldr	r0, .L348
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     if((int)correlationArray[1] == 1){
 6007              		.loc 23 345 0
 6008 0040 012B     		cmp	r3, #1
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****       correlationValue |= 0xff00;
 6009              		.loc 23 346 0
 6010 0042 08BF     		it	eq
 6011 0044 41F47F41 		orreq	r1, r1, #65280
 6012              	.LVL330:
 6013              		.loc 23 348 0
 6014 0048 0A22     		movs	r2, #10
 6015 004a FFF7FEFF 		bl	_ZN5Print5printEii
 6016              	.LVL331:
 349:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****     Serial.print(separator);
 6017              		.loc 23 349 0
 6018 004e 0748     		ldr	r0, .L348
 6019 0050 3946     		mov	r1, r7
 6020 0052 FFF7FEFF 		bl	_ZN5Print5printEc
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   for(int i = 0; i<numberOfReadings; i++){
 6021              		.loc 23 339 0
 6022 0056 0136     		adds	r6, r6, #1
 6023              	.LVL332:
 6024              	.L345:
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   for(int i = 0; i<numberOfReadings; i++){
 6025              		.loc 23 339 0 is_stmt 0 discriminator 1
 6026 0058 4645     		cmp	r6, r8
 6027 005a E3DB     		blt	.L347
 6028              	.LBE150:
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   }
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   // test mode disable
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h ****   write(0x40,0x00,lidarliteAddress);
 6029              		.loc 23 352 0 is_stmt 1
 6030 005c 2846     		mov	r0, r5
 6031 005e 4021     		movs	r1, #64
 6032 0060 0022     		movs	r2, #0
 6033 0062 2346     		mov	r3, r4
 6034 0064 FFF7FEFF 		bl	_ZN9LIDARLite5writeEccc
 6035              	.LBE149:
 353:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/LIDARLite.h **** } /* LIDARLite::correlationRecordToSerial */
 6036              		.loc 23 353 0
 6037 0068 BDE8FF81 		pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}
 6038              	.L349:
 6039              		.align	2
 6040              	.L348:
 6041 006c 00000000 		.word	Serial1
 6042              		.cfi_endproc
 6043              	.LFE215:
 6045              		.section	.text._Z3kall,"ax",%progbits
 6046              		.align	1
 6047              		.global	_Z3kall
 6048              		.thumb
 6049              		.thumb_func
 6051              	_Z3kall:
 6052              	.LFB217:
 6053              		.file 24 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** 
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** #include "LIDARLite.h"
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** LIDARLite myLidarLite;
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** 
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** float prev_val;
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** unsigned char i2caddress[2] = {0x64, 0x66};
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** // use STM pins below!
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** int pinsArray[2] = {50, 52};
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** int alt_read(){
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   int temp = myLidarLite.distance();
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   kal_filt = kal(temp);
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   //Serial.print(temp);
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****  // Serial.print(" ");
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****  // Serial.println(kal_filt);
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   //kal_filt = kal(myLidarLite.distance());
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   //myLidarLite.distance(flase);
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   return kal_filt;
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** }
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** 
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** float kal(signed long meas_val)
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** {
 6054              		.loc 24 23 0
 6055              		.cfi_startproc
 6056              		@ args = 0, pretend = 0, frame = 0
 6057              		@ frame_needed = 0, uses_anonymous_args = 0
 6058              		@ link register save eliminated.
 6059              	.LVL333:
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****  /* if(meas_val != 0)
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   {*/
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     k = ((est_err+q)/(meas_err + est_err+q));
 6060              		.loc 24 26 0
 6061 0000 144B     		ldr	r3, .L351
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     est_val = (1-k)*est_val + k*meas_val;
 6062              		.loc 24 27 0
 6063 0002 154A     		ldr	r2, .L351+4
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     k = ((est_err+q)/(meas_err + est_err+q));
 6064              		.loc 24 26 0
 6065 0004 1549     		ldr	r1, .L351+8
 6066 0006 93ED007A 		flds	s14, [r3, #0]
 6067 000a B2EE042A 		fconsts	s4, #36
 6068 000e 77EE021A 		fadds	s3, s14, s4
 6069 0012 B6EE001A 		fconsts	s2, #96
 6070 0016 77EE010A 		fadds	s1, s14, s2
 6071 001a 71EE817A 		fadds	s15, s3, s2
 6072              		.loc 24 27 0
 6073 001e 05EE100A 		fmsr	s10, r0	@ int
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     k = ((est_err+q)/(meas_err + est_err+q));
 6074              		.loc 24 26 0
 6075 0022 C0EEA77A 		fdivs	s15, s1, s15
 6076              		.loc 24 27 0
 6077 0026 B7EE000A 		fconsts	s0, #112
 6078 002a F8EEC55A 		fsitos	s11, s10
 6079 002e 70EE676A 		fsubs	s13, s0, s15
 6080 0032 92ED006A 		flds	s12, [r2, #0]
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     k = ((est_err+q)/(meas_err + est_err+q));
 6081              		.loc 24 26 0
 6082 0036 C1ED007A 		fsts	s15, [r1, #0]
 6083              		.loc 24 27 0
 6084 003a 67EEA57A 		fmuls	s15, s15, s11
 6085 003e 46EE867A 		fmacs	s15, s13, s12
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     est_err = (1-k)*est_err;
 6086              		.loc 24 28 0
 6087 0042 26EE877A 		fmuls	s14, s13, s14
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     est_val = (1-k)*est_val + k*meas_val;
 6088              		.loc 24 27 0
 6089 0046 C2ED007A 		fsts	s15, [r2, #0]
 6090              		.loc 24 28 0
 6091 004a 83ED007A 		fsts	s14, [r3, #0]
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****    /* if(est_val != 0)
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****       prev_val = est_val;*/
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     return(est_val);
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** /*  }
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   else
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****     return(prev_val); */
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** 
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** }
 6092              		.loc 24 36 0
 6093 004e 17EE900A 		fmrs	r0, s15
 6094              	.LVL334:
 6095 0052 7047     		bx	lr
 6096              	.L352:
 6097              		.align	2
 6098              	.L351:
 6099 0054 00000000 		.word	.LANCHOR77
 6100 0058 00000000 		.word	.LANCHOR79
 6101 005c 00000000 		.word	.LANCHOR78
 6102              		.cfi_endproc
 6103              	.LFE217:
 6105              		.section	.text._Z8alt_readv,"ax",%progbits
 6106              		.align	1
 6107              		.global	_Z8alt_readv
 6108              		.thumb
 6109              		.thumb_func
 6111              	_Z8alt_readv:
 6112              	.LFB216:
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** int alt_read(){
 6113              		.loc 24 10 0
 6114              		.cfi_startproc
 6115              		@ args = 0, pretend = 0, frame = 0
 6116              		@ frame_needed = 0, uses_anonymous_args = 0
 6117 0000 08B5     		push	{r3, lr}
 6118              	.LCFI63:
 6119              		.cfi_def_cfa_offset 8
 6120              		.cfi_offset 14, -4
 6121              		.cfi_offset 3, -8
 6122              	.LBB151:
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   int temp = myLidarLite.distance();
 6123              		.loc 24 11 0
 6124 0002 0121     		movs	r1, #1
 6125 0004 6222     		movs	r2, #98
 6126 0006 0748     		ldr	r0, .L354
 6127 0008 FFF7FEFF 		bl	_ZN9LIDARLite8distanceEbc
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h ****   kal_filt = kal(temp);
 6128              		.loc 24 12 0
 6129 000c FFF7FEFF 		bl	_Z3kall
 6130 0010 00EE100A 		fmsr	s0, r0
 6131 0014 044B     		ldr	r3, .L354+4
 6132 0016 FDEEC07A 		ftosizs	s15, s0
 6133 001a 17EE900A 		fmrs	r0, s15	@ int
 6134 001e C3ED007A 		fsts	s15, [r3, #0]	@ int
 6135              	.LBE151:
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/lidar_lib.h **** }
 6136              		.loc 24 19 0
 6137 0022 08BD     		pop	{r3, pc}
 6138              	.L355:
 6139              		.align	2
 6140              	.L354:
 6141 0024 00000000 		.word	.LANCHOR80
 6142 0028 00000000 		.word	.LANCHOR81
 6143              		.cfi_endproc
 6144              	.LFE216:
 6146              		.section	.text._Z18boolean_to_decimalPb,"ax",%progbits
 6147              		.align	1
 6148              		.global	_Z18boolean_to_decimalPb
 6149              		.thumb
 6150              		.thumb_func
 6152              	_Z18boolean_to_decimalPb:
 6153              	.LFB218:
 6154              		.file 25 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** // Hokuyo connected to beaglebone Black
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** #define Hokuyo_Serial Serial2
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** 
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** int boolean_to_decimal(bool Arr[]){
 6155              		.loc 25 4 0
 6156              		.cfi_startproc
 6157              		@ args = 0, pretend = 0, frame = 0
 6158              		@ frame_needed = 0, uses_anonymous_args = 0
 6159              	.LVL335:
 6160 0000 10B5     		push	{r4, lr}
 6161              	.LCFI64:
 6162              		.cfi_def_cfa_offset 8
 6163              		.cfi_offset 14, -4
 6164              		.cfi_offset 4, -8
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   int sum=0;
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   for (int i = 0; i<18; i++){
 6165              		.loc 25 6 0
 6166 0002 0023     		movs	r3, #0
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   int sum=0;
 6167              		.loc 25 5 0
 6168 0004 1A46     		mov	r2, r3
 6169              	.LVL336:
 6170              	.L357:
 6171              	.LBB152:
 6172              	.LBB153:
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****     sum += Arr[i]*(1 << (17-i));
 6173              		.loc 25 7 0 discriminator 2
 6174 0006 C45C     		ldrb	r4, [r0, r3]	@ zero_extendqisi2
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** int boolean_to_decimal(bool Arr[]){
 6175              		.loc 25 4 0 discriminator 2
 6176 0008 C3F11101 		rsb	r1, r3, #17
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   for (int i = 0; i<18; i++){
 6177              		.loc 25 6 0 discriminator 2
 6178 000c 0133     		adds	r3, r3, #1
 6179              		.loc 25 7 0 discriminator 2
 6180 000e 14FA01F1 		lsls	r1, r4, r1
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   for (int i = 0; i<18; i++){
 6181              		.loc 25 6 0 discriminator 2
 6182 0012 122B     		cmp	r3, #18
 6183              		.loc 25 7 0 discriminator 2
 6184 0014 0A44     		add	r2, r2, r1
 6185              	.LVL337:
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   for (int i = 0; i<18; i++){
 6186              		.loc 25 6 0 discriminator 2
 6187 0016 F6D1     		bne	.L357
 6188              	.LBE153:
 6189              	.LBE152:
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   }
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   return sum;
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** }
 6190              		.loc 25 10 0
 6191 0018 1046     		mov	r0, r2
 6192              	.LVL338:
 6193 001a 10BD     		pop	{r4, pc}
 6194              		.cfi_endproc
 6195              	.LFE218:
 6197              		.section	.text._Z11Init_Hokuyov,"ax",%progbits
 6198              		.align	1
 6199              		.global	_Z11Init_Hokuyov
 6200              		.thumb
 6201              		.thumb_func
 6203              	_Z11Init_Hokuyov:
 6204              	.LFB219:
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** 
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** void Init_Hokuyo(){
 6205              		.loc 25 12 0
 6206              		.cfi_startproc
 6207              		@ args = 0, pretend = 0, frame = 0
 6208              		@ frame_needed = 0, uses_anonymous_args = 0
 6209              		@ link register save eliminated.
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   Hokuyo_Serial.begin(115200);  	
 6210              		.loc 25 13 0
 6211 0000 0248     		ldr	r0, .L360
 6212 0002 4FF4E131 		mov	r1, #115200
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** }
 6213              		.loc 25 14 0
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   Hokuyo_Serial.begin(115200);  	
 6214              		.loc 25 13 0
 6215 0006 FFF7FEBF 		b	_ZN14HardwareSerial5beginEj
 6216              	.L361:
 6217 000a 00BF     		.align	2
 6218              	.L360:
 6219 000c 00000000 		.word	Serial2
 6220              		.cfi_endproc
 6221              	.LFE219:
 6223              		.section	.text._Z11Hokuyo_Readv,"ax",%progbits
 6224              		.align	1
 6225              		.global	_Z11Hokuyo_Readv
 6226              		.thumb
 6227              		.thumb_func
 6229              	_Z11Hokuyo_Readv:
 6230              	.LFB220:
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** void Hokuyo_Read(){
 6231              		.loc 25 16 0
 6232              		.cfi_startproc
 6233              		@ args = 0, pretend = 0, frame = 0
 6234              		@ frame_needed = 0, uses_anonymous_args = 0
 6235 0000 70B5     		push	{r4, r5, r6, lr}
 6236              	.LCFI65:
 6237              		.cfi_def_cfa_offset 16
 6238              		.cfi_offset 14, -4
 6239              		.cfi_offset 6, -8
 6240              		.cfi_offset 5, -12
 6241              		.cfi_offset 4, -16
 6242              	.L369:
 6243              	.LBB154:
 6244              	.LBB155:
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   if(Hokuyo_Serial.available()>=10){
 6245              		.loc 25 17 0
 6246 0002 1E48     		ldr	r0, .L373
 6247 0004 FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 6248 0008 0928     		cmp	r0, #9
 6249 000a 31D9     		bls	.L363
 6250              	.LBB156:
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****     char check = Hokuyo_Serial.read();
 6251              		.loc 25 18 0
 6252 000c 1B48     		ldr	r0, .L373
 6253 000e FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 6254              	.LVL339:
 6255              	.LBB157:
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****     if(check == '+'){
 6256              		.loc 25 19 0
 6257 0012 C0B2     		uxtb	r0, r0
 6258 0014 2B28     		cmp	r0, #43
 6259 0016 2BD1     		bne	.L363
 6260 0018 0024     		movs	r4, #0
 6261              	.LVL340:
 6262              	.L364:
 6263              	.LBB158:
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       for(int i=0;i<9;i++){
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       Hokuyo_str[i] = int(Hokuyo_Serial.read());
 6264              		.loc 25 21 0 discriminator 2
 6265 001a 1848     		ldr	r0, .L373
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       Hokuyo_str[i] -=48;
 6266              		.loc 25 22 0 discriminator 2
 6267 001c 184D     		ldr	r5, .L373+4
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       Hokuyo_str[i] = int(Hokuyo_Serial.read());
 6268              		.loc 25 21 0 discriminator 2
 6269 001e FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 6270              		.loc 25 22 0 discriminator 2
 6271 0022 3038     		subs	r0, r0, #48
 6272 0024 6051     		str	r0, [r4, r5]
 6273 0026 0434     		adds	r4, r4, #4
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       for(int i=0;i<9;i++){
 6274              		.loc 25 20 0 discriminator 2
 6275 0028 242C     		cmp	r4, #36
 6276 002a F6D1     		bne	.L364
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       for(int i=0;i<9;i++){
 6277              		.loc 25 20 0 is_stmt 0
 6278 002c 0024     		movs	r4, #0
 6279 002e 1CE0     		b	.L365
 6280              	.L366:
 6281              	.LBE158:
 6282              	.LBB159:
 6283              	.LBB160:
 6284              	.LBB161:
 6285              	.LBB162:
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** void Hokuyo_Read(){
 6286              		.loc 25 16 0 is_stmt 1 discriminator 2
 6287 0030 C3F10506 		rsb	r6, r3, #5
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       }
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       for(int i=0;i<3;i++){  //3 data points
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****         for(int j=0;j<3;j++){  //each data point encrypted in 3 bytes
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****           for(int k=0;k<6;k++){
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****             bit_array[k + 6*j] = bitRead(Hokuyo_str[3*i+j],(5-k));  //one data point
 6288              		.loc 25 27 0 discriminator 2
 6289 0034 50FA06F6 		asrs	r6, r0, r6
 6290 0038 06F00106 		and	r6, r6, #1
 6291 003c CE54     		strb	r6, [r1, r3]
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****           for(int k=0;k<6;k++){
 6292              		.loc 25 26 0 discriminator 2
 6293 003e 0133     		adds	r3, r3, #1
 6294              	.LVL341:
 6295 0040 062B     		cmp	r3, #6
 6296 0042 F5D1     		bne	.L366
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****           for(int k=0;k<6;k++){
 6297              		.loc 25 26 0 is_stmt 0
 6298 0044 0432     		adds	r2, r2, #4
 6299 0046 0631     		adds	r1, r1, #6
 6300              	.LBE162:
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****         for(int j=0;j<3;j++){  //each data point encrypted in 3 bytes
 6301              		.loc 25 25 0 is_stmt 1
 6302 0048 0C2A     		cmp	r2, #12
 6303 004a 02D0     		beq	.L367
 6304              	.LVL342:
 6305              	.L368:
 6306              	.LBB163:
 6307              		.loc 25 27 0 discriminator 1
 6308 004c A858     		ldr	r0, [r5, r2]
 6309 004e 0023     		movs	r3, #0
 6310 0050 EEE7     		b	.L366
 6311              	.LVL343:
 6312              	.L367:
 6313              	.LBE163:
 6314              	.LBE161:
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****           }
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****         }
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****         distance2D[i] = boolean_to_decimal(bit_array)/10;
 6315              		.loc 25 30 0
 6316 0052 0C48     		ldr	r0, .L373+8
 6317 0054 FFF7FEFF 		bl	_Z18boolean_to_decimalPb
 6318              	.LVL344:
 6319 0058 0A21     		movs	r1, #10
 6320 005a 0B4A     		ldr	r2, .L373+12
 6321 005c 90FBF1F3 		sdiv	r3, r0, r1
 6322 0060 A350     		str	r3, [r4, r2]
 6323 0062 0434     		adds	r4, r4, #4
 6324 0064 0C35     		adds	r5, r5, #12
 6325              	.LBE160:
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       for(int i=0;i<3;i++){  //3 data points
 6326              		.loc 25 24 0
 6327 0066 0C2C     		cmp	r4, #12
 6328 0068 02D0     		beq	.L363
 6329              	.LVL345:
 6330              	.L365:
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       for(int i=0;i<3;i++){  //3 data points
 6331              		.loc 25 24 0 is_stmt 0 discriminator 1
 6332 006a 0649     		ldr	r1, .L373+8
 6333              	.LBB166:
 6334              	.LBB165:
 6335              	.LBB164:
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****             bit_array[k + 6*j] = bitRead(Hokuyo_str[3*i+j],(5-k));  //one data point
 6336              		.loc 25 27 0 is_stmt 1 discriminator 1
 6337 006c 0022     		movs	r2, #0
 6338 006e EDE7     		b	.L368
 6339              	.LVL346:
 6340              	.L363:
 6341              	.LBE164:
 6342              	.LBE165:
 6343              	.LBE166:
 6344              	.LBE159:
 6345              	.LBE157:
 6346              	.LBE156:
 6347              	.LBE155:
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****       }      
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****     }
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   }
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   //output distance2D
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   if(Hokuyo_Serial.available()>=10){
 6348              		.loc 25 35 0
 6349 0070 0248     		ldr	r0, .L373
 6350 0072 FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 6351 0076 0928     		cmp	r0, #9
 6352 0078 C3D8     		bhi	.L369
 6353              	.LBE154:
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****     Hokuyo_Read();
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   }
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** }
 6354              		.loc 25 38 0
 6355 007a 70BD     		pop	{r4, r5, r6, pc}
 6356              	.L374:
 6357              		.align	2
 6358              	.L373:
 6359 007c 00000000 		.word	Serial2
 6360 0080 00000000 		.word	.LANCHOR82
 6361 0084 00000000 		.word	.LANCHOR83
 6362 0088 00000000 		.word	.LANCHOR84
 6363              		.cfi_endproc
 6364              	.LFE220:
 6366              		.section	.text._Z11kal_hokuyoXl,"ax",%progbits
 6367              		.align	1
 6368              		.global	_Z11kal_hokuyoXl
 6369              		.thumb
 6370              		.thumb_func
 6372              	_Z11kal_hokuyoXl:
 6373              	.LFB221:
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** 
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** 
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** float kal_hokuyoX(signed long distX){
 6374              		.loc 25 41 0
 6375              		.cfi_startproc
 6376              		@ args = 0, pretend = 0, frame = 0
 6377              		@ frame_needed = 0, uses_anonymous_args = 0
 6378              		@ link register save eliminated.
 6379              	.LVL347:
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kX = ((est_errX+qX)/(meas_errX + est_errX+qX));
 6380              		.loc 25 42 0
 6381 0000 144B     		ldr	r3, .L376
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   est_valX = (1-kX)*est_valX + kX*distX;
 6382              		.loc 25 43 0
 6383 0002 154A     		ldr	r2, .L376+4
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kX = ((est_errX+qX)/(meas_errX + est_errX+qX));
 6384              		.loc 25 42 0
 6385 0004 1549     		ldr	r1, .L376+8
 6386 0006 93ED007A 		flds	s14, [r3, #0]
 6387 000a B2EE042A 		fconsts	s4, #36
 6388 000e 77EE021A 		fadds	s3, s14, s4
 6389 0012 B1EE021A 		fconsts	s2, #18
 6390 0016 77EE010A 		fadds	s1, s14, s2
 6391 001a 71EE817A 		fadds	s15, s3, s2
 6392              		.loc 25 43 0
 6393 001e 05EE100A 		fmsr	s10, r0	@ int
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kX = ((est_errX+qX)/(meas_errX + est_errX+qX));
 6394              		.loc 25 42 0
 6395 0022 C0EEA77A 		fdivs	s15, s1, s15
 6396              		.loc 25 43 0
 6397 0026 B7EE000A 		fconsts	s0, #112
 6398 002a F8EEC55A 		fsitos	s11, s10
 6399 002e 70EE676A 		fsubs	s13, s0, s15
 6400 0032 92ED006A 		flds	s12, [r2, #0]
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kX = ((est_errX+qX)/(meas_errX + est_errX+qX));
 6401              		.loc 25 42 0
 6402 0036 C1ED007A 		fsts	s15, [r1, #0]
 6403              		.loc 25 43 0
 6404 003a 67EEA57A 		fmuls	s15, s15, s11
 6405 003e 46EE867A 		fmacs	s15, s13, s12
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   est_errX = (1-kX)*est_errX;
 6406              		.loc 25 44 0
 6407 0042 26EE877A 		fmuls	s14, s13, s14
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   est_valX = (1-kX)*est_valX + kX*distX;
 6408              		.loc 25 43 0
 6409 0046 C2ED007A 		fsts	s15, [r2, #0]
 6410              		.loc 25 44 0
 6411 004a 83ED007A 		fsts	s14, [r3, #0]
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   return(est_valX);
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****    
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** }
 6412              		.loc 25 47 0
 6413 004e 17EE900A 		fmrs	r0, s15
 6414              	.LVL348:
 6415 0052 7047     		bx	lr
 6416              	.L377:
 6417              		.align	2
 6418              	.L376:
 6419 0054 00000000 		.word	.LANCHOR85
 6420 0058 00000000 		.word	.LANCHOR87
 6421 005c 00000000 		.word	.LANCHOR86
 6422              		.cfi_endproc
 6423              	.LFE221:
 6425              		.section	.text._Z11kal_hokuyoYl,"ax",%progbits
 6426              		.align	1
 6427              		.global	_Z11kal_hokuyoYl
 6428              		.thumb
 6429              		.thumb_func
 6431              	_Z11kal_hokuyoYl:
 6432              	.LFB222:
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** float kal_hokuyoY(signed long distY){
 6433              		.loc 25 48 0
 6434              		.cfi_startproc
 6435              		@ args = 0, pretend = 0, frame = 0
 6436              		@ frame_needed = 0, uses_anonymous_args = 0
 6437              		@ link register save eliminated.
 6438              	.LVL349:
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kY = ((est_errY+qY)/(meas_errY + est_errY+qY));
 6439              		.loc 25 49 0
 6440 0000 144B     		ldr	r3, .L379
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   est_valY = (1-kY)*est_valY + kY*distY;
 6441              		.loc 25 50 0
 6442 0002 154A     		ldr	r2, .L379+4
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kY = ((est_errY+qY)/(meas_errY + est_errY+qY));
 6443              		.loc 25 49 0
 6444 0004 1549     		ldr	r1, .L379+8
 6445 0006 93ED007A 		flds	s14, [r3, #0]
 6446 000a B2EE042A 		fconsts	s4, #36
 6447 000e 77EE021A 		fadds	s3, s14, s4
 6448 0012 B1EE021A 		fconsts	s2, #18
 6449 0016 77EE010A 		fadds	s1, s14, s2
 6450 001a 71EE817A 		fadds	s15, s3, s2
 6451              		.loc 25 50 0
 6452 001e 05EE100A 		fmsr	s10, r0	@ int
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kY = ((est_errY+qY)/(meas_errY + est_errY+qY));
 6453              		.loc 25 49 0
 6454 0022 C0EEA77A 		fdivs	s15, s1, s15
 6455              		.loc 25 50 0
 6456 0026 B7EE000A 		fconsts	s0, #112
 6457 002a F8EEC55A 		fsitos	s11, s10
 6458 002e 70EE676A 		fsubs	s13, s0, s15
 6459 0032 92ED006A 		flds	s12, [r2, #0]
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   kY = ((est_errY+qY)/(meas_errY + est_errY+qY));
 6460              		.loc 25 49 0
 6461 0036 C1ED007A 		fsts	s15, [r1, #0]
 6462              		.loc 25 50 0
 6463 003a 67EEA57A 		fmuls	s15, s15, s11
 6464 003e 46EE867A 		fmacs	s15, s13, s12
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   est_errY = (1-kY)*est_errY;
 6465              		.loc 25 51 0
 6466 0042 26EE877A 		fmuls	s14, s13, s14
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   est_valY = (1-kY)*est_valY + kY*distY;
 6467              		.loc 25 50 0
 6468 0046 C2ED007A 		fsts	s15, [r2, #0]
 6469              		.loc 25 51 0
 6470 004a 83ED007A 		fsts	s14, [r3, #0]
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****   return(est_valY);
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h ****    
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/Hokuyo.h **** }
 6471              		.loc 25 54 0
 6472 004e 17EE900A 		fmrs	r0, s15
 6473              	.LVL350:
 6474 0052 7047     		bx	lr
 6475              	.L380:
 6476              		.align	2
 6477              	.L379:
 6478 0054 00000000 		.word	.LANCHOR88
 6479 0058 00000000 		.word	.LANCHOR90
 6480 005c 00000000 		.word	.LANCHOR89
 6481              		.cfi_endproc
 6482              	.LFE222:
 6484              		.section	.text._Z17applyMotorCommandv,"ax",%progbits
 6485              		.align	1
 6486              		.global	_Z17applyMotorCommandv
 6487              		.thumb
 6488              		.thumb_func
 6490              	_Z17applyMotorCommandv:
 6491              	.LFB223:
 6492              		.file 26 "../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h"
   1:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** /*
   2:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   www.AeroQuad.com
   4:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****  
   7:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   (at your option) any later version. 
  11:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****  
  12:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****  
  17:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** */
  20:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** 
  21:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_PLUS_MODE_H_
  22:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_PLUS_MODE_H_
  23:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** 
  24:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** /*  
  25:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****                  CW
  26:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****             
  27:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****            0....Front....0  
  28:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****            ......***......    
  29:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****       CCW  ......***......  CCW
  30:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****            ......***......    
  31:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****            0....Back.....0  
  32:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****       
  33:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****                  CW
  34:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** */     
  35:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** 
  36:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #include "FlightControlVariable.h"
  37:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** 
  38:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #ifdef OLD_MOTOR_NUMBERING  
  39:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define FRONT MOTOR1
  40:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define REAR  MOTOR2
  41:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define RIGHT MOTOR3
  42:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define LEFT  MOTOR4
  43:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #else
  44:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define FRONT MOTOR1
  45:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define RIGHT MOTOR2
  46:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define REAR  MOTOR3
  47:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   #define LEFT  MOTOR4
  48:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #endif
  49:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #define LASTMOTOR (MOTOR4+1)
  50:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** 
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** int motorMaxCommand[4] = {0,0,0,0};
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** int motorMinCommand[4] = {0,0,0,0};
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** int motorConfiguratorCommand[4] = {0,0,0,0};
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** #define MotorOffset_Roll 0
  55:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** void applyMotorCommand() {
 6493              		.loc 26 55 0
 6494              		.cfi_startproc
 6495              		@ args = 0, pretend = 0, frame = 0
 6496              		@ frame_needed = 0, uses_anonymous_args = 0
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[FRONT] = throttle - motorAxisCommandPitch - (YAW_DIRECTION * motorAxisCommandYaw);
 6497              		.loc 26 56 0
 6498 0000 0D4A     		ldr	r2, .L382
 6499 0002 0E49     		ldr	r1, .L382+4
 6500 0004 0E4B     		ldr	r3, .L382+8
 6501 0006 0968     		ldr	r1, [r1, #0]
 6502 0008 1068     		ldr	r0, [r2, #0]
 6503 000a 1A68     		ldr	r2, [r3, #0]
 6504 000c 0D4B     		ldr	r3, .L382+12
 6505 000e C0EB010C 		rsb	ip, r0, r1
  55:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** void applyMotorCommand() {
 6506              		.loc 26 55 0
 6507 0012 10B5     		push	{r4, lr}
 6508              	.LCFI66:
 6509              		.cfi_def_cfa_offset 8
 6510              		.cfi_offset 14, -4
 6511              		.cfi_offset 4, -8
 6512              		.loc 26 56 0
 6513 0014 C2EB0C04 		rsb	r4, r2, ip
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[REAR] =  throttle + motorAxisCommandPitch - (YAW_DIRECTION * motorAxisCommandYaw);
 6514              		.loc 26 57 0
 6515 0018 01EB000C 		add	ip, r1, r0
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[RIGHT] = throttle - motorAxisCommandRoll  + (YAW_DIRECTION * motorAxisCommandYaw) + 
 6516              		.loc 26 58 0
 6517 001c 0A48     		ldr	r0, .L382+16
  56:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[FRONT] = throttle - motorAxisCommandPitch - (YAW_DIRECTION * motorAxisCommandYaw);
 6518              		.loc 26 56 0
 6519 001e 1C60     		str	r4, [r3, #0]
 6520              		.loc 26 58 0
 6521 0020 0068     		ldr	r0, [r0, #0]
  57:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[REAR] =  throttle + motorAxisCommandPitch - (YAW_DIRECTION * motorAxisCommandYaw);
 6522              		.loc 26 57 0
 6523 0022 C2EB0C04 		rsb	r4, r2, ip
 6524 0026 9C60     		str	r4, [r3, #8]
 6525              		.loc 26 58 0
 6526 0028 0C1A     		subs	r4, r1, r0
  59:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[LEFT] =  throttle + motorAxisCommandRoll  + (YAW_DIRECTION * motorAxisCommandYaw) - 
 6527              		.loc 26 59 0
 6528 002a 0918     		adds	r1, r1, r0
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[RIGHT] = throttle - motorAxisCommandRoll  + (YAW_DIRECTION * motorAxisCommandYaw) + 
 6529              		.loc 26 58 0
 6530 002c A418     		adds	r4, r4, r2
 6531              		.loc 26 59 0
 6532 002e 8A18     		adds	r2, r1, r2
  58:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h ****   motorCommand[RIGHT] = throttle - motorAxisCommandRoll  + (YAW_DIRECTION * motorAxisCommandYaw) + 
 6533              		.loc 26 58 0
 6534 0030 5C60     		str	r4, [r3, #4]
 6535              		.loc 26 59 0
 6536 0032 DA60     		str	r2, [r3, #12]
  60:../Libraries/AQ_FlightControlProcessor/FlightControlQuadPlus.h **** }
 6537              		.loc 26 60 0
 6538 0034 10BD     		pop	{r4, pc}
 6539              	.L383:
 6540 0036 00BF     		.align	2
 6541              	.L382:
 6542 0038 00000000 		.word	.LANCHOR92
 6543 003c 00000000 		.word	.LANCHOR91
 6544 0040 00000000 		.word	.LANCHOR93
 6545 0044 00000000 		.word	.LANCHOR56
 6546 0048 00000000 		.word	.LANCHOR94
 6547              		.cfi_endproc
 6548              	.LFE223:
 6550              		.section	.text._Z9movingAvgi,"ax",%progbits
 6551              		.align	1
 6552              		.global	_Z9movingAvgi
 6553              		.thumb
 6554              		.thumb_func
 6556              	_Z9movingAvgi:
 6557              	.LFB224:
 6558              		.file 27 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** /////////////////////////// calculateFlightError /////////////////////////////
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** #ifndef _AQ_ALTITUDE_CONTROL_PROCESSOR_H_
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** #define _AQ_ALTITUDE_CONTROL_PROCESSOR_H_
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** #define INVALID_THROTTLE_CORRECTION -1000
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** #define ALTITUDE_BUMP_SPEED 0.01
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** #define G_Bias 17
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** //************************************************************************************
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** int movingAvg( int senValue)
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** {
 6559              		.loc 27 39 0
 6560              		.cfi_startproc
 6561              		@ args = 0, pretend = 0, frame = 0
 6562              		@ frame_needed = 0, uses_anonymous_args = 0
 6563              	.LVL351:
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_Sum -=alt_buffer[alt_buffer_pointer];
 6564              		.loc 27 40 0
 6565 0000 124B     		ldr	r3, .L386
 6566 0002 1349     		ldr	r1, .L386+4
 6567 0004 1A68     		ldr	r2, [r3, #0]
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** {
 6568              		.loc 27 39 0
 6569 0006 10B5     		push	{r4, lr}
 6570              	.LCFI67:
 6571              		.cfi_def_cfa_offset 8
 6572              		.cfi_offset 14, -4
 6573              		.cfi_offset 4, -8
 6574              		.loc 27 40 0
 6575 0008 124C     		ldr	r4, .L386+8
 6576 000a 04EB8204 		add	r4, r4, r2, lsl #2
 6577 000e D1ED000A 		flds	s1, [r1, #0]
 6578 0012 94ED000A 		flds	s0, [r4, #0]
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_buffer[alt_buffer_pointer] = senValue;
 6579              		.loc 27 41 0
 6580 0016 06EE900A 		fmsr	s13, r0	@ int
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_Sum -=alt_buffer[alt_buffer_pointer];
 6581              		.loc 27 40 0
 6582 001a 70EEC07A 		fsubs	s15, s1, s0
 6583              		.loc 27 41 0
 6584 001e B8EEE67A 		fsitos	s14, s13
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_Sum +=alt_buffer[alt_buffer_pointer];
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_buffer_pointer++;
 6585              		.loc 27 43 0
 6586 0022 0132     		adds	r2, r2, #1
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_Sum +=alt_buffer[alt_buffer_pointer];
 6587              		.loc 27 42 0
 6588 0024 77EE877A 		fadds	s15, s15, s14
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   if(alt_buffer_pointer>alt_buffer_size-1)
 6589              		.loc 27 44 0
 6590 0028 312A     		cmp	r2, #49
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_buffer[alt_buffer_pointer] = senValue;
 6591              		.loc 27 41 0
 6592 002a 84ED007A 		fsts	s14, [r4, #0]
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_Sum +=alt_buffer[alt_buffer_pointer];
 6593              		.loc 27 42 0
 6594 002e C1ED007A 		fsts	s15, [r1, #0]
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   alt_buffer_pointer++;
 6595              		.loc 27 43 0
 6596 0032 1A60     		str	r2, [r3, #0]
 6597              		.loc 27 44 0
 6598 0034 01DD     		ble	.L385
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   {
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     alt_buffer_pointer=0;
 6599              		.loc 27 46 0
 6600 0036 0020     		movs	r0, #0
 6601              	.LVL352:
 6602 0038 1860     		str	r0, [r3, #0]
 6603              	.L385:
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   }
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   return(alt_Sum/(alt_buffer_size));
 6604              		.loc 27 48 0
 6605 003a DFED071A 		flds	s3, .L386+12
 6606 003e C7EEA17A 		fdivs	s15, s15, s3
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** }
 6607              		.loc 27 51 0
 6608 0042 BDEEE71A 		ftosizs	s2, s15
 6609 0046 11EE100A 		fmrs	r0, s2	@ int
 6610 004a 10BD     		pop	{r4, pc}
 6611              	.L387:
 6612              		.align	2
 6613              	.L386:
 6614 004c 00000000 		.word	.LANCHOR95
 6615 0050 00000000 		.word	.LANCHOR96
 6616 0054 00000000 		.word	.LANCHOR97
 6617 0058 00004842 		.word	1112014848
 6618              		.cfi_endproc
 6619              	.LFE224:
 6621              		.section	.text._Z19processAltitudeHoldv,"ax",%progbits
 6622              		.align	1
 6623              		.global	_Z19processAltitudeHoldv
 6624              		.thumb
 6625              		.thumb_func
 6627              	_Z19processAltitudeHoldv:
 6628              	.LFB225:
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** //***************************************************************************************
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** /**
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  * processAltitudeHold
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  * 
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  * This function is responsible to process the throttle correction 
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  * to keep the current altitude if selected by the user 
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****  */
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** void processAltitudeHold()
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** {
 6629              		.loc 27 62 0
 6630              		.cfi_startproc
 6631              		@ args = 0, pretend = 0, frame = 0
 6632              		@ frame_needed = 0, uses_anonymous_args = 0
 6633 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 6634              	.LCFI68:
 6635              		.cfi_def_cfa_offset 32
 6636              		.cfi_offset 14, -4
 6637              		.cfi_offset 9, -8
 6638              		.cfi_offset 8, -12
 6639              		.cfi_offset 7, -16
 6640              		.cfi_offset 6, -20
 6641              		.cfi_offset 5, -24
 6642              		.cfi_offset 4, -28
 6643              		.cfi_offset 3, -32
 6644 0004 2DED028B 		fstmfdd	sp!, {d8}
 6645              	.LCFI69:
 6646              		.cfi_def_cfa_offset 40
 6647              		.cfi_offset 80, -40
 6648              	.LBB167:
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   // ****************************** Altitude Adjust *************************
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   // Thanks to Honk for his work with altitude hold
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   // http://aeroquad.com/showthread.php?792-Problems-with-BMP085-I2C-barometer
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   // Thanks to Sherbakov for his work in Z Axis dampening
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   // http://aeroquad.com/showthread.php?359-Stable-flight-logic...&p=10325&viewfull=1#post10325
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   //int temp_throttle, errorAltitude;
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   //errorAltitude = baroAltitudeToHoldTarget - estimatedAltitude;
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   if (altitudeHoldState == ON) {
 6649              		.loc 27 71 0
 6650 0008 484B     		ldr	r3, .L401
 6651 000a 494E     		ldr	r6, .L401+4
 6652 000c 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 6653 000e 494D     		ldr	r5, .L401+8
 6654 0010 012A     		cmp	r2, #1
 6655 0012 9946     		mov	r9, r3
 6656 0014 40F08480 		bne	.L389
 6657              	.LVL353:
 6658              	.LBB168:
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     int altitudeHoldThrottleCorrection = INVALID_THROTTLE_CORRECTION;
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     // computer altitude error!
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     #if defined AltitudeHoldRangeFinder
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) {
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         if (sonarAltitudeToHoldTarget == INVALID_RANGE) {
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         }
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(sonarAltitudeToHoldTarget, rangeFinderRange[ALTI
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, minThrottleAdjus
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     #endif
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     #if defined AltitudeLidar
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       int errorAltitude = (baroAltitudeToHoldTarget - estimatedAltitude);
 6659              		.loc 27 85 0
 6660 0018 474C     		ldr	r4, .L401+12
 6661 001a 484F     		ldr	r7, .L401+16
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, estimatedAltitude, &PID[
 6662              		.loc 27 86 0
 6663 001c 484A     		ldr	r2, .L401+20
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       int errorAltitude = (baroAltitudeToHoldTarget - estimatedAltitude);
 6664              		.loc 27 85 0
 6665 001e D4ED008A 		flds	s17, [r4, #0]
 6666 0022 97ED008A 		flds	s16, [r7, #0]
 6667              	.LVL354:
 6668              		.loc 27 86 0
 6669 0026 18EE900A 		fmrs	r0, s17
 6670 002a 18EE101A 		fmrs	r1, s16
 6671 002e FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6672              	.LVL355:
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       int errorAltitude = (baroAltitudeToHoldTarget - estimatedAltitude);
 6673              		.loc 27 85 0
 6674 0032 38EEC88A 		fsubs	s16, s17, s16
 6675              	.LVL356:
 6676              		.loc 27 86 0
 6677 0036 07EE900A 		fmsr	s15, r0
 6678              	.LVL357:
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       int errorAltitude = (baroAltitudeToHoldTarget - estimatedAltitude);
 6679              		.loc 27 85 0
 6680 003a BDEEC88A 		ftosizs	s16, s16
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if((errorAltitude<0)&&(-10<errorAltitude)){
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection=0;
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if(zDirection ==0){  // down motion
 6681              		.loc 27 90 0
 6682 003e 4149     		ldr	r1, .L401+24
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       int errorAltitude = (baroAltitudeToHoldTarget - estimatedAltitude);
 6683              		.loc 27 85 0
 6684 0040 18EE103A 		fmrs	r3, s16	@ int
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if((errorAltitude<0)&&(-10<errorAltitude)){
 6685              		.loc 27 87 0
 6686 0044 0933     		adds	r3, r3, #9
 6687 0046 082B     		cmp	r3, #8
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, estimatedAltitude, &PID[
 6688              		.loc 27 86 0
 6689 0048 88BF     		it	hi
 6690 004a FDEEE77A 		ftosizshi	s15, s15
 6691              		.loc 27 90 0
 6692 004e 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 6693              	.LVL358:
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, estimatedAltitude, &PID[
 6694              		.loc 27 86 0
 6695 0050 8CBF     		ite	hi
 6696 0052 17EE903A 		fmrshi	r3, s15	@ int
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection=0;
 6697              		.loc 27 88 0
 6698 0056 0023     		movls	r3, #0
 6699              	.LVL359:
 6700              		.loc 27 90 0
 6701 0058 00B9     		cbnz	r0, .L391
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection +=G_Bias;
 6702              		.loc 27 91 0
 6703 005a 1133     		adds	r3, r3, #17
 6704              	.LVL360:
 6705              	.L391:
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     /*  else(zDirection ==1){  // up motion
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection -=G_Bias;
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }   */    
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       //altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection,minThrottleAdjust
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, -50, 50);
 6706              		.loc 27 97 0
 6707 005c 322B     		cmp	r3, #50
 6708 005e A8BF     		it	ge
 6709 0060 3223     		movge	r3, #50
 6710              	.LVL361:
 6711 0062 6FF03107 		mvn	r7, #49
 6712 0066 BB42     		cmp	r3, r7
 6713 0068 B8BF     		it	lt
 6714 006a 3B46     		movlt	r3, r7
 6715              	.LVL362:
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrectionGLOBAL = altitudeHoldThrottleCorrection;  
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       LidarHoldThrottle = altitudeHoldThrottle + altitudeHoldThrottleCorrection;
 6716              		.loc 27 99 0
 6717 006c 364F     		ldr	r7, .L401+28
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrectionGLOBAL = altitudeHoldThrottleCorrection;  
 6718              		.loc 27 98 0
 6719 006e 3749     		ldr	r1, .L401+32
 6720              		.loc 27 99 0
 6721 0070 3868     		ldr	r0, [r7, #0]
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldThrottleCorrectionGLOBAL = altitudeHoldThrottleCorrection;  
 6722              		.loc 27 98 0
 6723 0072 0B60     		str	r3, [r1, #0]
 6724              		.loc 27 99 0
 6725 0074 C218     		adds	r2, r0, r3
 6726 0076 DFF8F480 		ldr	r8, .L401+64
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       //LidarHoldThrottle = constrain(LidarHoldThrottle, altitudeHoldThrottle-50, altitudeHoldThrot
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****    
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****    #elif defined AltitudeHoldBaro && !defined AltitudeLidar
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if (altitudeHoldThrottleCorrection == INVALID_THROTTLE_CORRECTION) {
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = updatePID(baroAltitudeToHoldTarget, getBaroAltitude(), &PI
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         altitudeHoldThrottleCorrection = constrain(altitudeHoldThrottleCorrection, minThrottleAdjus
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     #endif        
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     if (altitudeHoldThrottleCorrection == INVALID_THROTTLE_CORRECTION) {
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       return;
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     }
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     // ZDAMPENING COMPUTATIONS
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       float zDampeningThrottleCorrection = -updatePID(0.0, estimatedZVelocity, &PID[ZDAMPENING_PID_
 6727              		.loc 27 116 0
 6728 007a 354B     		ldr	r3, .L401+36
 6729              	.LVL363:
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       LidarHoldThrottle = altitudeHoldThrottle + altitudeHoldThrottleCorrection;
 6730              		.loc 27 99 0
 6731 007c C8F80020 		str	r2, [r8, #0]
 6732              		.loc 27 116 0
 6733 0080 0020     		movs	r0, #0
 6734 0082 1968     		ldr	r1, [r3, #0]	@ float
 6735 0084 334A     		ldr	r2, .L401+40
 6736 0086 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6737              	.LVL364:
 6738 008a 06EE900A 		fmsr	s13, r0
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       zDampeningThrottleCorrection = constrain(zDampeningThrottleCorrection, -50, 50);
 6739              		.loc 27 117 0
 6740 008e 9FED327A 		flds	s14, .L401+44
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       float zDampeningThrottleCorrection = -updatePID(0.0, estimatedZVelocity, &PID[ZDAMPENING_PID_
 6741              		.loc 27 116 0
 6742 0092 F1EE667A 		fnegs	s15, s13
 6743              	.LVL365:
 6744              		.loc 27 117 0
 6745 0096 F4EEC77A 		fcmpes	s15, s14
 6746 009a F1EE10FA 		fmstat
 6747 009e 4046     		mov	r0, r8
 6748 00a0 09D4     		bmi	.L399
 6749              		.loc 27 117 0 is_stmt 0 discriminator 2
 6750 00a2 9FED2E7A 		flds	s14, .L401+48
 6751 00a6 F4EE477A 		fcmps	s15, s14
 6752 00aa F1EE10FA 		fmstat
 6753 00ae C8BF     		it	gt
 6754 00b0 F0EE477A 		fcpysgt	s15, s14
 6755              	.LVL366:
 6756 00b4 01E0     		b	.L392
 6757              	.LVL367:
 6758              	.L399:
 6759              		.loc 27 117 0
 6760 00b6 F0EE477A 		fcpys	s15, s14
 6761              	.LVL368:
 6762              	.L392:
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     #endif
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     if (abs(altitudeHoldThrottle - receiverCommand[THROTTLE]) > altitudeHoldPanicStickMovement) {
 6763              		.loc 27 120 0 is_stmt 1 discriminator 6
 6764 00ba 3A68     		ldr	r2, [r7, #0]
 6765 00bc F368     		ldr	r3, [r6, #12]
 6766 00be 2849     		ldr	r1, .L401+52
 6767 00c0 D61A     		subs	r6, r2, r3
 6768 00c2 0968     		ldr	r1, [r1, #0]
 6769 00c4 002E     		cmp	r6, #0
 6770 00c6 B8BF     		it	lt
 6771 00c8 7642     		rsblt	r6, r6, #0
 6772 00ca 8E42     		cmp	r6, r1
 6773 00cc 03DD     		ble	.L394
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       altitudeHoldState = ALTPANIC; // too rapid of stick movement so PANIC out of ALTHOLD
 6774              		.loc 27 121 0
 6775 00ce 0223     		movs	r3, #2
 6776 00d0 89F80030 		strb	r3, [r9, #0]
 6777 00d4 18E0     		b	.L395
 6778              	.L394:
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     } 
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     else {
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if (receiverCommand[THROTTLE] > (altitudeHoldThrottle + altitudeHoldBump)) { // AKA changed t
 6779              		.loc 27 125 0
 6780 00d6 234E     		ldr	r6, .L401+56
 6781 00d8 3168     		ldr	r1, [r6, #0]
 6782 00da 5618     		adds	r6, r2, r1
 6783 00dc B342     		cmp	r3, r6
 6784 00de 07DD     		ble	.L396
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #if defined AltitudeHoldBaro
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           baroAltitudeToHoldTarget += ALTITUDE_BUMP_SPEED;
 6785              		.loc 27 127 0
 6786 00e0 94ED001A 		flds	s2, [r4, #0]
 6787 00e4 DFED200A 		flds	s1, .L401+60
 6788 00e8 31EE200A 		fadds	s0, s2, s1
 6789 00ec 84ED000A 		fsts	s0, [r4, #0]
 6790              	.L396:
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #endif
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #if defined AltitudeHoldRangeFinder
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           float newalt = sonarAltitudeToHoldTarget + ALTITUDE_BUMP_SPEED;
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           if (isOnRangerRange(newalt)) {
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****             sonarAltitudeToHoldTarget = newalt;
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           }
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #endif
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       if (receiverCommand[THROTTLE] < (altitudeHoldThrottle - altitudeHoldBump)) { // AKA change to
 6791              		.loc 27 137 0
 6792 00f0 C1EB020C 		rsb	ip, r1, r2
 6793 00f4 6345     		cmp	r3, ip
 6794 00f6 07DA     		bge	.L395
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #if defined AltitudeHoldBaro
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           baroAltitudeToHoldTarget -= ALTITUDE_BUMP_SPEED;
 6795              		.loc 27 139 0
 6796 00f8 D4ED002A 		flds	s5, [r4, #0]
 6797 00fc 9FED1A2A 		flds	s4, .L401+60
 6798 0100 72EEC21A 		fsubs	s3, s5, s4
 6799 0104 C4ED001A 		fsts	s3, [r4, #0]
 6800              	.L395:
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #endif
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #if defined AltitudeHoldRangeFinder
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           float newalt = sonarAltitudeToHoldTarget - ALTITUDE_BUMP_SPEED;
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           if (isOnRangerRange(newalt)) {
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****             sonarAltitudeToHoldTarget = newalt;
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****           }
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****         #endif
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****       }
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     }
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 	
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 	#if defined AltitudeLidar
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 	     throttle = LidarHoldThrottle + zDampeningThrottleCorrection;
 6801              		.loc 27 151 0
 6802 0108 0268     		ldr	r2, [r0, #0]
 6803 010a 04EE902A 		fmsr	s9, r2	@ int
 6804 010e B8EEE44A 		fsitos	s8, s9
 6805 0112 74EE273A 		fadds	s7, s8, s15
 6806 0116 BDEEE33A 		ftosizs	s6, s7
 6807 011a 85ED003A 		fsts	s6, [r5, #0]	@ int
 6808 011e 01E0     		b	.L388
 6809              	.L389:
 6810              	.LBE168:
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 	#else
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****             throttle = altitudeHoldThrottle + altitudeHoldThrottleCorrection + zDampeningThrottleCo
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** 	#endif
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   }
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   else {
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****     throttle = receiverCommand[THROTTLE];
 6811              		.loc 27 157 0
 6812 0120 F068     		ldr	r0, [r6, #12]
 6813 0122 2860     		str	r0, [r5, #0]
 6814              	.L388:
 6815              	.LBE167:
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h ****   }
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AltitudeControlProcessor.h **** }
 6816              		.loc 27 159 0
 6817 0124 BDEC028B 		fldmfdd	sp!, {d8}
 6818 0128 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 6819              	.L402:
 6820              		.align	2
 6821              	.L401:
 6822 012c 00000000 		.word	.LANCHOR98
 6823 0130 00000000 		.word	.LANCHOR1
 6824 0134 00000000 		.word	.LANCHOR91
 6825 0138 00000000 		.word	.LANCHOR99
 6826 013c 00000000 		.word	.LANCHOR100
 6827 0140 E0000000 		.word	.LANCHOR9+224
 6828 0144 00000000 		.word	.LANCHOR101
 6829 0148 00000000 		.word	.LANCHOR104
 6830 014c 00000000 		.word	.LANCHOR102
 6831 0150 00000000 		.word	.LANCHOR105
 6832 0154 FC000000 		.word	.LANCHOR9+252
 6833 0158 000048C2 		.word	-1035468800
 6834 015c 00004842 		.word	1112014848
 6835 0160 00000000 		.word	.LANCHOR106
 6836 0164 00000000 		.word	.LANCHOR107
 6837 0168 0AD7233C 		.word	1008981770
 6838 016c 00000000 		.word	.LANCHOR103
 6839              		.cfi_endproc
 6840              	.LFE225:
 6842              		.section	.text._Z17processHokuyoHoldv,"ax",%progbits
 6843              		.align	1
 6844              		.global	_Z17processHokuyoHoldv
 6845              		.thumb
 6846              		.thumb_func
 6848              	_Z17processHokuyoHoldv:
 6849              	.LFB226:
 6850              		.file 28 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****  
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****  
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** /////////////////////////// calculateFlightError /////////////////////////////
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** //////////////////////////////////////////////////////////////////////////////
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** 
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** #ifndef _AQ_POSITION_CONTROL_PROCESSOR_H_
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** #define _AQ_POSITION_CONTROL_PROCESSOR_H_
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** 
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** 
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** /* /// do not uncomment
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   motorCommand[FRONT] = throttle - motorAxisCommandPitch  - (YAW_DIRECTION * motorAxisCommandYaw);
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   motorCommand[REAR] =  throttle + motorAxisCommandPitch  - (YAW_DIRECTION * motorAxisCommandYaw);
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   motorCommand[RIGHT] = throttle - motorAxisCommandRoll   + (YAW_DIRECTION * motorAxisCommandYaw) +
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   motorCommand[LEFT] =  throttle + motorAxisCommandRoll   + (YAW_DIRECTION * motorAxisCommandYaw) -
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** */
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** 
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** 
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** #if defined Lidar2D
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** #define INVALID_THROTTLE_CORRECTION_HOKUYO -1000
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** void processHokuyoHold()
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h **** {
 6851              		.loc 28 42 0
 6852              		.cfi_startproc
 6853              		@ args = 0, pretend = 0, frame = 0
 6854              		@ frame_needed = 0, uses_anonymous_args = 0
 6855 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 6856              	.LCFI70:
 6857              		.cfi_def_cfa_offset 24
 6858              		.cfi_offset 14, -4
 6859              		.cfi_offset 7, -8
 6860              		.cfi_offset 6, -12
 6861              		.cfi_offset 5, -16
 6862              		.cfi_offset 4, -20
 6863              		.cfi_offset 3, -24
 6864              	.LBB169:
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   if (HokuyoHoldState == ON) {
 6865              		.loc 28 43 0
 6866 0002 4C48     		ldr	r0, .L417
 6867 0004 4C4D     		ldr	r5, .L417+4
 6868 0006 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 6869 0008 4C4C     		ldr	r4, .L417+8
 6870 000a 012B     		cmp	r3, #1
 6871 000c 40F08D80 		bne	.L404
 6872              	.LVL369:
 6873              	.LBB170:
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     int temphokuyoHoldThrottleCorrection_X = INVALID_THROTTLE_CORRECTION_HOKUYO;
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     int temphokuyoHoldThrottleCorrection_Y = INVALID_THROTTLE_CORRECTION_HOKUYO;
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     #if defined Hold_X  //roll
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_X = HokuyoPositionToHoldTarget_X - distance2D[plus_X];
 6874              		.loc 28 47 0
 6875 0010 4B4F     		ldr	r7, .L417+12
 6876 0012 4C4A     		ldr	r2, .L417+16
 6877 0014 D7ED001A 		flds	s3, [r7, #0]	@ int
 6878 0018 92ED007A 		flds	s14, [r2, #0]
 6879 001c F8EEE10A 		fsitos	s1, s3
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_X = updatePID(HokuyoPositionToHoldTarget_X, distance2D[plus_
 6880              		.loc 28 48 0
 6881 0020 17EE100A 		fmrs	r0, s14
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_X = HokuyoPositionToHoldTarget_X - distance2D[plus_X];
 6882              		.loc 28 47 0
 6883 0024 37EE601A 		fsubs	s2, s14, s1
 6884              		.loc 28 48 0
 6885 0028 10EE901A 		fmrs	r1, s1
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_X = HokuyoPositionToHoldTarget_X - distance2D[plus_X];
 6886              		.loc 28 47 0
 6887 002c FDEEC16A 		ftosizs	s13, s2
 6888              		.loc 28 48 0
 6889 0030 454A     		ldr	r2, .L417+20
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_X = HokuyoPositionToHoldTarget_X - distance2D[plus_X];
 6890              		.loc 28 47 0
 6891 0032 16EE906A 		fmrs	r6, s13	@ int
 6892              	.LVL370:
 6893              		.loc 28 48 0
 6894 0036 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6895              	.LVL371:
 6896 003a 00EE100A 		fmsr	s0, r0
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_XGLOBAL = temphokuyoHoldThrottleCorrection_X;
 6897              		.loc 28 49 0
 6898 003e 4349     		ldr	r1, .L417+24
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_X = updatePID(HokuyoPositionToHoldTarget_X, distance2D[plus_
 6899              		.loc 28 48 0
 6900 0040 FDEEC07A 		ftosizs	s15, s0
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_X = temphokuyoHoldThrottleCorrection_X;
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       if(((error_X<0)&&(RollVelocityDirection ==0)) || ((error_X>0)&&(RollVelocityDirection ==1))){
 6901              		.loc 28 51 0
 6902 0044 002E     		cmp	r6, #0
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_X = updatePID(HokuyoPositionToHoldTarget_X, distance2D[plus_
 6903              		.loc 28 48 0
 6904 0046 17EE900A 		fmrs	r0, s15	@ int
 6905              	.LVL372:
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_XGLOBAL = temphokuyoHoldThrottleCorrection_X;
 6906              		.loc 28 49 0
 6907 004a C1ED007A 		fsts	s15, [r1, #0]	@ int
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_X = temphokuyoHoldThrottleCorrection_X;
 6908              		.loc 28 50 0
 6909 004e C5ED007A 		fsts	s15, [r5, #0]	@ int
 6910 0052 BE46     		mov	lr, r7
 6911              		.loc 28 51 0
 6912 0054 03DA     		bge	.L405
 6913              		.loc 28 51 0 is_stmt 0 discriminator 1
 6914 0056 3E4F     		ldr	r7, .L417+28
 6915 0058 3B68     		ldr	r3, [r7, #0]
 6916 005a 2BB1     		cbz	r3, .L406
 6917 005c 08E0     		b	.L407
 6918              	.L405:
 6919              		.loc 28 51 0 discriminator 2
 6920 005e 07D0     		beq	.L407
 6921              		.loc 28 51 0 discriminator 3
 6922 0060 3B4A     		ldr	r2, .L417+28
 6923 0062 1168     		ldr	r1, [r2, #0]
 6924 0064 0129     		cmp	r1, #1
 6925 0066 03D1     		bne	.L407
 6926              	.L406:
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****         hokuyoHoldThrottleCorrection_X = temphokuyoHoldThrottleCorrection_X/3;
 6927              		.loc 28 52 0 is_stmt 1
 6928 0068 0327     		movs	r7, #3
 6929 006a 90FBF7F3 		sdiv	r3, r0, r7
 6930 006e 2B60     		str	r3, [r5, #0]
 6931              	.L407:
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       }
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_X = constrain(hokuyoHoldThrottleCorrection_X, minThrottleAdjust,
 6932              		.loc 28 54 0
 6933 0070 3849     		ldr	r1, .L417+32
 6934 0072 2A68     		ldr	r2, [r5, #0]
 6935 0074 0B68     		ldr	r3, [r1, #0]
 6936 0076 9A42     		cmp	r2, r3
 6937 0078 0F46     		mov	r7, r1
 6938 007a 04DB     		blt	.L408
 6939              		.loc 28 54 0 is_stmt 0 discriminator 2
 6940 007c 364B     		ldr	r3, .L417+36
 6941 007e 1B68     		ldr	r3, [r3, #0]
 6942 0080 9A42     		cmp	r2, r3
 6943 0082 B8BF     		it	lt
 6944 0084 1346     		movlt	r3, r2
 6945              	.L408:
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       if((-10<error_X)&&(error_X<10)){
 6946              		.loc 28 55 0 is_stmt 1 discriminator 6
 6947 0086 0936     		adds	r6, r6, #9
 6948              	.LVL373:
 6949 0088 122E     		cmp	r6, #18
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_X = constrain(hokuyoHoldThrottleCorrection_X, minThrottleAdjust,
 6950              		.loc 28 54 0 discriminator 6
 6951 008a 2B60     		str	r3, [r5, #0]
 6952              		.loc 28 55 0 discriminator 6
 6953 008c 02D8     		bhi	.L409
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****         hokuyoHoldThrottleCorrection_X = 0;
 6954              		.loc 28 56 0
 6955 008e 2A49     		ldr	r1, .L417+4
 6956 0090 0022     		movs	r2, #0
 6957 0092 0A60     		str	r2, [r1, #0]
 6958              	.L409:
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       }      
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     #endif
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     if (temphokuyoHoldThrottleCorrection_X == INVALID_THROTTLE_CORRECTION_HOKUYO) {
 6959              		.loc 28 59 0
 6960 0094 10F57A7F 		cmn	r0, #1000
 6961 0098 01D1     		bne	.L410
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****         hokuyoHoldThrottleCorrection_X =0;
 6962              		.loc 28 60 0
 6963 009a 0020     		movs	r0, #0
 6964 009c 2860     		str	r0, [r5, #0]
 6965              	.L410:
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     }
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     #if defined Hold_Y  //pitch
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_Y = HokuyoPositionToHoldTarget_Y - distance2D[plus_Y];
 6966              		.loc 28 63 0
 6967 009e DEF80450 		ldr	r5, [lr, #4]
 6968 00a2 2E4A     		ldr	r2, .L417+40
 6969 00a4 05EE105A 		fmsr	s10, r5	@ int
 6970 00a8 D2ED003A 		flds	s7, [r2, #0]
 6971 00ac B8EEC53A 		fsitos	s6, s10
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_Y = updatePID(HokuyoPositionToHoldTarget_Y, distance2D[plus_
 6972              		.loc 28 64 0
 6973 00b0 13EE900A 		fmrs	r0, s7
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_Y = HokuyoPositionToHoldTarget_Y - distance2D[plus_Y];
 6974              		.loc 28 63 0
 6975 00b4 73EEC34A 		fsubs	s9, s7, s6
 6976              		.loc 28 64 0
 6977 00b8 13EE101A 		fmrs	r1, s6
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_Y = HokuyoPositionToHoldTarget_Y - distance2D[plus_Y];
 6978              		.loc 28 63 0
 6979 00bc BDEEE44A 		ftosizs	s8, s9
 6980              		.loc 28 64 0
 6981 00c0 274A     		ldr	r2, .L417+44
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       int error_Y = HokuyoPositionToHoldTarget_Y - distance2D[plus_Y];
 6982              		.loc 28 63 0
 6983 00c2 14EE105A 		fmrs	r5, s8	@ int
 6984              	.LVL374:
 6985              		.loc 28 64 0
 6986 00c6 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 6987              	.LVL375:
 6988 00ca 02EE900A 		fmsr	s5, r0
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_YGLOBAL = temphokuyoHoldThrottleCorrection_Y;
 6989              		.loc 28 65 0
 6990 00ce 254B     		ldr	r3, .L417+48
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_Y = updatePID(HokuyoPositionToHoldTarget_Y, distance2D[plus_
 6991              		.loc 28 64 0
 6992 00d0 BDEEE22A 		ftosizs	s4, s5
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_Y = temphokuyoHoldThrottleCorrection_Y;
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       if(((error_Y<0)&&(PitchVelocityDirection ==0)) || ((error_Y>0)&&(PitchVelocityDirection ==1))
 6993              		.loc 28 67 0
 6994 00d4 002D     		cmp	r5, #0
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_Y = updatePID(HokuyoPositionToHoldTarget_Y, distance2D[plus_
 6995              		.loc 28 64 0
 6996 00d6 12EE100A 		fmrs	r0, s4	@ int
 6997              	.LVL376:
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       temphokuyoHoldThrottleCorrection_YGLOBAL = temphokuyoHoldThrottleCorrection_Y;
 6998              		.loc 28 65 0
 6999 00da 83ED002A 		fsts	s4, [r3, #0]	@ int
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_Y = temphokuyoHoldThrottleCorrection_Y;
 7000              		.loc 28 66 0
 7001 00de 84ED002A 		fsts	s4, [r4, #0]	@ int
 7002              		.loc 28 67 0
 7003 00e2 03DA     		bge	.L411
 7004              		.loc 28 67 0 is_stmt 0 discriminator 1
 7005 00e4 204B     		ldr	r3, .L417+52
 7006 00e6 1968     		ldr	r1, [r3, #0]
 7007 00e8 29B1     		cbz	r1, .L412
 7008 00ea 08E0     		b	.L413
 7009              	.L411:
 7010              		.loc 28 67 0 discriminator 2
 7011 00ec 07D0     		beq	.L413
 7012              		.loc 28 67 0 discriminator 3
 7013 00ee 1E49     		ldr	r1, .L417+52
 7014 00f0 0A68     		ldr	r2, [r1, #0]
 7015 00f2 012A     		cmp	r2, #1
 7016 00f4 03D1     		bne	.L413
 7017              	.L412:
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****         hokuyoHoldThrottleCorrection_Y = temphokuyoHoldThrottleCorrection_Y/3;
 7018              		.loc 28 68 0 is_stmt 1
 7019 00f6 0322     		movs	r2, #3
 7020 00f8 90FBF2F3 		sdiv	r3, r0, r2
 7021 00fc 2360     		str	r3, [r4, #0]
 7022              	.L413:
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       }      
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_Y = constrain(hokuyoHoldThrottleCorrection_Y, minThrottleAdjust,
 7023              		.loc 28 70 0
 7024 00fe 2268     		ldr	r2, [r4, #0]
 7025 0100 3B68     		ldr	r3, [r7, #0]
 7026 0102 9A42     		cmp	r2, r3
 7027 0104 04DB     		blt	.L414
 7028              		.loc 28 70 0 is_stmt 0 discriminator 2
 7029 0106 1449     		ldr	r1, .L417+36
 7030 0108 0B68     		ldr	r3, [r1, #0]
 7031 010a 9A42     		cmp	r2, r3
 7032 010c B8BF     		it	lt
 7033 010e 1346     		movlt	r3, r2
 7034              	.L414:
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       if((-10<error_Y)&&(error_Y<10)){
 7035              		.loc 28 71 0 is_stmt 1 discriminator 6
 7036 0110 0935     		adds	r5, r5, #9
 7037              	.LVL377:
 7038 0112 122D     		cmp	r5, #18
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       hokuyoHoldThrottleCorrection_Y = constrain(hokuyoHoldThrottleCorrection_Y, minThrottleAdjust,
 7039              		.loc 28 70 0 discriminator 6
 7040 0114 2360     		str	r3, [r4, #0]
 7041              		.loc 28 71 0 discriminator 6
 7042 0116 02D8     		bhi	.L415
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****         hokuyoHoldThrottleCorrection_Y = 0;
 7043              		.loc 28 72 0
 7044 0118 084B     		ldr	r3, .L417+8
 7045 011a 0022     		movs	r2, #0
 7046 011c 1A60     		str	r2, [r3, #0]
 7047              	.L415:
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****       }    
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     #endif
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     if (temphokuyoHoldThrottleCorrection_Y == INVALID_THROTTLE_CORRECTION_HOKUYO) {
 7048              		.loc 28 75 0
 7049 011e 10F57A7F 		cmn	r0, #1000
 7050 0122 05D1     		bne	.L403
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****         hokuyoHoldThrottleCorrection_Y =0;
 7051              		.loc 28 76 0
 7052 0124 0020     		movs	r0, #0
 7053 0126 2060     		str	r0, [r4, #0]
 7054 0128 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7055              	.LVL378:
 7056              	.L404:
 7057              	.LBE170:
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     }	
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   }
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****   else{
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     hokuyoHoldThrottleCorrection_X   = 0;
 7058              		.loc 28 80 0
 7059 012a 0021     		movs	r1, #0
 7060 012c 2960     		str	r1, [r5, #0]
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/PositionControlProcessor.h ****     hokuyoHoldThrottleCorrection_Y  = 0;
 7061              		.loc 28 81 0
 7062 012e 2160     		str	r1, [r4, #0]
 7063              	.L403:
 7064 0130 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7065              	.L418:
 7066 0132 00BF     		.align	2
 7067              	.L417:
 7068 0134 00000000 		.word	.LANCHOR108
 7069 0138 00000000 		.word	.LANCHOR111
 7070 013c 00000000 		.word	.LANCHOR117
 7071 0140 00000000 		.word	.LANCHOR84
 7072 0144 00000000 		.word	.LANCHOR109
 7073 0148 50010000 		.word	.LANCHOR9+336
 7074 014c 00000000 		.word	.LANCHOR110
 7075 0150 00000000 		.word	.LANCHOR112
 7076 0154 00000000 		.word	.LANCHOR113
 7077 0158 00000000 		.word	.LANCHOR114
 7078 015c 00000000 		.word	.LANCHOR115
 7079 0160 34010000 		.word	.LANCHOR9+308
 7080 0164 00000000 		.word	.LANCHOR116
 7081 0168 00000000 		.word	.LANCHOR118
 7082              	.LBE169:
 7083              		.cfi_endproc
 7084              	.LFE226:
 7086              		.section	.text._Z20calculateFlightErrorv,"ax",%progbits
 7087              		.align	1
 7088              		.global	_Z20calculateFlightErrorv
 7089              		.thumb
 7090              		.thumb_func
 7092              	_Z20calculateFlightErrorv:
 7093              	.LFB227:
 7094              		.file 29 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_H_
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_H_
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #define ATTITUDE_SCALING (0.75 * PWM2RAD)
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * calculateFlightError
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Calculate roll/pitch axis error with gyro/accel data to
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * compute motor command thrust so used command are executed
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void calculateFlightError()
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 7095              		.loc 29 38 0
 7096              		.cfi_startproc
 7097              		@ args = 0, pretend = 0, frame = 0
 7098              		@ frame_needed = 0, uses_anonymous_args = 0
 7099 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 7100              	.LCFI71:
 7101              		.cfi_def_cfa_offset 32
 7102              		.cfi_offset 14, -4
 7103              		.cfi_offset 10, -8
 7104              		.cfi_offset 9, -12
 7105              		.cfi_offset 8, -16
 7106              		.cfi_offset 7, -20
 7107              		.cfi_offset 6, -24
 7108              		.cfi_offset 5, -28
 7109              		.cfi_offset 4, -32
 7110 0004 2DED028B 		fstmfdd	sp!, {d8}
 7111              	.LCFI72:
 7112              		.cfi_def_cfa_offset 40
 7113              		.cfi_offset 80, -40
 7114              	.LBB171:
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined (UseGPSNavigator)
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] + gpsRollAxi
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] + gpsPitchAx
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAX
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     else
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined (Hold_X) || defined(Hold_Y)
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (HokuyoHoldState == ON) {
 7115              		.loc 29 49 0
 7116 0008 6548     		ldr	r0, .L423
 7117 000a 664C     		ldr	r4, .L423+4
 7118 000c 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 7119 000e 664E     		ldr	r6, .L423+8
 7120 0010 664D     		ldr	r5, .L423+12
 7121 0012 012B     		cmp	r3, #1
 7122 0014 4CD1     		bne	.L420
 7123              	.LBB172:
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] - hokuyoHold
 7124              		.loc 29 50 0
 7125 0016 DFF8C891 		ldr	r9, .L423+64
 7126 001a DFF8C881 		ldr	r8, .L423+68
 7127 001e 644B     		ldr	r3, .L423+16
 7128 0020 D9F80020 		ldr	r2, [r9, #0]
 7129 0024 D8F80070 		ldr	r7, [r8, #0]
 7130 0028 1968     		ldr	r1, [r3, #0]
 7131 002a D01B     		subs	r0, r2, r7
 7132 002c 471A     		subs	r7, r0, r1
 7133 002e 03EE107A 		fmsr	s6, r7	@ int
 7134 0032 9FED608A 		flds	s16, .L423+20
 7135 0036 F8EEC32A 		fsitos	s5, s6
 7136 003a 5F4F     		ldr	r7, .L423+24
 7137 003c 5F4A     		ldr	r2, .L423+28
 7138 003e 3968     		ldr	r1, [r7, #0]	@ float
 7139 0040 22EE882A 		fmuls	s4, s5, s16
 7140 0044 12EE100A 		fmrs	r0, s4
 7141 0048 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] - hokuyoHold
 7142              		.loc 29 51 0
 7143 004c 5C49     		ldr	r1, .L423+32
 7144 004e D9F80420 		ldr	r2, [r9, #4]
 7145 0052 D8F80430 		ldr	r3, [r8, #4]
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] - hokuyoHold
 7146              		.loc 29 50 0
 7147 0056 8246     		mov	sl, r0	@ float
 7148              	.LVL379:
 7149              		.loc 29 51 0
 7150 0058 0868     		ldr	r0, [r1, #0]
 7151              	.LVL380:
 7152 005a D31A     		subs	r3, r2, r3
 7153 005c C0EB030C 		rsb	ip, r0, r3
 7154 0060 01EE90CA 		fmsr	s3, ip	@ int
 7155 0064 B8EEE11A 		fsitos	s2, s3
 7156 0068 7A68     		ldr	r2, [r7, #4]	@ float
 7157 006a 21EE087A 		fmuls	s14, s2, s16
 7158 006e 82F00041 		eor	r1, r2, #-2147483648
 7159 0072 17EE100A 		fmrs	r0, s14
 7160 0076 534A     		ldr	r2, .L423+36
 7161 0078 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
 7162              		.loc 29 52 0
 7163 007c 2168     		ldr	r1, [r4, #0]	@ float
 7164 007e 524A     		ldr	r2, .L423+40
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] - hokuyoHold
 7165              		.loc 29 51 0
 7166 0080 0746     		mov	r7, r0	@ float
 7167              	.LVL381:
 7168              		.loc 29 52 0
 7169 0082 5046     		mov	r0, sl	@ float
 7170              	.LVL382:
 7171 0084 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7172 0088 00EE900A 		fmsr	s1, r0
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAX
 7173              		.loc 29 53 0
 7174 008c 6168     		ldr	r1, [r4, #4]	@ float
 7175 008e 4F4A     		ldr	r2, .L423+44
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
 7176              		.loc 29 52 0
 7177 0090 FDEEE07A 		ftosizs	s15, s1
 7178              		.loc 29 53 0
 7179 0094 3846     		mov	r0, r7	@ float
 7180 0096 81F00041 		eor	r1, r1, #-2147483648
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
 7181              		.loc 29 52 0
 7182 009a C6ED007A 		fsts	s15, [r6, #0]	@ int
 7183              		.loc 29 53 0
 7184 009e FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7185 00a2 00EE100A 		fmsr	s0, r0
 7186 00a6 FDEEC06A 		ftosizs	s13, s0
 7187 00aa C5ED006A 		fsts	s13, [r5, #0]	@ int
 7188 00ae 73E0     		b	.L419
 7189              	.LVL383:
 7190              	.L420:
 7191              	.LBE172:
 7192              	.LBB173:
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     else
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif  
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 7193              		.loc 29 57 0
 7194 00b0 4749     		ldr	r1, .L423+48
 7195 00b2 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 7196 00b4 0128     		cmp	r0, #1
 7197 00b6 46D1     		bne	.L422
 7198              	.LBB174:
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 7199              		.loc 29 58 0
 7200 00b8 DFF82491 		ldr	r9, .L423+64
 7201 00bc DFF82481 		ldr	r8, .L423+68
 7202 00c0 D9F80070 		ldr	r7, [r9, #0]
 7203 00c4 D8F80030 		ldr	r3, [r8, #0]
 7204 00c8 3C4A     		ldr	r2, .L423+28
 7205 00ca C3EB070A 		rsb	sl, r3, r7
 7206 00ce 08EE10AA 		fmsr	s16, sl	@ int
 7207 00d2 F8EEC87A 		fsitos	s15, s16
 7208 00d6 9FED378A 		flds	s16, .L423+20
 7209 00da 374F     		ldr	r7, .L423+24
 7210 00dc 27EE880A 		fmuls	s0, s15, s16
 7211 00e0 3968     		ldr	r1, [r7, #0]	@ float
 7212 00e2 10EE100A 		fmrs	r0, s0
 7213 00e6 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 7214              		.loc 29 59 0
 7215 00ea D9F80410 		ldr	r1, [r9, #4]
 7216 00ee 7F68     		ldr	r7, [r7, #4]	@ float
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 7217              		.loc 29 58 0
 7218 00f0 8246     		mov	sl, r0	@ float
 7219              	.LVL384:
 7220              		.loc 29 59 0
 7221 00f2 D8F80400 		ldr	r0, [r8, #4]
 7222              	.LVL385:
 7223 00f6 0A1A     		subs	r2, r1, r0
 7224 00f8 06EE902A 		fmsr	s13, r2	@ int
 7225 00fc B8EEE66A 		fsitos	s12, s13
 7226 0100 87F00041 		eor	r1, r7, #-2147483648
 7227 0104 66EE085A 		fmuls	s11, s12, s16
 7228 0108 2E4A     		ldr	r2, .L423+36
 7229 010a 15EE900A 		fmrs	r0, s11
 7230 010e FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 7231              		.loc 29 60 0
 7232 0112 2168     		ldr	r1, [r4, #0]	@ float
 7233 0114 2C4A     		ldr	r2, .L423+40
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 7234              		.loc 29 59 0
 7235 0116 0746     		mov	r7, r0	@ float
 7236              	.LVL386:
 7237              		.loc 29 60 0
 7238 0118 5046     		mov	r0, sl	@ float
 7239              	.LVL387:
 7240 011a FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7241 011e 05EE100A 		fmsr	s10, r0
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAXIS
 7242              		.loc 29 61 0
 7243 0122 6368     		ldr	r3, [r4, #4]	@ float
 7244 0124 294A     		ldr	r2, .L423+44
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 7245              		.loc 29 60 0
 7246 0126 FDEEC54A 		ftosizs	s9, s10
 7247              		.loc 29 61 0
 7248 012a 3846     		mov	r0, r7	@ float
 7249 012c 83F00041 		eor	r1, r3, #-2147483648
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 7250              		.loc 29 60 0
 7251 0130 C6ED004A 		fsts	s9, [r6, #0]	@ int
 7252              		.loc 29 61 0
 7253 0134 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7254 0138 04EE100A 		fmsr	s8, r0
 7255 013c FDEEC43A 		ftosizs	s7, s8
 7256 0140 C5ED003A 		fsts	s7, [r5, #0]	@ int
 7257 0144 28E0     		b	.L419
 7258              	.LVL388:
 7259              	.L422:
 7260              	.LBE174:
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   else {
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 7261              		.loc 29 64 0
 7262 0146 234F     		ldr	r7, .L423+52
 7263 0148 0020     		movs	r0, #0
 7264 014a FFF7FEFF 		bl	_Z17getReceiverSIDatah
 7265 014e 94ED004A 		flds	s8, [r4, #0]
 7266 0152 D7ED004A 		flds	s9, [r7, #0]
 7267 0156 64EE243A 		fmuls	s7, s8, s9
 7268 015a 1F4A     		ldr	r2, .L423+56
 7269 015c 13EE901A 		fmrs	r1, s7
 7270 0160 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7271 0164 03EE100A 		fmsr	s6, r0
 7272 0168 FDEEC32A 		ftosizs	s5, s6
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandPitch = updatePID(getReceiverSIData(YAXIS), -gyroRate[YAXIS]*rotationSpeedFacto
 7273              		.loc 29 65 0
 7274 016c 0120     		movs	r0, #1
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 7275              		.loc 29 64 0
 7276 016e C6ED002A 		fsts	s5, [r6, #0]	@ int
 7277              		.loc 29 65 0
 7278 0172 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 7279 0176 D4ED011A 		flds	s3, [r4, #4]
 7280 017a 97ED002A 		flds	s4, [r7, #0]
 7281 017e 21EEC21A 		fnmuls	s2, s3, s4
 7282 0182 164A     		ldr	r2, .L423+60
 7283 0184 11EE101A 		fmrs	r1, s2
 7284 0188 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 7285 018c 07EE100A 		fmsr	s14, r0
 7286 0190 FDEEC70A 		ftosizs	s1, s14
 7287 0194 C5ED000A 		fsts	s1, [r5, #0]	@ int
 7288              	.L419:
 7289              	.LBE173:
 7290              	.LBE171:
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 7291              		.loc 29 67 0
 7292 0198 BDEC028B 		fldmfdd	sp!, {d8}
 7293 019c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 7294              	.L424:
 7295              		.align	2
 7296              	.L423:
 7297 01a0 00000000 		.word	.LANCHOR108
 7298 01a4 00000000 		.word	.LANCHOR19
 7299 01a8 00000000 		.word	.LANCHOR94
 7300 01ac 00000000 		.word	.LANCHOR92
 7301 01b0 00000000 		.word	.LANCHOR111
 7302 01b4 A69BC43A 		.word	985963430
 7303 01b8 00000000 		.word	.LANCHOR33
 7304 01bc 54000000 		.word	.LANCHOR9+84
 7305 01c0 00000000 		.word	.LANCHOR117
 7306 01c4 70000000 		.word	.LANCHOR9+112
 7307 01c8 A8000000 		.word	.LANCHOR9+168
 7308 01cc C4000000 		.word	.LANCHOR9+196
 7309 01d0 00000000 		.word	.LANCHOR119
 7310 01d4 00000000 		.word	.LANCHOR120
 7311 01d8 00000000 		.word	.LANCHOR9
 7312 01dc 1C000000 		.word	.LANCHOR9+28
 7313 01e0 00000000 		.word	.LANCHOR1
 7314 01e4 00000000 		.word	.LANCHOR3
 7315              		.cfi_endproc
 7316              	.LFE227:
 7318              		.section	.text._Z19processCalibrateESCv,"ax",%progbits
 7319              		.align	1
 7320              		.global	_Z19processCalibrateESCv
 7321              		.thumb
 7322              		.thumb_func
 7324              	_Z19processCalibrateESCv:
 7325              	.LFB228:
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processCalibrateESC
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * 
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Proces esc calibration command with the help of the configurator
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processCalibrateESC()
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 7326              		.loc 29 75 0
 7327              		.cfi_startproc
 7328              		@ args = 0, pretend = 0, frame = 0
 7329              		@ frame_needed = 0, uses_anonymous_args = 0
 7330              		@ link register save eliminated.
 7331              	.LBB175:
 7332              	.LBB176:
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 7333              		.loc 29 76 0
 7334 0000 1B4B     		ldr	r3, .L439
 7335 0002 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 7336 0004 1B4B     		ldr	r3, .L439+4
 7337 0006 032A     		cmp	r2, #3
 7338 0008 0CD0     		beq	.L428
 7339 000a 052A     		cmp	r2, #5
 7340 000c 19D0     		beq	.L434
 7341 000e 012A     		cmp	r2, #1
 7342              	.LVL389:
 7343              	.LBB177:
 7344              	.LBB178:
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   case 1:
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = MAXCOMMAND;
 7345              		.loc 29 79 0
 7346 0010 0CBF     		ite	eq
 7347 0012 4FF4FA62 		moveq	r2, #2000
 7348              	.LVL390:
 7349              	.LBE178:
 7350              	.LBB179:
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     break;
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   case 3:
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     break;
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   case 5:
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     safetyCheck = ON;
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     break;
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   default:
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = MINCOMMAND;
 7351              		.loc 29 92 0
 7352 0016 4FF47A72 		movne	r2, #1000
 7353              	.LVL391:
 7354              	.L438:
 7355              		.loc 29 92 0 is_stmt 0 discriminator 1
 7356 001a 1A60     		str	r2, [r3, #0]
 7357              	.LVL392:
 7358 001c 5A60     		str	r2, [r3, #4]
 7359              	.LVL393:
 7360 001e 9A60     		str	r2, [r3, #8]
 7361              	.LVL394:
 7362 0020 DA60     		str	r2, [r3, #12]
 7363              	.LVL395:
 7364 0022 23E0     		b	.L430
 7365              	.LVL396:
 7366              	.L428:
 7367              	.LBE179:
 7368              	.LBB180:
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
 7369              		.loc 29 83 0 is_stmt 1
 7370 0024 1448     		ldr	r0, .L439+8
 7371 0026 0268     		ldr	r2, [r0, #0]
 7372 0028 B2F5966F 		cmp	r2, #1200
 7373 002c B4BF     		ite	lt
 7374 002e 1146     		movlt	r1, r2
 7375 0030 4FF49661 		movge	r1, #1200
 7376 0034 B2F57A7F 		cmp	r2, #1000
 7377 0038 ACBF     		ite	ge
 7378 003a 0A46     		movge	r2, r1
 7379 003c 4FF47A72 		movlt	r2, #1000
 7380 0040 EBE7     		b	.L438
 7381              	.L434:
 7382              	.LBE180:
 7383              	.LBE177:
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 7384              		.loc 29 76 0
 7385 0042 0022     		movs	r2, #0
 7386              	.L429:
 7387              	.LBB182:
 7388              	.LBB181:
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7389              		.loc 29 87 0
 7390 0044 0D49     		ldr	r1, .L439+12
 7391 0046 5158     		ldr	r1, [r2, r1]
 7392 0048 B1F57A7F 		cmp	r1, #1000
 7393 004c 05DB     		blt	.L435
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7394              		.loc 29 87 0 is_stmt 0 discriminator 1
 7395 004e B1F5966F 		cmp	r1, #1200
 7396 0052 A8BF     		it	ge
 7397 0054 4FF49661 		movge	r1, #1200
 7398 0058 01E0     		b	.L433
 7399              	.L435:
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7400              		.loc 29 87 0
 7401 005a 4FF47A71 		mov	r1, #1000
 7402              	.L433:
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 7403              		.loc 29 87 0 discriminator 3
 7404 005e 9950     		str	r1, [r3, r2]
 7405 0060 0432     		adds	r2, r2, #4
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
 7406              		.loc 29 86 0 is_stmt 1 discriminator 3
 7407 0062 102A     		cmp	r2, #16
 7408 0064 EED1     		bne	.L429
 7409              	.LBE181:
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     safetyCheck = ON;
 7410              		.loc 29 88 0
 7411 0066 064B     		ldr	r3, .L439+16
 7412 0068 0122     		movs	r2, #1
 7413 006a 1A70     		strb	r2, [r3, #0]
 7414              	.LVL397:
 7415              	.L430:
 7416              	.LBE182:
 7417              	.LBE176:
 7418              	.LBE175:
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // Send calibration commands to motors
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 7419              		.loc 29 96 0
 7420              	.LBB183:
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
 7421              		.loc 29 95 0
 7422 006c FFF7FEBF 		b	_Z11writeMotorsv
 7423              	.L440:
 7424              		.align	2
 7425              	.L439:
 7426 0070 00000000 		.word	.LANCHOR121
 7427 0074 00000000 		.word	.LANCHOR56
 7428 0078 00000000 		.word	.LANCHOR122
 7429 007c 00000000 		.word	.LANCHOR123
 7430 0080 00000000 		.word	.LANCHOR124
 7431              	.LBE183:
 7432              		.cfi_endproc
 7433              	.LFE228:
 7435              		.section	.text._Z25processThrottleCorrectionv,"ax",%progbits
 7436              		.align	1
 7437              		.global	_Z25processThrottleCorrectionv
 7438              		.thumb
 7439              		.thumb_func
 7441              	_Z25processThrottleCorrectionv:
 7442              	.LFB229:
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processBatteryMonitorThrottleAdjustment
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Check battery alarm and if in alarm, increment a counter
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * When this counter reach BATTERY_MONITOR_MAX_ALARM_COUNT, then
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * we are now in auto-descent mode.
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * When in auto-descent mode, the user can pass throttle keep when the
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * alarm was reach, and the throttle is slowly decrease for a minute til
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * batteryMonitorThrottle that is configurable with the configurator
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #if defined BattMonitor && defined BattMonitorAutoDescent
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   void processBatteryMonitorThrottleAdjustment() {
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (batteryMonitorAlarmCounter < BATTERY_MONITOR_MAX_ALARM_COUNT) {
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (batteryAlarm) {
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         batteryMonitorAlarmCounter++;
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     else {
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (altitudeHoldState == ON) {
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #if defined AltitudeHoldBaro
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             baroAltitudeToHoldTarget -= 0.01;
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #endif
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #if defined AltitudeHoldRangeFinder
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             if (sonarAltitudeToHoldTarget != INVALID_RANGE) {
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****               sonarAltitudeToHoldTarget -= 0.01;
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             }
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           #endif
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         else {
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #endif
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           if (batteryMonitorStartThrottle == 0) {  // init battery monitor throttle correction!
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteryMonitorStartTime = millis();
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             if (throttle < batteryMonitorThrottleTarget) {
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****               batteryMonitorStartThrottle = batteryMonitorThrottleTarget;
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             }
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             else {
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****               batteryMonitorStartThrottle = throttle; 
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             }
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           int batteryMonitorThrottle = map(millis()-batteryMonitorStartTime, 0, batteryMonitorGoing
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           if (batteryMonitorThrottle < batteryMonitorThrottleTarget) {
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteryMonitorThrottle = batteryMonitorThrottleTarget;
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           if (throttle < batteryMonitorThrottle) {
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = 0;
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           else {
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = batteryMonitorThrottle - throttle;
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           }
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #endif
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #endif  
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #if defined AutoLanding
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #define BARO_AUTO_LANDING_DESCENT_SPEED 0.008
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #define SONAR_AUTO_LANDING_DESCENT_SPEED 0.005
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   void processAutoLandingAltitudeCorrection() {
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (autoLandingState != OFF) {   
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (autoLandingState == BARO_AUTO_DESCENT_STATE) {
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) { 
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           autoLandingState = SONAR_AUTO_DESCENT_STATE;
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       else if (autoLandingState == SONAR_AUTO_DESCENT_STATE) {
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] < 0.5) {
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           autoLandingState = MOTOR_AUTO_DESCENT_STATE;
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       else {
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         autoLandingThrottleCorrection -= 1;
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         if (((throttle + autoLandingThrottleCorrection) < 1000) || (rangeFinderRange[ALTITUDE_RANGE
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           commandAllMotors(MINCOMMAND);
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****           motorArmed = OFF;
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         }
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  }
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** #endif
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processThrottleCorrection
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * 
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * This function will add some throttle imput if the craft is angled
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * this prevent the craft to loose altitude when angled.
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * it also add the battery throttle correction in case
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * of we are in auto-descent.
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * 
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Special thank to Ziojo for this.
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processThrottleCorrection() {
 7443              		.loc 29 202 0
 7444              		.cfi_startproc
 7445              		@ args = 0, pretend = 0, frame = 0
 7446              		@ frame_needed = 0, uses_anonymous_args = 0
 7447              		@ link register save eliminated.
 7448              	.LVL398:
 7449              	.LBB184:
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   int throttleAdjust = 0;
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined UseGPSNavigator
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttleAdjust = throttle / (cos (kinematicsAngle[XAXIS]*0.55) * cos (kinematicsAngle[YAXIS]*
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttleAdjust = constrain ((throttleAdjust - throttle), 0, 50); //compensate max  +/- 25 deg
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined BattMonitorAutoDescent
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     throttleAdjust += batteyMonitorThrottleCorrection;
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #if defined (AutoLanding)
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined BattMonitorAutoDescent
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (batteyMonitorThrottleCorrection != 0) { // don't auto land in the same time that the batt
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         throttleAdjust += autoLandingThrottleCorrection;
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #else
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttleAdjust += autoLandingThrottleCorrection;
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   #endif
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   throttle = constrain((throttle + throttleAdjust),MINCOMMAND,MAXCOMMAND-150);  // limmit throttle 
 7450              		.loc 29 224 0
 7451 0000 074A     		ldr	r2, .L444
 7452 0002 1368     		ldr	r3, [r2, #0]
 7453 0004 B3F57A7F 		cmp	r3, #1000
 7454 0008 05DB     		blt	.L443
 7455              		.loc 29 224 0 is_stmt 0 discriminator 1
 7456 000a 40F23A71 		movw	r1, #1850
 7457 000e 8B42     		cmp	r3, r1
 7458 0010 A8BF     		it	ge
 7459 0012 0B46     		movge	r3, r1
 7460 0014 01E0     		b	.L442
 7461              	.L443:
 7462              		.loc 29 224 0
 7463 0016 4FF47A73 		mov	r3, #1000
 7464              	.L442:
 7465              		.loc 29 224 0 discriminator 3
 7466 001a 1360     		str	r3, [r2, #0]
 7467              	.LBE184:
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 7468              		.loc 29 225 0 is_stmt 1 discriminator 3
 7469 001c 7047     		bx	lr
 7470              	.L445:
 7471 001e 00BF     		.align	2
 7472              	.L444:
 7473 0020 00000000 		.word	.LANCHOR91
 7474              		.cfi_endproc
 7475              	.LFE229:
 7477              		.section	.text._Z20processHardManueversv,"ax",%progbits
 7478              		.align	1
 7479              		.global	_Z20processHardManueversv
 7480              		.thumb
 7481              		.thumb_func
 7483              	_Z20processHardManueversv:
 7484              	.LFB230:
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processHardManuevers
 230:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 231:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * In case of a roll/pitch stick at one edge to do a loop, this function
 232:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * will prevent the lower throttle motor side to have too much low throtte.
 233:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processHardManuevers() {
 7485              		.loc 29 234 0
 7486              		.cfi_startproc
 7487              		@ args = 0, pretend = 0, frame = 0
 7488              		@ frame_needed = 0, uses_anonymous_args = 0
 7489              		@ link register save eliminated.
 7490              	.LBB185:
 235:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7491              		.loc 29 236 0
 7492 0000 0F4A     		ldr	r2, .L452
 7493 0002 1068     		ldr	r0, [r2, #0]
 7494 0004 A0F58863 		sub	r3, r0, #1088
 7495 0008 0C3B     		subs	r3, r3, #12
 7496 000a B3F5487F 		cmp	r3, #800
 7497 000e 04D8     		bhi	.L447
 237:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       (receiverCommand[XAXIS] > MAXCHECK) ||
 238:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       (receiverCommand[YAXIS] < MINCHECK) ||
 7498              		.loc 29 238 0 discriminator 1
 7499 0010 5368     		ldr	r3, [r2, #4]
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7500              		.loc 29 236 0 discriminator 1
 7501 0012 40F24B42 		movw	r2, #1099
 7502 0016 9342     		cmp	r3, r2
 7503 0018 03DC     		bgt	.L448
 7504              	.L447:
 7505              	.LBB186:
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       (receiverCommand[YAXIS] > MAXCHECK)) {  
 240:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7506              		.loc 29 242 0 discriminator 2
 7507 001a 0A49     		ldr	r1, .L452+4
 7508 001c 0023     		movs	r3, #0
 7509 001e 0A68     		ldr	r2, [r1, #0]
 7510 0020 04E0     		b	.L449
 7511              	.L448:
 7512              	.LBE186:
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 7513              		.loc 29 236 0 discriminator 2
 7514 0022 40F26C70 		movw	r0, #1900
 7515 0026 8342     		cmp	r3, r0
 7516 0028 F7DC     		bgt	.L447
 7517 002a 7047     		bx	lr
 7518              	.L449:
 7519              	.LBB187:
 7520              		.loc 29 242 0 discriminator 2
 7521 002c 0648     		ldr	r0, .L452+8
 243:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMaxCommand[motor] = MAXCOMMAND;
 7522              		.loc 29 243 0 discriminator 2
 7523 002e 0749     		ldr	r1, .L452+12
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 7524              		.loc 29 242 0 discriminator 2
 7525 0030 1A50     		str	r2, [r3, r0]
 7526              		.loc 29 243 0 discriminator 2
 7527 0032 4FF4FA60 		mov	r0, #2000
 7528 0036 5850     		str	r0, [r3, r1]
 7529 0038 0433     		adds	r3, r3, #4
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 7530              		.loc 29 241 0 discriminator 2
 7531 003a 102B     		cmp	r3, #16
 7532 003c F6D1     		bne	.L449
 7533 003e 7047     		bx	lr
 7534              	.L453:
 7535              		.align	2
 7536              	.L452:
 7537 0040 00000000 		.word	.LANCHOR1
 7538 0044 00000000 		.word	.LANCHOR125
 7539 0048 00000000 		.word	.LANCHOR126
 7540 004c 00000000 		.word	.LANCHOR127
 7541              	.LBE187:
 7542              	.LBE185:
 7543              		.cfi_endproc
 7544              	.LFE230:
 7546              		.section	.text._Z20processMinMaxCommandv,"ax",%progbits
 7547              		.align	1
 7548              		.global	_Z20processMinMaxCommandv
 7549              		.thumb
 7550              		.thumb_func
 7552              	_Z20processMinMaxCommandv:
 7553              	.LFB231:
 244:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 249:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processMinMaxCommand
 250:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 251:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * This function correct too low/max throttle when manuevering
 252:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * preventing some wobbling behavior
 253:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 254:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processMinMaxCommand()
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 7554              		.loc 29 255 0
 7555              		.cfi_startproc
 7556              		@ args = 0, pretend = 0, frame = 0
 7557              		@ frame_needed = 0, uses_anonymous_args = 0
 7558              	.LVL399:
 7559              	.LBB188:
 7560              	.LBB189:
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++)
 257:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   {
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7561              		.loc 29 258 0
 7562 0000 154A     		ldr	r2, .L458
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMaxCommand[motor] = MAXCOMMAND;
 7563              		.loc 29 259 0
 7564 0002 164B     		ldr	r3, .L458+4
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7565              		.loc 29 258 0
 7566 0004 1068     		ldr	r0, [r2, #0]
 7567 0006 1649     		ldr	r1, .L458+8
 7568              		.loc 29 259 0
 7569 0008 4FF4FA62 		mov	r2, #2000
 7570              	.LBE189:
 7571              	.LBE188:
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** {
 7572              		.loc 29 255 0
 7573 000c 10B5     		push	{r4, lr}
 7574              	.LCFI73:
 7575              		.cfi_def_cfa_offset 8
 7576              		.cfi_offset 14, -4
 7577              		.cfi_offset 4, -8
 7578              	.LBB194:
 7579              	.LBB190:
 7580              		.loc 29 259 0
 7581 000e 9A60     		str	r2, [r3, #8]
 7582 0010 DA60     		str	r2, [r3, #12]
 7583 0012 1A60     		str	r2, [r3, #0]
 7584              	.LVL400:
 7585 0014 5A60     		str	r2, [r3, #4]
 7586              	.LVL401:
 7587              	.LBE190:
 260:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 261:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 262:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   int maxMotor = motorCommand[0];
 7588              		.loc 29 262 0
 7589 0016 134B     		ldr	r3, .L458+12
 7590              	.LBB191:
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 7591              		.loc 29 258 0
 7592 0018 0860     		str	r0, [r1, #0]
 7593 001a 4860     		str	r0, [r1, #4]
 7594 001c 8860     		str	r0, [r1, #8]
 7595 001e C860     		str	r0, [r1, #12]
 7596              	.LBE191:
 7597              		.loc 29 262 0
 7598 0020 93E80600 		ldmia	r3, {r1, r2}
 7599 0024 9868     		ldr	r0, [r3, #8]
 7600 0026 9142     		cmp	r1, r2
 7601 0028 B8BF     		it	lt
 7602 002a 1146     		movlt	r1, r2
 7603              	.LVL402:
 7604 002c DA68     		ldr	r2, [r3, #12]
 7605 002e 8142     		cmp	r1, r0
 7606 0030 B8BF     		it	lt
 7607 0032 0146     		movlt	r1, r0
 7608              	.LVL403:
 7609 0034 9142     		cmp	r1, r2
 7610 0036 B8BF     		it	lt
 7611 0038 1146     		movlt	r1, r2
 7612              	.LVL404:
 7613              	.LBB192:
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 264:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor=1; motor < LASTMOTOR; motor++) {
 265:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (motorCommand[motor] > maxMotor) {
 7614              		.loc 29 265 0
 7615 003a 0022     		movs	r2, #0
 7616              	.LVL405:
 7617              	.L456:
 7618              	.LBE192:
 7619              	.LBB193:
 266:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       maxMotor = motorCommand[motor];
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 269:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     if (maxMotor > MAXCOMMAND) {
 7620              		.loc 29 271 0
 7621 003c B1F5FA6F 		cmp	r1, #2000
 7622 0040 05DD     		ble	.L455
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorCommand[motor] =  motorCommand[motor] - (maxMotor - MAXCOMMAND);
 7623              		.loc 29 272 0
 7624 0042 9C58     		ldr	r4, [r3, r2]
 7625 0044 C1F5FA6C 		rsb	ip, r1, #2000
 7626 0048 04EB0C00 		add	r0, r4, ip
 7627 004c 9850     		str	r0, [r3, r2]
 7628              	.L455:
 7629 004e 0432     		adds	r2, r2, #4
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 7630              		.loc 29 270 0
 7631 0050 102A     		cmp	r2, #16
 7632 0052 F3D1     		bne	.L456
 7633              	.LBE193:
 7634              	.LBE194:
 273:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 274:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 7635              		.loc 29 275 0
 7636 0054 10BD     		pop	{r4, pc}
 7637              	.L459:
 7638 0056 00BF     		.align	2
 7639              	.L458:
 7640 0058 00000000 		.word	.LANCHOR125
 7641 005c 00000000 		.word	.LANCHOR127
 7642 0060 00000000 		.word	.LANCHOR126
 7643 0064 00000000 		.word	.LANCHOR56
 7644              		.cfi_endproc
 7645              	.LFE231:
 7647              		.section	.text._Z25isHokuyoHoldEnabledByUserv,"ax",%progbits
 7648              		.align	1
 7649              		.global	_Z25isHokuyoHoldEnabledByUserv
 7650              		.thumb
 7651              		.thumb_func
 7653              	_Z25isHokuyoHoldEnabledByUserv:
 7654              	.LFB233:
 7655              		.file 30 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** // FlightCommandProcessor is responsible for decoding transmitter stick combinations
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** // for setting up AeroQuad modes such as motor arming and disarming
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #ifndef _AQ_FLIGHT_COMMAND_READER_
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #define _AQ_FLIGHT_COMMAND_READER_
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (Lidar2D)
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   boolean isHokuyoHoldEnabledByUser() {
 7656              		.loc 30 29 0
 7657              		.cfi_startproc
 7658              		@ args = 0, pretend = 0, frame = 0
 7659              		@ frame_needed = 0, uses_anonymous_args = 0
 7660              		@ link register save eliminated.
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     // add transmiter control code
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if ((receiverCommand[AUX1] < 1750) && (receiverCommand[MODE] > 1500)) {
 7661              		.loc 30 31 0
 7662 0000 074B     		ldr	r3, .L463
 7663 0002 5969     		ldr	r1, [r3, #20]
 7664 0004 40F2D562 		movw	r2, #1749
 7665 0008 9142     		cmp	r1, r2
 7666 000a 07DC     		bgt	.L462
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   boolean isHokuyoHoldEnabledByUser() {
 7667              		.loc 30 29 0 discriminator 1
 7668 000c 1869     		ldr	r0, [r3, #16]
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       return true;
 7669              		.loc 30 32 0 discriminator 1
 7670 000e 40F2DC53 		movw	r3, #1500
 7671 0012 9842     		cmp	r0, r3
 7672 0014 D4BF     		ite	le
 7673 0016 0020     		movle	r0, #0
 7674 0018 0120     		movgt	r0, #1
 7675 001a 7047     		bx	lr
 7676              	.L462:
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****      }
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       return false;
 7677              		.loc 30 34 0
 7678 001c 0020     		movs	r0, #0
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 7679              		.loc 30 35 0
 7680 001e 7047     		bx	lr
 7681              	.L464:
 7682              		.align	2
 7683              	.L463:
 7684 0020 00000000 		.word	.LANCHOR1
 7685              		.cfi_endproc
 7686              	.LFE233:
 7688              		.section	.text._Z41processHokuyoHoldStateFromReceiverCommandv,"ax",%progbits
 7689              		.align	1
 7690              		.global	_Z41processHokuyoHoldStateFromReceiverCommandv
 7691              		.thumb
 7692              		.thumb_func
 7694              	_Z41processHokuyoHoldStateFromReceiverCommandv:
 7695              	.LFB234:
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (Lidar2D)
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processHokuyoHoldStateFromReceiverCommand() {
 7696              		.loc 30 40 0
 7697              		.cfi_startproc
 7698              		@ args = 0, pretend = 0, frame = 0
 7699              		@ frame_needed = 0, uses_anonymous_args = 0
 7700 0000 08B5     		push	{r3, lr}
 7701              	.LCFI74:
 7702              		.cfi_def_cfa_offset 8
 7703              		.cfi_offset 14, -4
 7704              		.cfi_offset 3, -8
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (isHokuyoHoldEnabledByUser()) {
 7705              		.loc 30 41 0
 7706 0002 FFF7FEFF 		bl	_Z25isHokuyoHoldEnabledByUserv
 7707 0006 30B3     		cbz	r0, .L466
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
 7708              		.loc 30 42 0
 7709 0008 1548     		ldr	r0, .L469
 7710 000a 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 7711 000c 022B     		cmp	r3, #2
 7712 000e 26D0     		beq	.L465
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (!isHokuyoHoldInitialized) {  //X and Y according to transmiter co-ordinate system
 7713              		.loc 30 43 0
 7714 0010 144A     		ldr	r2, .L469+4
 7715 0012 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 7716 0014 D9B9     		cbnz	r1, .L468
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             //roll position hold
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             #if defined (Hold_X)
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             HokuyoPositionToHoldTarget_X = distance2D[plus_X];                
 7717              		.loc 30 46 0
 7718 0016 1448     		ldr	r0, .L469+8
 7719 0018 144B     		ldr	r3, .L469+12
 7720 001a D0ED000A 		flds	s1, [r0, #0]	@ int
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSROLL_PID_IDX].integratedError = 0;
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSROLL_PID_IDX].lastError = HokuyoPositionToHoldTarget_X;
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             #endif
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             //pitch position hold
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             #if defined (Hold_Y)
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             HokuyoPositionToHoldTarget_Y = distance2D[plus_Y];                
 7721              		.loc 30 53 0
 7722 001e 4068     		ldr	r0, [r0, #4]
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             HokuyoPositionToHoldTarget_X = distance2D[plus_X];                
 7723              		.loc 30 46 0
 7724 0020 B8EEE00A 		fsitos	s0, s1
 7725              		.loc 30 53 0
 7726 0024 07EE100A 		fmsr	s14, r0	@ int
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             HokuyoPositionToHoldTarget_X = distance2D[plus_X];                
 7727              		.loc 30 46 0
 7728 0028 83ED000A 		fsts	s0, [r3, #0]
 7729              		.loc 30 53 0
 7730 002c F8EEC77A 		fsitos	s15, s14
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSROLL_PID_IDX].integratedError = 0;
 7731              		.loc 30 47 0
 7732 0030 0F4B     		ldr	r3, .L469+16
 7733              		.loc 30 53 0
 7734 0032 1048     		ldr	r0, .L469+20
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSROLL_PID_IDX].integratedError = 0;
 7735              		.loc 30 47 0
 7736 0034 0021     		movs	r1, #0
 7737 0036 C3F86411 		str	r1, [r3, #356]	@ float
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSROLL_PID_IDX].lastError = HokuyoPositionToHoldTarget_X;
 7738              		.loc 30 48 0
 7739 003a 83ED570A 		fsts	s0, [r3, #348]
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSPITCH_PID_IDX].integratedError = 0;
 7740              		.loc 30 54 0
 7741 003e C3F84811 		str	r1, [r3, #328]	@ float
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[GPSPITCH_PID_IDX].lastError = HokuyoPositionToHoldTarget_Y; 
 7742              		.loc 30 55 0
 7743 0042 C3ED507A 		fsts	s15, [r3, #320]
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             HokuyoPositionToHoldTarget_Y = distance2D[plus_Y];                
 7744              		.loc 30 53 0
 7745 0046 C0ED007A 		fsts	s15, [r0, #0]
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             #endif           
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             isHokuyoHoldInitialized = true;
 7746              		.loc 30 57 0
 7747 004a 0123     		movs	r3, #1
 7748 004c 1370     		strb	r3, [r2, #0]
 7749              	.L468:
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         HokuyoHoldState = ON;
 7750              		.loc 30 59 0
 7751 004e 0A49     		ldr	r1, .L469+24
 7752 0050 0122     		movs	r2, #1
 7753 0052 0A70     		strb	r2, [r1, #0]
 7754 0054 08BD     		pop	{r3, pc}
 7755              	.L466:
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     } 
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isHokuyoHoldInitialized = false;
 7756              		.loc 30 63 0
 7757 0056 034A     		ldr	r2, .L469+4
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       HokuyoHoldState = OFF;
 7758              		.loc 30 64 0
 7759 0058 074B     		ldr	r3, .L469+24
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isHokuyoHoldInitialized = false;
 7760              		.loc 30 63 0
 7761 005a 1070     		strb	r0, [r2, #0]
 7762              		.loc 30 64 0
 7763 005c 1870     		strb	r0, [r3, #0]
 7764              	.L465:
 7765 005e 08BD     		pop	{r3, pc}
 7766              	.L470:
 7767              		.align	2
 7768              	.L469:
 7769 0060 00000000 		.word	.LANCHOR98
 7770 0064 00000000 		.word	.LANCHOR128
 7771 0068 00000000 		.word	.LANCHOR84
 7772 006c 00000000 		.word	.LANCHOR109
 7773 0070 00000000 		.word	.LANCHOR9
 7774 0074 00000000 		.word	.LANCHOR115
 7775 0078 00000000 		.word	.LANCHOR108
 7776              		.cfi_endproc
 7777              	.LFE234:
 7779              		.section	.text._Z27isPositionHoldEnabledByUserv,"ax",%progbits
 7780              		.align	1
 7781              		.global	_Z27isPositionHoldEnabledByUserv
 7782              		.thumb
 7783              		.thumb_func
 7785              	_Z27isPositionHoldEnabledByUserv:
 7786              	.LFB235:
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (AltitudeHoldBaro) || defined (AltitudeHoldRangeFinder)
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   boolean isPositionHoldEnabledByUser() {
 7787              		.loc 30 73 0
 7788              		.cfi_startproc
 7789              		@ args = 0, pretend = 0, frame = 0
 7790              		@ frame_needed = 0, uses_anonymous_args = 0
 7791              		@ link register save eliminated.
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #if defined (UseGPSNavigator)
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if ((receiverCommand[AUX1] < 1750) || (receiverCommand[AUX2] < 1750)) {
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         return true;
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       return false;
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #else
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (receiverCommand[AUX1] < 1750) {
 7792              		.loc 30 80 0
 7793 0000 0448     		ldr	r0, .L472
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         return true;
 7794              		.loc 30 81 0
 7795 0002 4069     		ldr	r0, [r0, #20]
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       return false;
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 7796              		.loc 30 85 0
 7797 0004 40F2D563 		movw	r3, #1749
 7798 0008 9842     		cmp	r0, r3
 7799 000a CCBF     		ite	gt
 7800 000c 0020     		movgt	r0, #0
 7801 000e 0120     		movle	r0, #1
 7802 0010 7047     		bx	lr
 7803              	.L473:
 7804 0012 00BF     		.align	2
 7805              	.L472:
 7806 0014 00000000 		.word	.LANCHOR1
 7807              		.cfi_endproc
 7808              	.LFE235:
 7810              		.section	.text._Z43processAltitudeHoldStateFromReceiverCommandv,"ax",%progbits
 7811              		.align	1
 7812              		.global	_Z43processAltitudeHoldStateFromReceiverCommandv
 7813              		.thumb
 7814              		.thumb_func
 7816              	_Z43processAltitudeHoldStateFromReceiverCommandv:
 7817              	.LFB236:
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processAltitudeHoldStateFromReceiverCommand() {
 7818              		.loc 30 89 0
 7819              		.cfi_startproc
 7820              		@ args = 0, pretend = 0, frame = 0
 7821              		@ frame_needed = 0, uses_anonymous_args = 0
 7822 0000 38B5     		push	{r3, r4, r5, lr}
 7823              	.LCFI75:
 7824              		.cfi_def_cfa_offset 16
 7825              		.cfi_offset 14, -4
 7826              		.cfi_offset 5, -8
 7827              		.cfi_offset 4, -12
 7828              		.cfi_offset 3, -16
 7829              	.LBB195:
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (isPositionHoldEnabledByUser()) {
 7830              		.loc 30 90 0
 7831 0002 FFF7FEFF 		bl	_Z27isPositionHoldEnabledByUserv
 7832 0006 1B4C     		ldr	r4, .L480
 7833 0008 0028     		cmp	r0, #0
 7834 000a 2FD0     		beq	.L475
 7835              	.LBB196:
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
 7836              		.loc 30 91 0
 7837 000c 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 7838 000e 022B     		cmp	r3, #2
 7839 0010 2FD0     		beq	.L474
 7840              	.LBB197:
 7841              	.LBB198:
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (!isAltitudeHoldInitialized) {
 7842              		.loc 30 92 0
 7843 0012 194D     		ldr	r5, .L480+4
 7844 0014 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 7845 0016 30BB     		cbnz	r0, .L477
 7846              	.LBB199:
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined(AltitudeLidar)
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = alt_read();                // Lidar sensor -----> Altitude h
 7847              		.loc 30 94 0
 7848 0018 FFF7FEFF 		bl	_Z8alt_readv
 7849 001c 07EE100A 		fmsr	s14, r0	@ int
 7850 0020 1649     		ldr	r1, .L480+8
 7851 0022 174B     		ldr	r3, .L480+12
 7852 0024 F8EEC77A 		fsitos	s15, s14
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processAltitudeHoldStateFromReceiverCommand() {
 7853              		.loc 30 89 0
 7854 0028 03F1C802 		add	r2, r3, #200
 7855              		.loc 30 94 0
 7856 002c C1ED007A 		fsts	s15, [r1, #0]
 7857              	.LVL406:
 7858              	.L478:
 7859              	.LBB200:
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             for(int i=0;i<alt_buffer_size;i++){    // for moving avg of altitude
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****               alt_buffer[i] = baroAltitudeToHoldTarget;
 7860              		.loc 30 96 0 discriminator 2
 7861 0030 17EE900A 		fmrs	r0, s15
 7862 0034 43F8040F 		str	r0, [r3, #4]!	@ float
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             for(int i=0;i<alt_buffer_size;i++){    // for moving avg of altitude
 7863              		.loc 30 95 0 discriminator 2
 7864 0038 9342     		cmp	r3, r2
 7865 003a F9D1     		bne	.L478
 7866              	.LBE200:
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             }
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             alt_Sum = baroAltitudeToHoldTarget*alt_buffer_size;
 7867              		.loc 30 98 0
 7868 003c 9FED110A 		flds	s0, .L480+16
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 7869              		.loc 30 99 0
 7870 0040 1149     		ldr	r1, .L480+20
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             alt_Sum = baroAltitudeToHoldTarget*alt_buffer_size;
 7871              		.loc 30 98 0
 7872 0042 1248     		ldr	r0, .L480+24
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #elif defined AltitudeHoldBaro
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 7873              		.loc 30 111 0
 7874 0044 124A     		ldr	r2, .L480+28
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             alt_Sum = baroAltitudeToHoldTarget*alt_buffer_size;
 7875              		.loc 30 98 0
 7876 0046 27EE800A 		fmuls	s0, s15, s0
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 7877              		.loc 30 99 0
 7878 004a 0023     		movs	r3, #0
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             alt_Sum = baroAltitudeToHoldTarget*alt_buffer_size;
 7879              		.loc 30 98 0
 7880 004c 80ED000A 		fsts	s0, [r0, #0]
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 7881              		.loc 30 99 0
 7882 0050 C1F8F430 		str	r3, [r1, #244]	@ float
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
 7883              		.loc 30 100 0
 7884 0054 C1ED3B7A 		fsts	s15, [r1, #236]
 7885              		.loc 30 111 0
 7886 0058 D368     		ldr	r3, [r2, #12]
 7887 005a 0E48     		ldr	r0, .L480+32
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           LidarHoldThrottle = altitudeHoldThrottle;
 7888              		.loc 30 112 0
 7889 005c 0E49     		ldr	r1, .L480+36
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 7890              		.loc 30 111 0
 7891 005e 0360     		str	r3, [r0, #0]
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAltitudeHoldInitialized = true;
 7892              		.loc 30 113 0
 7893 0060 0122     		movs	r2, #1
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           LidarHoldThrottle = altitudeHoldThrottle;
 7894              		.loc 30 112 0
 7895 0062 0B60     		str	r3, [r1, #0]
 7896              		.loc 30 113 0
 7897 0064 2A70     		strb	r2, [r5, #0]
 7898              	.L477:
 7899              	.LBE199:
 7900              	.LBE198:
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         altitudeHoldState = ON;
 7901              		.loc 30 115 0
 7902 0066 0122     		movs	r2, #1
 7903 0068 2270     		strb	r2, [r4, #0]
 7904 006a 38BD     		pop	{r3, r4, r5, pc}
 7905              	.L475:
 7906              	.LBE197:
 7907              	.LBE196:
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     } 
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isAltitudeHoldInitialized = false;
 7908              		.loc 30 119 0
 7909 006c 0249     		ldr	r1, .L480+4
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       altitudeHoldState = OFF;
 7910              		.loc 30 120 0
 7911 006e 2070     		strb	r0, [r4, #0]
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isAltitudeHoldInitialized = false;
 7912              		.loc 30 119 0
 7913 0070 0870     		strb	r0, [r1, #0]
 7914              	.L474:
 7915 0072 38BD     		pop	{r3, r4, r5, pc}
 7916              	.L481:
 7917              		.align	2
 7918              	.L480:
 7919 0074 00000000 		.word	.LANCHOR98
 7920 0078 00000000 		.word	.LANCHOR129
 7921 007c 00000000 		.word	.LANCHOR99
 7922 0080 FCFFFFFF 		.word	.LANCHOR97-4
 7923 0084 00004842 		.word	1112014848
 7924 0088 00000000 		.word	.LANCHOR9
 7925 008c 00000000 		.word	.LANCHOR96
 7926 0090 00000000 		.word	.LANCHOR1
 7927 0094 00000000 		.word	.LANCHOR104
 7928 0098 00000000 		.word	.LANCHOR103
 7929              	.LBE195:
 7930              		.cfi_endproc
 7931              	.LFE236:
 7933              		.section	.text._Z14processHeadingv,"ax",%progbits
 7934              		.align	1
 7935              		.global	_Z14processHeadingv
 7936              		.thumb
 7937              		.thumb_func
 7939              	_Z14processHeadingv:
 7940              	.LFB239:
 7941              		.file 31 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** #ifndef _AQ_HEADING_CONTROL_PROCESSOR_H_
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** #define _AQ_HEADING_CONTROL_PROCESSOR_H_
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** float setHeading          = 0;
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** unsigned long headingTime = micros();
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** /**
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * processHeading
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  *
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * This function will calculate the craft heading correction depending 
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * of the users command. Heading correction is process with the gyro
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  * or a magnetometer
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****  */
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** void processHeading()
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** {
 7942              		.loc 31 38 0
 7943              		.cfi_startproc
 7944              		@ args = 0, pretend = 0, frame = 0
 7945              		@ frame_needed = 0, uses_anonymous_args = 0
 7946 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7947              	.LCFI76:
 7948              		.cfi_def_cfa_offset 24
 7949              		.cfi_offset 14, -4
 7950              		.cfi_offset 7, -8
 7951              		.cfi_offset 6, -12
 7952              		.cfi_offset 5, -16
 7953              		.cfi_offset 4, -20
 7954              		.cfi_offset 3, -24
 7955              	.LBB201:
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   if (headingHoldConfig == ON) {
 7956              		.loc 31 39 0
 7957 0002 5C48     		ldr	r0, .L503
 7958 0004 5C4E     		ldr	r6, .L503+4
 7959 0006 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 7960 0008 5C4C     		ldr	r4, .L503+8
 7961 000a 012B     		cmp	r3, #1
 7962 000c 7ED1     		bne	.L483
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     #if defined(HeadingMagHold)
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     #else
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 7963              		.loc 31 44 0
 7964 000e 5C4A     		ldr	r2, .L503+12
 7965 0010 5C49     		ldr	r1, .L503+16
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     #endif
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // Always center relative heading around absolute heading chosen during yaw command
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // This assumes that an incorrect yaw can't be forced on the AeroQuad >180 or <-180 degrees
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // This is done so that AeroQuad does not accidentally hit transition between 0 and 360 or -180
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // AKA - THERE IS A BUG HERE - if relative heading is greater than 180 degrees, the PID will sw
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // Doubt that will happen as it would have to be uncommanded.
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7966              		.loc 31 52 0
 7967 0012 5D4B     		ldr	r3, .L503+20
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 7968              		.loc 31 44 0
 7969 0014 92ED007A 		flds	s14, [r2, #0]
 7970 0018 DFED5C7A 		flds	s15, .L503+24
 7971              		.loc 31 52 0
 7972 001c 5C4A     		ldr	r2, .L503+28
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 7973              		.loc 31 44 0
 7974 001e 67EE277A 		fmuls	s15, s14, s15
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     if (heading <= (setHeading - 180)) {
 7975              		.loc 31 53 0
 7976 0022 9FED5C6A 		flds	s12, .L503+32
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7977              		.loc 31 52 0
 7978 0026 92ED007A 		flds	s14, [r2, #0]
 7979              		.loc 31 53 0
 7980 002a 77EE465A 		fsubs	s11, s14, s12
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7981              		.loc 31 52 0
 7982 002e 77EEC76A 		fsubs	s13, s15, s14
 7983              		.loc 31 53 0
 7984 0032 F4EEE57A 		fcmpes	s15, s11
 7985 0036 F1EE10FA 		fmstat
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 7986              		.loc 31 44 0
 7987 003a C1ED007A 		fsts	s15, [r1, #0]
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 7988              		.loc 31 52 0
 7989 003e C3ED006A 		fsts	s13, [r3, #0]
 7990              		.loc 31 53 0
 7991 0042 05D8     		bhi	.L484
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       relativeHeading += 360;
 7992              		.loc 31 54 0
 7993 0044 9FED540A 		flds	s0, .L503+36
 7994 0048 76EE806A 		fadds	s13, s13, s0
 7995 004c C3ED006A 		fsts	s13, [r3, #0]
 7996              	.L484:
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     if (heading >= (setHeading + 180)) {
 7997              		.loc 31 56 0
 7998 0050 77EE060A 		fadds	s1, s14, s12
 7999 0054 F4EEE07A 		fcmpes	s15, s1
 8000 0058 F1EE10FA 		fmstat
 8001 005c 07DB     		blt	.L486
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       relativeHeading -= 360;
 8002              		.loc 31 57 0
 8003 005e 93ED002A 		flds	s4, [r3, #0]
 8004 0062 DFED4D1A 		flds	s3, .L503+36
 8005 0066 32EE611A 		fsubs	s2, s4, s3
 8006 006a 83ED001A 		fsts	s2, [r3, #0]
 8007              	.L486:
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** 
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     // Apply heading hold only when throttle high enough to start flight
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     if (receiverCommand[THROTTLE] > MINCHECK ) { 
 8008              		.loc 31 61 0
 8009 006e F068     		ldr	r0, [r6, #12]
 8010 0070 40F24C4C 		movw	ip, #1100
 8011 0074 6045     		cmp	r0, ip
 8012 0076 42DD     		ble	.L488
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       #if defined (UseGPSNavigator)
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         if (( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) > (MIDCOMMAND + 25)) || 
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             ( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) < (MIDCOMMAND - 25))) {
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       #else
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         if ((receiverCommand[ZAXIS] > (MIDCOMMAND + 25)) || 
 8013              		.loc 31 67 0
 8014 0078 3F48     		ldr	r0, .L503+4
 8015 007a 8168     		ldr	r1, [r0, #8]
 8016 007c A1F5B860 		sub	r0, r1, #1472
 8017 0080 C11E     		subs	r1, r0, #3
 8018 0082 3229     		cmp	r1, #50
 8019 0084 0ED9     		bls	.L489
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             (receiverCommand[ZAXIS] < (MIDCOMMAND - 25))) {
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       #endif
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         // If commanding yaw, turn off heading hold and store latest heading
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         setHeading = heading;
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHold = 0;
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 8020              		.loc 31 75 0
 8021 0086 4549     		ldr	r1, .L503+40
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHold = 0;
 8022              		.loc 31 74 0
 8023 0088 0023     		movs	r3, #0
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         setHeading = heading;
 8024              		.loc 31 73 0
 8025 008a C2ED007A 		fsts	s15, [r2, #0]
 8026              		.loc 31 75 0
 8027 008e C1F8A030 		str	r3, [r1, #160]	@ float
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHoldState = OFF;
 8028              		.loc 31 76 0
 8029 0092 434A     		ldr	r2, .L503+44
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingTime = currentTime;
 8030              		.loc 31 77 0
 8031 0094 4349     		ldr	r1, .L503+48
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHold = 0;
 8032              		.loc 31 74 0
 8033 0096 2360     		str	r3, [r4, #0]	@ float
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         headingHoldState = OFF;
 8034              		.loc 31 76 0
 8035 0098 0020     		movs	r0, #0
 8036 009a 1070     		strb	r0, [r2, #0]
 8037              		.loc 31 77 0
 8038 009c 424B     		ldr	r3, .L503+52
 8039 009e 0A68     		ldr	r2, [r1, #0]
 8040 00a0 1A60     		str	r2, [r3, #0]
 8041 00a2 33E0     		b	.L483
 8042              	.L489:
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       }
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       else {
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         if (relativeHeading < 0.25 && relativeHeading > -0.25) {
 8043              		.loc 31 80 0
 8044 00a4 93ED007A 		flds	s14, [r3, #0]
 8045 00a8 F5EE002A 		fconsts	s5, #80
 8046 00ac B4EEE27A 		fcmpes	s14, s5
 8047 00b0 F1EE10FA 		fmstat
 8048 00b4 06D5     		bpl	.L490
 8049              		.loc 31 80 0 is_stmt 0 discriminator 1
 8050 00b6 BDEE003A 		fconsts	s6, #208
 8051 00ba B4EEC37A 		fcmpes	s14, s6
 8052 00be F1EE10FA 		fmstat
 8053 00c2 1EDC     		bgt	.L502
 8054              	.L490:
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingHold = 0;
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           PID[HEADING_HOLD_PID_IDX].integratedError = 0;
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         }
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         else if (headingHoldState == OFF) { // quick fix to soften heading hold on new heading
 8055              		.loc 31 84 0 is_stmt 1
 8056 00c4 3649     		ldr	r1, .L503+44
 8057 00c6 384D     		ldr	r5, .L503+52
 8058 00c8 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 8059 00ca 364F     		ldr	r7, .L503+48
 8060 00cc 68B9     		cbnz	r0, .L493
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           if ((currentTime - headingTime) > 500000) {
 8061              		.loc 31 85 0
 8062 00ce 3B68     		ldr	r3, [r7, #0]
 8063 00d0 2F68     		ldr	r7, [r5, #0]
 8064 00d2 3648     		ldr	r0, .L503+56
 8065 00d4 DF1B     		subs	r7, r3, r7
 8066 00d6 8742     		cmp	r7, r0
 8067 00d8 18D9     		bls	.L483
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingHoldState = ON;
 8068              		.loc 31 86 0
 8069 00da 0120     		movs	r0, #1
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingTime = currentTime;
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             setHeading = heading;
 8070              		.loc 31 88 0
 8071 00dc C2ED007A 		fsts	s15, [r2, #0]
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingHold = 0;
 8072              		.loc 31 89 0
 8073 00e0 0022     		movs	r2, #0
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingHoldState = ON;
 8074              		.loc 31 86 0
 8075 00e2 0870     		strb	r0, [r1, #0]
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****             headingTime = currentTime;
 8076              		.loc 31 87 0
 8077 00e4 2B60     		str	r3, [r5, #0]
 8078              		.loc 31 89 0
 8079 00e6 2260     		str	r2, [r4, #0]	@ float
 8080 00e8 10E0     		b	.L483
 8081              	.L493:
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           }
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         }
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         else {
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         // No new yaw input, calculate current heading vs. desired heading heading hold
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         // Relative heading is always centered around zero
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 8082              		.loc 31 95 0
 8083 00ea 17EE101A 		fmrs	r1, s14
 8084 00ee 0020     		movs	r0, #0
 8085 00f0 2F4A     		ldr	r2, .L503+60
 8086 00f2 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingTime = currentTime; // quick fix to soften heading hold, wait 100ms before applyin
 8087              		.loc 31 96 0
 8088 00f6 3968     		ldr	r1, [r7, #0]
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 8089              		.loc 31 95 0
 8090 00f8 2060     		str	r0, [r4, #0]	@ float
 8091              		.loc 31 96 0
 8092 00fa 2960     		str	r1, [r5, #0]
 8093 00fc 06E0     		b	.L483
 8094              	.L488:
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****         }
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       }
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     else {
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       // minimum throttle not reached, use off settings
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       setHeading = heading;
 8095              		.loc 31 102 0
 8096 00fe C2ED007A 		fsts	s15, [r2, #0]
 8097              	.L502:
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       headingHold = 0;
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 8098              		.loc 31 104 0
 8099 0102 264A     		ldr	r2, .L503+40
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****       headingHold = 0;
 8100              		.loc 31 103 0
 8101 0104 0023     		movs	r3, #0
 8102 0106 2360     		str	r3, [r4, #0]	@ float
 8103              		.loc 31 104 0
 8104 0108 C2F8A030 		str	r3, [r2, #160]	@ float
 8105              	.L483:
 8106              	.LVL407:
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     }
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   }
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   // NEW SI Version
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   #if defined (UseGPSNavigator) 
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS] + gpsYawAxisCorrection) * 
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   #else
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 8107              		.loc 31 111 0
 8108 010c 294B     		ldr	r3, .L503+64
 8109 010e B268     		ldr	r2, [r6, #8]
 8110 0110 9968     		ldr	r1, [r3, #8]
 8111 0112 501A     		subs	r0, r2, r1
 8112 0114 07EE900A 		fmsr	s15, r0	@ int
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   #endif
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   const float commandedYaw = constrain(receiverSiData + radians(headingHold), -PI, PI);
 8113              		.loc 31 114 0
 8114 0118 D4ED004A 		flds	s9, [r4, #0]
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 8115              		.loc 31 111 0
 8116 011c F8EEE73A 		fsitos	s7, s15
 8117              		.loc 31 114 0
 8118 0120 DFED257A 		flds	s15, .L503+68
 8119 0124 9FED254A 		flds	s8, .L503+72
 8120 0128 64EEA77A 		fmuls	s15, s9, s15
 8121 012c 43EE847A 		fmacs	s15, s7, s8
 8122 0130 9FED237A 		flds	s14, .L503+76
 8123 0134 F4EEC77A 		fcmpes	s15, s14
 8124 0138 F1EE10FA 		fmstat
 8125 013c 0BD4     		bmi	.L496
 8126              		.loc 31 114 0 is_stmt 0 discriminator 2
 8127 013e 9FED215A 		flds	s10, .L503+80
 8128 0142 F4EE457A 		fcmps	s15, s10
 8129 0146 F1EE10FA 		fmstat
 8130 014a CCBF     		ite	gt
 8131 014c 15EE100A 		fmrsgt	r0, s10
 8132 0150 17EE900A 		fmrsle	r0, s15
 8133 0154 01E0     		b	.L494
 8134              	.L496:
 8135              		.loc 31 114 0
 8136 0156 17EE100A 		fmrs	r0, s14
 8137              	.L494:
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h ****   motorAxisCommandYaw = updatePID(commandedYaw, gyroRate[ZAXIS], &PID[ZAXIS_PID_IDX]);
 8138              		.loc 31 115 0 is_stmt 1 discriminator 6
 8139 015a 1B49     		ldr	r1, .L503+84
 8140 015c 1B4A     		ldr	r2, .L503+88
 8141 015e 8968     		ldr	r1, [r1, #8]	@ float
 8142 0160 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 8143              	.LVL408:
 8144 0164 05EE900A 		fmsr	s11, r0
 8145 0168 1948     		ldr	r0, .L503+92
 8146 016a BDEEE56A 		ftosizs	s12, s11
 8147 016e 80ED006A 		fsts	s12, [r0, #0]	@ int
 8148              	.LBE201:
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** }
 8149              		.loc 31 116 0 discriminator 6
 8150 0172 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 8151              	.L504:
 8152              		.align	2
 8153              	.L503:
 8154 0174 00000000 		.word	.LANCHOR130
 8155 0178 00000000 		.word	.LANCHOR1
 8156 017c 00000000 		.word	.LANCHOR134
 8157 0180 00000000 		.word	.LANCHOR20
 8158 0184 00000000 		.word	.LANCHOR131
 8159 0188 00000000 		.word	.LANCHOR133
 8160 018c E12E6542 		.word	1113927393
 8161 0190 00000000 		.word	.LANCHOR132
 8162 0194 00003443 		.word	1127481344
 8163 0198 0000B443 		.word	1135869952
 8164 019c 00000000 		.word	.LANCHOR9
 8165 01a0 00000000 		.word	.LANCHOR135
 8166 01a4 00000000 		.word	.LANCHOR7
 8167 01a8 00000000 		.word	.LANCHOR136
 8168 01ac 20A10700 		.word	500000
 8169 01b0 8C000000 		.word	.LANCHOR9+140
 8170 01b4 00000000 		.word	.LANCHOR3
 8171 01b8 35FA8E3C 		.word	1016003125
 8172 01bc 0BD7A33B 		.word	1000593163
 8173 01c0 DB0F49C0 		.word	-1068953637
 8174 01c4 DB0F4940 		.word	1078530011
 8175 01c8 00000000 		.word	.LANCHOR19
 8176 01cc 38000000 		.word	.LANCHOR9+56
 8177 01d0 00000000 		.word	.LANCHOR93
 8178              		.cfi_endproc
 8179              	.LFE239:
 8181              		.section	.text._Z20processFlightControlv,"ax",%progbits
 8182              		.align	1
 8183              		.global	_Z20processFlightControlv
 8184              		.thumb
 8185              		.thumb_func
 8187              	_Z20processFlightControlv:
 8188              	.LFB232:
 276:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** /**
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * processFlightControl
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  *
 280:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  * Main flight control processos function
 281:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****  */
 282:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** void processFlightControl() {
 8189              		.loc 29 282 0
 8190              		.cfi_startproc
 8191              		@ args = 0, pretend = 0, frame = 0
 8192              		@ frame_needed = 0, uses_anonymous_args = 0
 8193 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 8194              	.LCFI77:
 8195              		.cfi_def_cfa_offset 24
 8196              		.cfi_offset 14, -4
 8197              		.cfi_offset 7, -8
 8198              		.cfi_offset 6, -12
 8199              		.cfi_offset 5, -16
 8200              		.cfi_offset 4, -20
 8201              		.cfi_offset 3, -24
 8202              	.LBB202:
 283:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ********************** Calculate Flight Error ***************************
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   calculateFlightError();
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 287:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ********************** Update Yaw ***************************************
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   processHeading();
 289:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 290:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  // 50hz task
 8203              		.loc 29 290 0
 8204 0002 2F4C     		ldr	r4, .L521
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   calculateFlightError();
 8205              		.loc 29 285 0
 8206 0004 FFF7FEFF 		bl	_Z20calculateFlightErrorv
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   processHeading();
 8207              		.loc 29 288 0
 8208 0008 FFF7FEFF 		bl	_Z14processHeadingv
 8209              		.loc 29 290 0
 8210 000c 2368     		ldr	r3, [r4, #0]
 8211 000e D907     		lsls	r1, r3, #31
 8212 0010 03D4     		bmi	.L506
 291:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process position hold or navigation **************************
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined (UseGPS)
 294:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #if defined (UseGPSNavigator)
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         processGpsNavigation();
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       #endif  
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 298:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Altitude hold **************************
 300:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processAltitudeHold();
 8213              		.loc 29 301 0
 8214 0012 FFF7FEFF 		bl	_Z19processAltitudeHoldv
 302:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #else
 303:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
 304:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Battery monitor hold **************************
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined BattMonitor && defined BattMonitorAutoDescent
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processBatteryMonitorThrottleAdjustment();
 309:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Auto-Descent  **************************
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined AutoLanding
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processAutoLandingAltitudeCorrection();
 314:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process throttle correction ********************
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     processThrottleCorrection();
 8215              		.loc 29 317 0
 8216 0016 FFF7FEFF 		bl	_Z25processThrottleCorrectionv
 8217              	.L506:
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 319:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** if (frameCounter % HOKUYO_TASK_SPEED == 0) {  // 10hz task   
 8218              		.loc 29 320 0
 8219 001a 2268     		ldr	r2, [r4, #0]
 8220 001c 0A24     		movs	r4, #10
 8221 001e B2FBF4F1 		udiv	r1, r2, r4
 8222 0022 04FB1120 		mls	r0, r4, r1, r2
 8223 0026 08B9     		cbnz	r0, .L507
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     // ********************** Process Hokuyo hold **************************
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #if defined Lidar2D
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       processHokuyoHold();
 8224              		.loc 29 323 0
 8225 0028 FFF7FEFF 		bl	_Z17processHokuyoHoldv
 8226              	.L507:
 324:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     #endif
 325:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ********************** Calculate Motor Commands *************************
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (motorArmed && safetyCheck) {
 8227              		.loc 29 329 0
 8228 002c 254C     		ldr	r4, .L521+4
 8229 002e 2578     		ldrb	r5, [r4, #0]	@ zero_extendqisi2
 8230 0030 25B1     		cbz	r5, .L508
 8231              		.loc 29 329 0 is_stmt 0 discriminator 1
 8232 0032 2548     		ldr	r0, .L521+8
 8233 0034 0378     		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 8234 0036 0BB1     		cbz	r3, .L508
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     applyMotorCommand();
 8235              		.loc 29 330 0 is_stmt 1
 8236 0038 FFF7FEFF 		bl	_Z17applyMotorCommandv
 8237              	.L508:
 8238              	.LBB203:
 331:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   } 
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // *********************** process min max motor command *******************
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   processMinMaxCommand();
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // If throttle in minimum position, don't apply yaw
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 8239              		.loc 29 337 0
 8240 003c 234D     		ldr	r5, .L521+12
 8241              	.LBE203:
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   processMinMaxCommand();
 8242              		.loc 29 334 0
 8243 003e FFF7FEFF 		bl	_Z20processMinMaxCommandv
 8244              	.LBB205:
 8245              		.loc 29 337 0
 8246 0042 E968     		ldr	r1, [r5, #12]
 8247 0044 40F24B42 		movw	r2, #1099
 8248 0048 9142     		cmp	r1, r2
 8249 004a 2149     		ldr	r1, .L521+16
 8250 004c 01DD     		ble	.L509
 8251              	.L513:
 8252              	.LVL409:
 8253              	.LBB204:
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 342:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       else {
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****         motorMaxCommand[motor] = minArmedThrottle;
 8254              		.loc 29 344 0 discriminator 1
 8255 004e 0023     		movs	r3, #0
 8256 0050 15E0     		b	.L510
 8257              	.LVL410:
 8258              	.L509:
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8259              		.loc 29 340 0
 8260 0052 204E     		ldr	r6, .L521+20
 8261 0054 204F     		ldr	r7, .L521+24
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 8262              		.loc 29 339 0
 8263 0056 214B     		ldr	r3, .L521+28
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8264              		.loc 29 340 0
 8265 0058 3678     		ldrb	r6, [r6, #0]	@ zero_extendqisi2
 8266 005a 3D78     		ldrb	r5, [r7, #0]	@ zero_extendqisi2
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 8267              		.loc 29 339 0
 8268 005c 1A68     		ldr	r2, [r3, #0]
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8269              		.loc 29 340 0
 8270 005e 0023     		movs	r3, #0
 8271              	.L512:
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 8272              		.loc 29 339 0
 8273 0060 CA50     		str	r2, [r1, r3]
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8274              		.loc 29 340 0
 8275 0062 2EB1     		cbz	r6, .L517
 8276              		.loc 29 344 0 discriminator 1
 8277 0064 002D     		cmp	r5, #0
 8278 0066 14BF     		ite	ne
 8279 0068 1046     		movne	r0, r2
 8280 006a 4FF4FA60 		moveq	r0, #2000
 8281 006e 00E0     		b	.L511
 8282              	.L517:
 8283              		.loc 29 344 0 is_stmt 0
 8284 0070 1046     		mov	r0, r2
 8285              	.L511:
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 8286              		.loc 29 340 0 is_stmt 1
 8287 0072 1B4F     		ldr	r7, .L521+32
 8288 0074 D851     		str	r0, [r3, r7]
 8289 0076 0433     		adds	r3, r3, #4
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8290              		.loc 29 338 0
 8291 0078 102B     		cmp	r3, #16
 8292 007a F1D1     		bne	.L512
 8293 007c E7E7     		b	.L513
 8294              	.LVL411:
 8295              	.L510:
 8296              	.LBE204:
 8297              	.LBE205:
 8298              	.LBB206:
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****       }
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     }
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 348:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 349:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // Apply limits to motor commands
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     motorCommand[motor] = constrain(motorCommand[motor], motorMinCommand[motor], motorMaxCommand[mo
 8299              		.loc 29 351 0
 8300 007e 1948     		ldr	r0, .L521+36
 8301 0080 CA58     		ldr	r2, [r1, r3]
 8302 0082 1D58     		ldr	r5, [r3, r0]
 8303 0084 9542     		cmp	r5, r2
 8304 0086 04DB     		blt	.L514
 8305              		.loc 29 351 0 is_stmt 0 discriminator 2
 8306 0088 154A     		ldr	r2, .L521+32
 8307 008a 9A58     		ldr	r2, [r3, r2]
 8308 008c 9542     		cmp	r5, r2
 8309 008e B8BF     		it	lt
 8310 0090 2A46     		movlt	r2, r5
 8311              	.L514:
 8312              		.loc 29 351 0 discriminator 6
 8313 0092 C250     		str	r2, [r0, r3]
 8314 0094 0433     		adds	r3, r3, #4
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8315              		.loc 29 350 0 is_stmt 1 discriminator 6
 8316 0096 102B     		cmp	r3, #16
 8317 0098 F1D1     		bne	.L510
 8318              	.LBE206:
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 353:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** 
 354:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // ESC Calibration
 355:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (motorArmed == OFF) {
 8319              		.loc 29 355 0
 8320 009a 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 8321 009c 08B9     		cbnz	r0, .L515
 356:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     processCalibrateESC();
 8322              		.loc 29 356 0
 8323 009e FFF7FEFF 		bl	_Z19processCalibrateESCv
 8324              	.L515:
 357:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 358:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   
 359:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   // *********************** Command Motors **********************
 360:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   if (motorArmed == ON && safetyCheck == ON) {
 8325              		.loc 29 360 0
 8326 00a2 2178     		ldrb	r1, [r4, #0]	@ zero_extendqisi2
 8327 00a4 0129     		cmp	r1, #1
 8328 00a6 09D1     		bne	.L505
 8329              		.loc 29 360 0 is_stmt 0 discriminator 1
 8330 00a8 074B     		ldr	r3, .L521+8
 8331 00aa 93F800C0 		ldrb	ip, [r3, #0]	@ zero_extendqisi2
 8332 00ae BCF1010F 		cmp	ip, #1
 8333 00b2 03D1     		bne	.L505
 8334              	.LBE202:
 361:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     writeMotors();
 362:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****   }
 363:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h **** }
 8335              		.loc 29 363 0 is_stmt 1
 8336 00b4 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 8337              	.LBB207:
 361:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightControlProcessor.h ****     writeMotors();
 8338              		.loc 29 361 0
 8339 00b8 FFF7FEBF 		b	_Z11writeMotorsv
 8340              	.L505:
 8341 00bc F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 8342              	.L522:
 8343 00be 00BF     		.align	2
 8344              	.L521:
 8345 00c0 00000000 		.word	.LANCHOR137
 8346 00c4 00000000 		.word	.LANCHOR138
 8347 00c8 00000000 		.word	.LANCHOR124
 8348 00cc 00000000 		.word	.LANCHOR1
 8349 00d0 00000000 		.word	.LANCHOR126
 8350 00d4 00000000 		.word	.LANCHOR8
 8351 00d8 00000000 		.word	.LANCHOR119
 8352 00dc 00000000 		.word	.LANCHOR125
 8353 00e0 00000000 		.word	.LANCHOR127
 8354 00e4 00000000 		.word	.LANCHOR56
 8355              	.LBE207:
 8356              		.cfi_endproc
 8357              	.LFE232:
 8359              		.section	.text._Z12nvrReadFloati,"ax",%progbits
 8360              		.align	1
 8361              		.global	_Z12nvrReadFloati
 8362              		.thumb
 8363              		.thumb_func
 8365              	_Z12nvrReadFloati:
 8366              	.LFB240:
 8367              		.file 32 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   This program is free software: you can redistribute it and/or modify
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   it under the terms of the GNU General Public License as published by
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   the Free Software Foundation, either version 3 of the License, or
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   (at your option) any later version.
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   This program is distributed in the hope that it will be useful,
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   GNU General Public License for more details.
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   You should have received a copy of the GNU General Public License
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // Special thanks for 1k space optimization update from Ala42
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // http://aeroquad.com/showthread.php?1369-The-big-enhancement-addition-to-2.0-code&p=13359&viewful
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifndef _AQ_DATA_STORAGE_H_
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #define _AQ_DATA_STORAGE_H_
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // Utilities for writing and reading from the EEPROM
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** float nvrReadFloat(int address) {
 8368              		.loc 32 28 0
 8369              		.cfi_startproc
 8370              		@ args = 0, pretend = 0, frame = 0
 8371              		@ frame_needed = 0, uses_anonymous_args = 0
 8372              	.LVL412:
 8373 0000 38B5     		push	{r3, r4, r5, lr}
 8374              	.LCFI78:
 8375              		.cfi_def_cfa_offset 16
 8376              		.cfi_offset 14, -4
 8377              		.cfi_offset 5, -8
 8378              		.cfi_offset 4, -12
 8379              		.cfi_offset 3, -16
 8380              	.LBB208:
 8381              	.LBB209:
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union floatStore {
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte floatByte[4];
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short floatUShort[2];
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     float floatVal;
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } floatOut;
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     floatOut.floatUShort[i] = EEPROM.read(address + 2*i);
 8382              		.loc 32 37 0
 8383 0002 85B2     		uxth	r5, r0
 8384 0004 2946     		mov	r1, r5
 8385 0006 0748     		ldr	r0, .L524
 8386              	.LVL413:
 8387 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8388 000c 0024     		movs	r4, #0
 8389              	.LVL414:
 8390 000e A91C     		adds	r1, r5, #2
 8391 0010 60F30F04 		bfi	r4, r0, #0, #16
 8392              	.LVL415:
 8393 0014 89B2     		uxth	r1, r1
 8394 0016 0348     		ldr	r0, .L524
 8395 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8396 001c 60F31F44 		bfi	r4, r0, #16, #16
 8397              	.LVL416:
 8398              	.LBE209:
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 4; i++) {
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     floatOut.floatByte[i] = EEPROM.read(address + i);
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   return floatOut.floatVal;
 8399              		.loc 32 45 0
 8400 0020 2046     		mov	r0, r4	@ float
 8401              	.LBE208:
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8402              		.loc 32 46 0
 8403 0022 38BD     		pop	{r3, r4, r5, pc}
 8404              	.L525:
 8405              		.align	2
 8406              	.L524:
 8407 0024 00000000 		.word	EEPROM
 8408              		.cfi_endproc
 8409              	.LFE240:
 8411              		.section	.text._Z13nvrWriteFloatfi,"ax",%progbits
 8412              		.align	1
 8413              		.global	_Z13nvrWriteFloatfi
 8414              		.thumb
 8415              		.thumb_func
 8417              	_Z13nvrWriteFloatfi:
 8418              	.LFB241:
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWriteFloat(float value, int address) {
 8419              		.loc 32 48 0
 8420              		.cfi_startproc
 8421              		@ args = 0, pretend = 0, frame = 0
 8422              		@ frame_needed = 0, uses_anonymous_args = 0
 8423              	.LVL417:
 8424 0000 38B5     		push	{r3, r4, r5, lr}
 8425              	.LCFI79:
 8426              		.cfi_def_cfa_offset 16
 8427              		.cfi_offset 14, -4
 8428              		.cfi_offset 5, -8
 8429              		.cfi_offset 4, -12
 8430              		.cfi_offset 3, -16
 8431              	.LBB210:
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union floatStore {
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte floatByte[4];
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short floatUShort[2];
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     float floatVal;
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } floatIn;
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   floatIn.floatVal = value;
 8432              		.loc 32 55 0
 8433 0002 0446     		mov	r4, r0	@ float
 8434              	.LVL418:
 8435              	.LBB211:
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 8436              		.loc 32 58 0
 8437 0004 8DB2     		uxth	r5, r1
 8438 0006 2946     		mov	r1, r5
 8439              	.LVL419:
 8440 0008 A2B2     		uxth	r2, r4
 8441 000a 0548     		ldr	r0, .L527
 8442              	.LVL420:
 8443 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 8444              	.LVL421:
 8445 0010 A91C     		adds	r1, r5, #2
 8446 0012 0348     		ldr	r0, .L527
 8447 0014 89B2     		uxth	r1, r1
 8448 0016 220C     		lsrs	r2, r4, #16
 8449              	.LBE211:
 8450              	.LBE210:
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 4; i++) {
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + i, floatIn.floatByte[i]);
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8451              		.loc 32 65 0
 8452 0018 BDE83840 		pop	{r3, r4, r5, lr}
 8453              	.LBB213:
 8454              	.LBB212:
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 8455              		.loc 32 58 0
 8456 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 8457              	.L528:
 8458              		.align	2
 8459              	.L527:
 8460 0020 00000000 		.word	EEPROM
 8461              	.LBE212:
 8462              	.LBE213:
 8463              		.cfi_endproc
 8464              	.LFE241:
 8466              		.section	.text._Z11nvrReadLongi,"ax",%progbits
 8467              		.align	1
 8468              		.global	_Z11nvrReadLongi
 8469              		.thumb
 8470              		.thumb_func
 8472              	_Z11nvrReadLongi:
 8473              	.LFB242:
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** long nvrReadLong(int address) {
 8474              		.loc 32 67 0
 8475              		.cfi_startproc
 8476              		@ args = 0, pretend = 0, frame = 0
 8477              		@ frame_needed = 0, uses_anonymous_args = 0
 8478              	.LVL422:
 8479 0000 38B5     		push	{r3, r4, r5, lr}
 8480              	.LCFI80:
 8481              		.cfi_def_cfa_offset 16
 8482              		.cfi_offset 14, -4
 8483              		.cfi_offset 5, -8
 8484              		.cfi_offset 4, -12
 8485              		.cfi_offset 3, -16
 8486              	.LBB214:
 8487              	.LBB215:
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union longStore {
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte longByte[4];
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short longUShort[2];
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     long longVal;
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } longOut;  
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     longOut.longUShort[i] = EEPROM.read(address + 2*i);
 8488              		.loc 32 76 0
 8489 0002 85B2     		uxth	r5, r0
 8490 0004 2946     		mov	r1, r5
 8491 0006 0748     		ldr	r0, .L530
 8492              	.LVL423:
 8493 0008 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8494 000c 0024     		movs	r4, #0
 8495              	.LVL424:
 8496 000e A91C     		adds	r1, r5, #2
 8497 0010 60F30F04 		bfi	r4, r0, #0, #16
 8498              	.LVL425:
 8499 0014 89B2     		uxth	r1, r1
 8500 0016 0348     		ldr	r0, .L530
 8501 0018 FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 8502 001c 60F31F44 		bfi	r4, r0, #16, #16
 8503              	.LVL426:
 8504              	.LBE215:
 8505              	.LBE214:
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = 0; i < 4; i++) {
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     longOut.longByte[i] = EEPROM.read(address + i);
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   return longOut.longVal;
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8506              		.loc 32 85 0
 8507 0020 2046     		mov	r0, r4
 8508 0022 38BD     		pop	{r3, r4, r5, pc}
 8509              	.L531:
 8510              		.align	2
 8511              	.L530:
 8512 0024 00000000 		.word	EEPROM
 8513              		.cfi_endproc
 8514              	.LFE242:
 8516              		.section	.text._Z12nvrWriteLongli,"ax",%progbits
 8517              		.align	1
 8518              		.global	_Z12nvrWriteLongli
 8519              		.thumb
 8520              		.thumb_func
 8522              	_Z12nvrWriteLongli:
 8523              	.LFB243:
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWriteLong(long value, int address) {
 8524              		.loc 32 87 0
 8525              		.cfi_startproc
 8526              		@ args = 0, pretend = 0, frame = 0
 8527              		@ frame_needed = 0, uses_anonymous_args = 0
 8528              	.LVL427:
 8529 0000 38B5     		push	{r3, r4, r5, lr}
 8530              	.LCFI81:
 8531              		.cfi_def_cfa_offset 16
 8532              		.cfi_offset 14, -4
 8533              		.cfi_offset 5, -8
 8534              		.cfi_offset 4, -12
 8535              		.cfi_offset 3, -16
 8536              		.loc 32 87 0
 8537 0002 0446     		mov	r4, r0
 8538              	.LBB216:
 8539              	.LBB217:
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   union longStore {
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     byte longByte[4];
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     unsigned short longUShort[2];
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     long longVal;
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   } longIn;  
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   longIn.longVal = value;
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 2; i++) {
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 8540              		.loc 32 98 0
 8541 0004 8DB2     		uxth	r5, r1
 8542 0006 2946     		mov	r1, r5
 8543              	.LVL428:
 8544 0008 A2B2     		uxth	r2, r4
 8545 000a 0548     		ldr	r0, .L533
 8546              	.LVL429:
 8547 000c FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 8548              	.LVL430:
 8549 0010 A91C     		adds	r1, r5, #2
 8550 0012 0348     		ldr	r0, .L533
 8551 0014 89B2     		uxth	r1, r1
 8552 0016 220C     		lsrs	r2, r4, #16
 8553              	.LBE217:
 8554              	.LBE216:
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #else
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (int i = 0; i < 4; i++) {
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + i, longIn.longByte[i]);
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** #endif
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8555              		.loc 32 105 0
 8556 0018 BDE83840 		pop	{r3, r4, r5, lr}
 8557              	.LBB219:
 8558              	.LBB218:
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 8559              		.loc 32 98 0
 8560 001c FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 8561              	.L534:
 8562              		.align	2
 8563              	.L533:
 8564 0020 00000000 		.word	EEPROM
 8565              	.LBE218:
 8566              	.LBE219:
 8567              		.cfi_endproc
 8568              	.LFE243:
 8570              		.section	.text._Z10nvrReadPIDhj,"ax",%progbits
 8571              		.align	1
 8572              		.global	_Z10nvrReadPIDhj
 8573              		.thumb
 8574              		.thumb_func
 8576              	_Z10nvrReadPIDhj:
 8577              	.LFB244:
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 8578              		.loc 32 107 0
 8579              		.cfi_startproc
 8580              		@ args = 0, pretend = 0, frame = 0
 8581              		@ frame_needed = 0, uses_anonymous_args = 0
 8582              	.LVL431:
 8583              	.LBB220:
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 8584              		.loc 32 108 0
 8585 0000 0B4A     		ldr	r2, .L536
 8586              	.LBE220:
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 8587              		.loc 32 107 0
 8588 0002 38B5     		push	{r3, r4, r5, lr}
 8589              	.LCFI82:
 8590              		.cfi_def_cfa_offset 16
 8591              		.cfi_offset 14, -4
 8592              		.cfi_offset 5, -8
 8593              		.cfi_offset 4, -12
 8594              		.cfi_offset 3, -16
 8595              	.LBB221:
 8596              		.loc 32 108 0
 8597 0004 1C24     		movs	r4, #28
 8598 0006 04FB0024 		mla	r4, r4, r0, r2
 8599              	.LVL432:
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->P = nvrReadFloat(IDEeprom);
 8600              		.loc 32 109 0
 8601 000a 0846     		mov	r0, r1
 8602              	.LVL433:
 8603              	.LBE221:
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 8604              		.loc 32 107 0
 8605 000c 0D46     		mov	r5, r1
 8606              	.LBB222:
 8607              		.loc 32 109 0
 8608 000e FFF7FEFF 		bl	_Z12nvrReadFloati
 8609              	.LVL434:
 8610 0012 2060     		str	r0, [r4, #0]	@ float
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->I = nvrReadFloat(IDEeprom+4);
 8611              		.loc 32 110 0
 8612 0014 281D     		adds	r0, r5, #4
 8613 0016 FFF7FEFF 		bl	_Z12nvrReadFloati
 8614 001a 6060     		str	r0, [r4, #4]	@ float
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 8615              		.loc 32 111 0
 8616 001c 05F10800 		add	r0, r5, #8
 8617 0020 FFF7FEFF 		bl	_Z12nvrReadFloati
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->lastError = 0;
 8618              		.loc 32 112 0
 8619 0024 0023     		movs	r3, #0
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 8620              		.loc 32 111 0
 8621 0026 A060     		str	r0, [r4, #8]	@ float
 8622              		.loc 32 112 0
 8623 0028 E360     		str	r3, [r4, #12]	@ float
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   pid->integratedError = 0;
 8624              		.loc 32 113 0
 8625 002a 6361     		str	r3, [r4, #20]	@ float
 8626              	.LBE222:
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8627              		.loc 32 114 0
 8628 002c 38BD     		pop	{r3, r4, r5, pc}
 8629              	.L537:
 8630 002e 00BF     		.align	2
 8631              	.L536:
 8632 0030 00000000 		.word	.LANCHOR9
 8633              		.cfi_endproc
 8634              	.LFE244:
 8636              		.section	.text._Z11nvrWritePIDhj,"ax",%progbits
 8637              		.align	1
 8638              		.global	_Z11nvrWritePIDhj
 8639              		.thumb
 8640              		.thumb_func
 8642              	_Z11nvrWritePIDhj:
 8643              	.LFB245:
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 8644              		.loc 32 116 0
 8645              		.cfi_startproc
 8646              		@ args = 0, pretend = 0, frame = 0
 8647              		@ frame_needed = 0, uses_anonymous_args = 0
 8648              	.LVL435:
 8649 0000 38B5     		push	{r3, r4, r5, lr}
 8650              	.LCFI83:
 8651              		.cfi_def_cfa_offset 16
 8652              		.cfi_offset 14, -4
 8653              		.cfi_offset 5, -8
 8654              		.cfi_offset 4, -12
 8655              		.cfi_offset 3, -16
 8656              	.LBB223:
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 8657              		.loc 32 117 0
 8658 0002 094B     		ldr	r3, .L539
 8659 0004 1C24     		movs	r4, #28
 8660 0006 04FB0034 		mla	r4, r4, r0, r3
 8661              	.LVL436:
 8662              	.LBE223:
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 8663              		.loc 32 116 0
 8664 000a 0D46     		mov	r5, r1
 8665              	.LBB224:
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->P, IDEeprom);
 8666              		.loc 32 118 0
 8667 000c 2068     		ldr	r0, [r4, #0]	@ float
 8668              	.LVL437:
 8669 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 8670              	.LVL438:
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->I, IDEeprom+4);
 8671              		.loc 32 119 0
 8672 0012 6068     		ldr	r0, [r4, #4]	@ float
 8673 0014 291D     		adds	r1, r5, #4
 8674 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 8675              		.loc 32 120 0
 8676 001a A068     		ldr	r0, [r4, #8]	@ float
 8677 001c 05F10801 		add	r1, r5, #8
 8678              	.LBE224:
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8679              		.loc 32 121 0
 8680 0020 BDE83840 		pop	{r3, r4, r5, lr}
 8681              	.LBB225:
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 8682              		.loc 32 120 0
 8683 0024 FFF7FEBF 		b	_Z13nvrWriteFloatfi
 8684              	.L540:
 8685              		.align	2
 8686              	.L539:
 8687 0028 00000000 		.word	.LANCHOR9
 8688              	.LBE225:
 8689              		.cfi_endproc
 8690              	.LFE245:
 8692              		.section	.text._Z16initializeEEPROMv,"ax",%progbits
 8693              		.align	1
 8694              		.global	_Z16initializeEEPROMv
 8695              		.thumb
 8696              		.thumb_func
 8698              	_Z16initializeEEPROMv:
 8699              	.LFB246:
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** // contains all default values when re-writing EEPROM
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void initializeEEPROM() {
 8700              		.loc 32 124 0
 8701              		.cfi_startproc
 8702              		@ args = 0, pretend = 0, frame = 0
 8703              		@ frame_needed = 0, uses_anonymous_args = 0
 8704 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 8705              	.LCFI84:
 8706              		.cfi_def_cfa_offset 24
 8707              		.cfi_offset 14, -4
 8708              		.cfi_offset 7, -8
 8709              		.cfi_offset 6, -12
 8710              		.cfi_offset 5, -16
 8711              		.cfi_offset 4, -20
 8712              		.cfi_offset 3, -24
 8713              	.LBB226:
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 150.0;
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -350.0;
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 8714              		.loc 32 131 0
 8715 0002 4D4A     		ldr	r2, .L547
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 8716              		.loc 32 125 0
 8717 0004 4D4C     		ldr	r4, .L547+4
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 8718              		.loc 32 127 0
 8719 0006 4E4E     		ldr	r6, .L547+8
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 8720              		.loc 32 125 0
 8721 0008 4E4B     		ldr	r3, .L547+12
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 3.5;
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 8722              		.loc 32 137 0
 8723 000a 4F4F     		ldr	r7, .L547+16
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 8724              		.loc 32 140 0
 8725 000c 4F48     		ldr	r0, .L547+20
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA PID experiements
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -350.0;
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -350.0;
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = 1.0;
 8726              		.loc 32 150 0
 8727 000e 5049     		ldr	r1, .L547+24
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 8728              		.loc 32 126 0
 8729 0010 504D     		ldr	r5, .L547+28
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 8730              		.loc 32 127 0
 8731 0012 A660     		str	r6, [r4, #8]	@ float
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -350.0;
 8732              		.loc 32 130 0
 8733 0014 6662     		str	r6, [r4, #36]	@ float
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 8734              		.loc 32 131 0
 8735 0016 6265     		str	r2, [r4, #84]	@ float
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 3.5;
 8736              		.loc 32 134 0
 8737 0018 2267     		str	r2, [r4, #112]	@ float
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -350.0;
 8738              		.loc 32 146 0
 8739 001a C4F8B060 		str	r6, [r4, #176]	@ float
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -350.0;
 8740              		.loc 32 149 0
 8741 001e C4F8CC60 		str	r6, [r4, #204]	@ float
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldBaro)
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 8742              		.loc 32 154 0
 8743 0022 4D4A     		ldr	r2, .L547+32
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 8744              		.loc 32 125 0
 8745 0024 2360     		str	r3, [r4, #0]	@ float
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = 1.0;
 8746              		.loc 32 150 0
 8747 0026 4FF07E56 		mov	r6, #1065353216
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 8748              		.loc 32 128 0
 8749 002a E361     		str	r3, [r4, #28]	@ float
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 8750              		.loc 32 137 0
 8751 002c A763     		str	r7, [r4, #56]	@ float
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 8752              		.loc 32 140 0
 8753 002e C4F88C00 		str	r0, [r4, #140]	@ float
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 8754              		.loc 32 138 0
 8755 0032 4A4F     		ldr	r7, .L547+36
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 8756              		.loc 32 141 0
 8757 0034 4A48     		ldr	r0, .L547+40
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 8758              		.loc 32 144 0
 8759 0036 C4F8A830 		str	r3, [r4, #168]	@ float
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 8760              		.loc 32 147 0
 8761 003a C4F8C430 		str	r3, [r4, #196]	@ float
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = 1.0;
 8762              		.loc 32 150 0
 8763 003e 0E60     		str	r6, [r1, #0]	@ float
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 8764              		.loc 32 153 0
 8765 0040 484B     		ldr	r3, .L547+44
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too 
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = 50.0;
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minThrottleAdjust = -50.0;
 8766              		.loc 32 170 0
 8767 0042 4949     		ldr	r1, .L547+48
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 8768              		.loc 32 126 0
 8769 0044 6560     		str	r5, [r4, #4]	@ float
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 150.0;
 8770              		.loc 32 129 0
 8771 0046 2562     		str	r5, [r4, #32]	@ float
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 8772              		.loc 32 154 0
 8773 0048 C4F8E420 		str	r2, [r4, #228]	@ float
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 8774              		.loc 32 132 0
 8775 004c 0025     		movs	r5, #0
 8776              		.loc 32 170 0
 8777 004e 6FF03102 		mvn	r2, #49
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 8778              		.loc 32 141 0
 8779 0052 C4F89000 		str	r0, [r4, #144]	@ float
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 8780              		.loc 32 153 0
 8781 0056 C4F8E030 		str	r3, [r4, #224]	@ float
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = 25.0; //this prevents the 0.1 I term to rise too 
 8782              		.loc 32 156 0
 8783 005a C4F8F830 		str	r3, [r4, #248]	@ float
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 8784              		.loc 32 132 0
 8785 005e A565     		str	r5, [r4, #88]	@ float
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxThrottleAdjust = 50.0; //we don't want it to be able to take over totally
 8786              		.loc 32 171 0
 8787 0060 424B     		ldr	r3, .L547+52
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 8788              		.loc 32 133 0
 8789 0062 E565     		str	r5, [r4, #92]	@ float
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 8790              		.loc 32 135 0
 8791 0064 6567     		str	r5, [r4, #116]	@ float
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 8792              		.loc 32 136 0
 8793 0066 A567     		str	r5, [r4, #120]	@ float
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 8794              		.loc 32 138 0
 8795 0068 E763     		str	r7, [r4, #60]	@ float
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 8796              		.loc 32 139 0
 8797 006a 2564     		str	r5, [r4, #64]	@ float
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 8798              		.loc 32 142 0
 8799 006c C4F89450 		str	r5, [r4, #148]	@ float
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 8800              		.loc 32 145 0
 8801 0070 C4F8AC50 		str	r5, [r4, #172]	@ float
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 8802              		.loc 32 148 0
 8803 0074 C4F8C850 		str	r5, [r4, #200]	@ float
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 8804              		.loc 32 155 0
 8805 0078 C4F8E850 		str	r5, [r4, #232]	@ float
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 8806              		.loc 32 157 0
 8807 007c C4F8FC50 		str	r5, [r4, #252]	@ float
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 8808              		.loc 32 158 0
 8809 0080 C4F80051 		str	r5, [r4, #256]	@ float
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 8810              		.loc 32 159 0
 8811 0084 C4F80451 		str	r5, [r4, #260]	@ float
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minThrottleAdjust = -50.0;
 8812              		.loc 32 170 0
 8813 0088 0A60     		str	r2, [r1, #0]
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       baroSmoothFactor = 0.1;
 8814              		.loc 32 173 0
 8815 008a 394A     		ldr	r2, .L547+56
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxThrottleAdjust = 50.0; //we don't want it to be able to take over totally
 8816              		.loc 32 171 0
 8817 008c 3221     		movs	r1, #50
 8818 008e 1960     		str	r1, [r3, #0]
 8819              		.loc 32 173 0
 8820 0090 1060     		str	r0, [r2, #0]	@ float
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = 90;
 8821              		.loc 32 175 0
 8822 0092 384B     		ldr	r3, .L547+60
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldPanicStickMovement = 250;
 8823              		.loc 32 176 0
 8824 0094 3848     		ldr	r0, .L547+64
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = 90;
 8825              		.loc 32 175 0
 8826 0096 5A21     		movs	r1, #90
 8827              		.loc 32 176 0
 8828 0098 FA22     		movs	r2, #250
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = 90;
 8829              		.loc 32 175 0
 8830 009a 1960     		str	r1, [r3, #0]
 8831              		.loc 32 176 0
 8832 009c 0260     		str	r2, [r0, #0]
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   initializePlatformSpecificAccelCalibration();
 8833              		.loc 32 179 0
 8834 009e FFF7FEFF 		bl	_Z42initializePlatformSpecificAccelCalibrationv
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = 1000.0;
 8835              		.loc 32 181 0
 8836 00a2 364B     		ldr	r3, .L547+68
 8837 00a4 3648     		ldr	r0, .L547+72
 8838 00a6 04F11802 		add	r2, r4, #24
 8839 00aa 1860     		str	r0, [r3, #0]	@ float
 8840              	.LVL439:
 8841 00ac BC46     		mov	ip, r7	@ float
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 8842              		.loc 32 184 0
 8843 00ae 0023     		movs	r3, #0
 8844 00b0 3146     		mov	r1, r6	@ float
 8845              	.LVL440:
 8846              	.L543:
 8847              	.LBB227:
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 8848              		.loc 32 186 0
 8849 00b2 082B     		cmp	r3, #8
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****         PID[i].windupGuard = windupGuard;
 8850              		.loc 32 187 0
 8851 00b4 18BF     		it	ne
 8852 00b6 1060     		strne	r0, [r2, #0]	@ float
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 8853              		.loc 32 184 0
 8854 00b8 5E1C     		adds	r6, r3, #1
 8855 00ba F3B2     		uxtb	r3, r6
 8856              	.LVL441:
 8857 00bc 1C32     		adds	r2, r2, #28
 8858 00be 0E2B     		cmp	r3, #14
 8859 00c0 F7D1     		bne	.L543
 8860              	.LBE227:
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       }
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #else
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       PID[i].windupGuard = windupGuard;
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverXmitFactor = 1.0;
 8861              		.loc 32 194 0
 8862 00c2 304E     		ldr	r6, .L547+76
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = 1150;
 8863              		.loc 32 195 0
 8864 00c4 304A     		ldr	r2, .L547+80
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA - old setOneG not in SI - accel->setOneG(500);
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = -9.80665; // AKA set one G to 9.8 m/s^2
 8865              		.loc 32 197 0
 8866 00c6 3148     		ldr	r0, .L547+84
 8867 00c8 314B     		ldr	r3, .L547+88
 8868              	.LVL442:
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverXmitFactor = 1.0;
 8869              		.loc 32 194 0
 8870 00ca 3160     		str	r1, [r6, #0]	@ float
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = 1150;
 8871              		.loc 32 195 0
 8872 00cc 40F27E47 		movw	r7, #1150
 8873 00d0 1760     		str	r7, [r2, #0]
 8874              		.loc 32 197 0
 8875 00d2 1860     		str	r0, [r3, #0]	@ float
 8876              	.LVL443:
 8877 00d4 2F4F     		ldr	r7, .L547+92
 8878 00d6 304E     		ldr	r6, .L547+96
 8879 00d8 3048     		ldr	r0, .L547+100
 8880 00da 0822     		movs	r2, #8
 8881              	.LVL444:
 8882              	.L544:
 8883              	.LBB228:
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSlope[channel] = 1.0;
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverOffset[channel] = 0.0;
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSmoothFactor[channel] = 1.0;
 8884              		.loc 32 201 0 discriminator 2
 8885 00dc 013A     		subs	r2, r2, #1
 8886 00de D2B2     		uxtb	r2, r2
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSlope[channel] = 1.0;
 8887              		.loc 32 199 0 discriminator 2
 8888 00e0 47F8041F 		str	r1, [r7, #4]!	@ float
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverOffset[channel] = 0.0;
 8889              		.loc 32 200 0 discriminator 2
 8890 00e4 0023     		movs	r3, #0
 8891 00e6 46F8045F 		str	r5, [r6, #4]!	@ float
 8892              		.loc 32 201 0 discriminator 2
 8893 00ea 40F8041F 		str	r1, [r0, #4]!	@ float
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 8894              		.loc 32 198 0 discriminator 2
 8895 00ee 002A     		cmp	r2, #0
 8896 00f0 F4D1     		bne	.L544
 8897              	.LBE228:
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 8898              		.loc 32 203 0
 8899 00f2 2B49     		ldr	r1, .L547+104
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   //flightMode = RATE_FLIGHT_MODE;
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = ATTITUDE_FLIGHT_MODE;
 8900              		.loc 32 206 0
 8901 00f4 2B4A     		ldr	r2, .L547+108
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = ON;
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Battery Monitor
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef BattMonitor
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorAlarmVoltage = 3.33;
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorGoingDownTime = 60000;
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Range Finder
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxRangeFinderRange = 4.5;
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minRangeFinderRange = 0.0;
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (Lidar2D)
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].I = 0.0;
 8902              		.loc 32 225 0
 8903 00f6 C4F85431 		str	r3, [r4, #340]	@ float
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 8904              		.loc 32 203 0
 8905 00fa 4FF07C5E 		mov	lr, #1056964608
 8906 00fe C1F808E0 		str	lr, [r1, #8]	@ float
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = ON;
 8907              		.loc 32 207 0
 8908 0102 2949     		ldr	r1, .L547+112
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].D = 0.0;
 8909              		.loc 32 226 0
 8910 0104 C4F85831 		str	r3, [r4, #344]	@ float
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = ATTITUDE_FLIGHT_MODE;
 8911              		.loc 32 206 0
 8912 0108 0120     		movs	r0, #1
 8913 010a 1070     		strb	r0, [r2, #0]
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = ON;
 8914              		.loc 32 207 0
 8915 010c 0870     		strb	r0, [r1, #0]
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 8916              		.loc 32 208 0
 8917 010e 274A     		ldr	r2, .L547+116
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 8918              		.loc 32 224 0
 8919 0110 2748     		ldr	r0, .L547+120
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 230:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].P = 50.0;
 8920              		.loc 32 230 0
 8921 0112 2849     		ldr	r1, .L547+124
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 8922              		.loc 32 208 0
 8923 0114 C2F800C0 		str	ip, [r2, #0]	@ float
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 8924              		.loc 32 224 0
 8925 0118 C4F85001 		str	r0, [r4, #336]	@ float
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 8926              		.loc 32 227 0
 8927 011c C4F83401 		str	r0, [r4, #308]	@ float
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 8928              		.loc 32 228 0
 8929 0120 C4F83831 		str	r3, [r4, #312]	@ float
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 8930              		.loc 32 229 0
 8931 0124 C4F83C31 		str	r3, [r4, #316]	@ float
 8932              		.loc 32 230 0
 8933 0128 C4F86C11 		str	r1, [r4, #364]	@ float
 231:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].I = 0.0;
 8934              		.loc 32 231 0
 8935 012c C4F87031 		str	r3, [r4, #368]	@ float
 232:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].D = 0.0;
 8936              		.loc 32 232 0
 8937 0130 C4F87431 		str	r3, [r4, #372]	@ float
 8938              	.LBE226:
 233:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif  
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 235:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (UseGPSNavigator)
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     missionNbPoint = 0;
 237:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 238:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].I = 0.0;
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSROLL_PID_IDX].D = 0.0;
 240:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 243:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].P = 50.0;
 244:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].I = 0.0;
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[GPSYAW_PID_IDX].D = 0.0;
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].longitude = GPS_INVALID_ANGLE;
 249:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].latitude = GPS_INVALID_ANGLE;
 250:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].altitude = GPS_INVALID_ALTITUDE;
 251:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     }
 252:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 253:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 254:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Camera Control
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef CameraControl
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     cameraMode = 1;
 257:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraPitch = 1273.2;    
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraRoll = 636.6;    
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraYaw = 318.3;
 260:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterPitch = 1500;
 261:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterRoll = 1500;
 262:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterYaw = 1500;
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinPitch = 1000;
 264:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinRoll = 1000;
 265:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinYaw = 1000;
 266:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxPitch = 2000;
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxRoll = 2000;
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxYaw = 2000;
 269:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #ifdef CameraTXControl
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       servoTXChannels = 1;
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 273:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 8939              		.loc 32 273 0
 8940 0134 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 8941              	.L548:
 8942 0136 00BF     		.align	2
 8943              	.L547:
 8944 0138 00006040 		.word	1080033280
 8945 013c 00000000 		.word	.LANCHOR9
 8946 0140 0000AFC3 		.word	-1011941376
 8947 0144 0000C842 		.word	1120403456
 8948 0148 00004843 		.word	1128792064
 8949 014c 00004040 		.word	1077936128
 8950 0150 00000000 		.word	.LANCHOR120
 8951 0154 00001643 		.word	1125515264
 8952 0158 9A99193F 		.word	1058642330
 8953 015c 0000A040 		.word	1084227584
 8954 0160 CDCCCC3D 		.word	1036831949
 8955 0164 0000C841 		.word	1103626240
 8956 0168 00000000 		.word	.LANCHOR113
 8957 016c 00000000 		.word	.LANCHOR114
 8958 0170 00000000 		.word	.LANCHOR74
 8959 0174 00000000 		.word	.LANCHOR107
 8960 0178 00000000 		.word	.LANCHOR106
 8961 017c 00000000 		.word	.LANCHOR139
 8962 0180 00007A44 		.word	1148846080
 8963 0184 00000000 		.word	.LANCHOR55
 8964 0188 00000000 		.word	.LANCHOR125
 8965 018c 0AE81CC1 		.word	-1055070198
 8966 0190 00000000 		.word	.LANCHOR31
 8967 0194 FCFFFFFF 		.word	.LANCHOR4-4
 8968 0198 FCFFFFFF 		.word	.LANCHOR5-4
 8969 019c FCFFFFFF 		.word	.LANCHOR6-4
 8970 01a0 00000000 		.word	.LANCHOR6
 8971 01a4 00000000 		.word	.LANCHOR119
 8972 01a8 00000000 		.word	.LANCHOR130
 8973 01ac 00000000 		.word	.LANCHOR140
 8974 01b0 CDCC4C3F 		.word	1061997773
 8975 01b4 00004842 		.word	1112014848
 8976              		.cfi_endproc
 8977              	.LFE246:
 8979              		.section	.text._Z10readEEPROMv,"ax",%progbits
 8980              		.align	1
 8981              		.global	_Z10readEEPROMv
 8982              		.thumb
 8983              		.thumb_func
 8985              	_Z10readEEPROMv:
 8986              	.LFB247:
 274:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void readEEPROM() {
 8987              		.loc 32 275 0
 8988              		.cfi_startproc
 8989              		@ args = 0, pretend = 0, frame = 0
 8990              		@ frame_needed = 0, uses_anonymous_args = 0
 8991              	.LBB229:
 276:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(XAXIS, ROLL_PID_GAIN_ADR);
 8992              		.loc 32 276 0
 8993 0000 0020     		movs	r0, #0
 8994              	.LBE229:
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void readEEPROM() {
 8995              		.loc 32 275 0
 8996 0002 10B5     		push	{r4, lr}
 8997              	.LCFI85:
 8998              		.cfi_def_cfa_offset 8
 8999              		.cfi_offset 14, -4
 9000              		.cfi_offset 4, -8
 9001              	.LBB231:
 9002              		.loc 32 276 0
 9003 0004 0146     		mov	r1, r0
 9004 0006 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(YAXIS, PITCH_PID_GAIN_ADR);
 9005              		.loc 32 277 0
 9006 000a 0120     		movs	r0, #1
 9007 000c 2421     		movs	r1, #36
 9008 000e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ZAXIS, YAW_PID_GAIN_ADR);
 9009              		.loc 32 278 0
 9010 0012 0220     		movs	r0, #2
 9011 0014 1821     		movs	r1, #24
 9012 0016 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 9013              		.loc 32 279 0
 9014 001a 0320     		movs	r0, #3
 9015 001c 0C21     		movs	r1, #12
 9016 001e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 280:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 9017              		.loc 32 280 0
 9018 0022 0420     		movs	r0, #4
 9019 0024 3021     		movs	r1, #48
 9020 0026 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 281:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 9021              		.loc 32 281 0
 9022 002a 0520     		movs	r0, #5
 9023 002c 3C21     		movs	r1, #60
 9024 002e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 282:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 9025              		.loc 32 282 0
 9026 0032 0620     		movs	r0, #6
 9027 0034 4821     		movs	r1, #72
 9028 0036 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 283:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   readPID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 9029              		.loc 32 283 0
 9030 003a 5421     		movs	r1, #84
 9031 003c 0720     		movs	r0, #7
 9032 003e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 9033              		.loc 32 285 0
 9034 0042 4FF4A670 		mov	r0, #332
 9035 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 9036 004a 484C     		ldr	r4, .L553
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 287:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Leaving separate PID reads as commented for now
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Previously had issue where EEPROM was not reading right data
 289:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 290:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 9037              		.loc 32 290 0
 9038 004c 6021     		movs	r1, #96
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 9039              		.loc 32 285 0
 9040 004e 2060     		str	r0, [r4, #0]	@ float
 9041              		.loc 32 290 0
 9042 0050 0820     		movs	r0, #8
 9043 0052 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 291:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloat(ALTITUDE_WINDUP_ADR);
 9044              		.loc 32 291 0
 9045 0056 4FF4A070 		mov	r0, #320
 9046 005a FFF7FEFF 		bl	_Z12nvrReadFloati
 9047 005e 444C     		ldr	r4, .L553+4
 9048 0060 C4F8F800 		str	r0, [r4, #248]	@ float
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 9049              		.loc 32 293 0
 9050 0064 4FF49E70 		mov	r0, #316
 9051 0068 FFF7FEFF 		bl	_Z12nvrReadFloati
 9052 006c 4149     		ldr	r1, .L553+8
 9053 006e 0860     		str	r0, [r1, #0]	@ float
 294:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif  
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 9054              		.loc 32 295 0
 9055 0070 4FF4A270 		mov	r0, #324
 9056 0074 FFF7FEFF 		bl	_Z12nvrReadFloati
 9057 0078 03EE100A 		fmsr	s6, r0
 9058 007c 3E4B     		ldr	r3, .L553+12
 9059 007e FDEEC32A 		ftosizs	s5, s6
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 9060              		.loc 32 296 0
 9061 0082 4FF4A470 		mov	r0, #328
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 9062              		.loc 32 295 0
 9063 0086 C3ED002A 		fsts	s5, [r3, #0]	@ int
 9064              		.loc 32 296 0
 9065 008a FFF7FEFF 		bl	_Z12nvrReadFloati
 9066 008e 02EE100A 		fmsr	s4, r0
 9067 0092 3A4A     		ldr	r2, .L553+16
 9068 0094 FDEEC21A 		ftosizs	s3, s4
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 9069              		.loc 32 297 0
 9070 0098 4FF49C70 		mov	r0, #312
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 9071              		.loc 32 296 0
 9072 009c C2ED001A 		fsts	s3, [r2, #0]	@ int
 9073              		.loc 32 297 0
 9074 00a0 FFF7FEFF 		bl	_Z12nvrReadFloati
 9075 00a4 01EE100A 		fmsr	s2, r0
 9076 00a8 3549     		ldr	r1, .L553+20
 9077 00aa FDEEC10A 		ftosizs	s1, s2
 298:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 9078              		.loc 32 298 0
 9079 00ae 4FF49A70 		mov	r0, #308
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 9080              		.loc 32 297 0
 9081 00b2 C1ED000A 		fsts	s1, [r1, #0]	@ int
 9082              		.loc 32 298 0
 9083 00b6 FFF7FEFF 		bl	_Z12nvrReadFloati
 9084 00ba 00EE100A 		fmsr	s0, r0
 9085 00be 3148     		ldr	r0, .L553+24
 9086 00c0 FDEEC07A 		ftosizs	s15, s0
 9087 00c4 C0ED007A 		fsts	s15, [r0, #0]	@ int
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 9088              		.loc 32 299 0
 9089 00c8 0920     		movs	r0, #9
 9090 00ca 6C21     		movs	r1, #108
 9091 00cc FFF7FEFF 		bl	_Z10nvrReadPIDhj
 300:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 302:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Mag calibration
 303:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef HeadingMagHold
 304:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     magBias[YAXIS]  = readFloat(YAXIS_MAG_BIAS_ADR);
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     magBias[ZAXIS]  = readFloat(ZAXIS_MAG_BIAS_ADR);
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 309:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Battery Monitor
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef BattMonitor
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorAlarmVoltage = readFloat(BATT_ALARM_VOLTAGE_ADR);
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     batteryMonitorGoingDownTime = readFloat(BATT_DOWN_TIME_ADR);
 314:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   windupGuard = readFloat(WINDUPGUARD_ADR);
 9092              		.loc 32 316 0
 9093 00d0 4FF48C70 		mov	r0, #280
 9094 00d4 FFF7FEFF 		bl	_Z12nvrReadFloati
 9095 00d8 2B4B     		ldr	r3, .L553+28
 9096 00da 1834     		adds	r4, r4, #24
 9097 00dc 1860     		str	r0, [r3, #0]	@ float
 9098              	.LVL445:
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // AKA - added so that each PID has its own windupGuard, will need to be removed once each PID's 
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 9099              		.loc 32 318 0
 9100 00de 0023     		movs	r3, #0
 9101              	.LVL446:
 9102              	.L551:
 9103              	.LBB230:
 319:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       if (i != BARO_ALTITUDE_HOLD_PID_IDX) {
 9104              		.loc 32 320 0
 9105 00e0 082B     		cmp	r3, #8
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****         PID[i].windupGuard = windupGuard;
 9106              		.loc 32 321 0
 9107 00e2 18BF     		it	ne
 9108 00e4 2060     		strne	r0, [r4, #0]	@ float
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for (byte i = XAXIS; i < LAST_PID_IDX; i++ ) {
 9109              		.loc 32 318 0
 9110 00e6 5A1C     		adds	r2, r3, #1
 9111 00e8 D3B2     		uxtb	r3, r2
 9112              	.LVL447:
 9113 00ea 1C34     		adds	r4, r4, #28
 9114 00ec 0E2B     		cmp	r3, #14
 9115 00ee F7D1     		bne	.L551
 9116              	.LBE230:
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       }
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #else
 324:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       PID[i].windupGuard = windupGuard;
 325:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif      
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 9117              		.loc 32 328 0
 9118 00f0 4FF49070 		mov	r0, #288
 9119 00f4 FFF7FEFF 		bl	_Z12nvrReadFloati
 9120              	.LVL448:
 9121 00f8 06EE100A 		fmsr	s12, r0
 9122 00fc 2348     		ldr	r0, .L553+32
 9123 00fe FDEEC65A 		ftosizs	s11, s12
 9124 0102 C0ED005A 		fsts	s11, [r0, #0]	@ int
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   aref = readFloat(AREF_ADR);
 9125              		.loc 32 329 0
 9126 0106 4FF49270 		mov	r0, #292
 9127 010a FFF7FEFF 		bl	_Z12nvrReadFloati
 9128 010e 204B     		ldr	r3, .L553+36
 9129 0110 1860     		str	r0, [r3, #0]	@ float
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = readFloat(FLIGHTMODE_ADR);
 9130              		.loc 32 330 0
 9131 0112 4FF49470 		mov	r0, #296
 9132 0116 FFF7FEFF 		bl	_Z12nvrReadFloati
 9133 011a 05EE100A 		fmsr	s10, r0
 9134 011e FCEEC54A 		ftouizs	s9, s10
 9135 0122 1C4A     		ldr	r2, .L553+40
 9136 0124 14EE901A 		fmrs	r1, s9	@ int
 331:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9137              		.loc 32 331 0
 9138 0128 4FF49870 		mov	r0, #304
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   flightMode = readFloat(FLIGHTMODE_ADR);
 9139              		.loc 32 330 0
 9140 012c 1170     		strb	r1, [r2, #0]
 9141              		.loc 32 331 0
 9142 012e FFF7FEFF 		bl	_Z12nvrReadFloati
 9143 0132 194B     		ldr	r3, .L553+44
 9144 0134 1860     		str	r0, [r3, #0]	@ float
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 9145              		.loc 32 332 0
 9146 0136 4FF49670 		mov	r0, #300
 9147 013a FFF7FEFF 		bl	_Z12nvrReadFloati
 9148 013e 04EE100A 		fmsr	s8, r0
 9149 0142 FCEEC43A 		ftouizs	s7, s8
 9150 0146 1548     		ldr	r0, .L553+48
 9151 0148 13EE90CA 		fmrs	ip, s7	@ int
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (Lidar2D)
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 9152              		.loc 32 335 0
 9153 014c 7821     		movs	r1, #120
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 9154              		.loc 32 332 0
 9155 014e 80F800C0 		strb	ip, [r0, #0]
 9156              		.loc 32 335 0
 9157 0152 0C20     		movs	r0, #12
 9158 0154 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 9159              		.loc 32 336 0
 9160 0158 0B20     		movs	r0, #11
 9161 015a 8421     		movs	r1, #132
 9162 015c FFF7FEFF 		bl	_Z10nvrReadPIDhj
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);  
 9163              		.loc 32 337 0
 9164 0160 0D20     		movs	r0, #13
 9165 0162 9021     		movs	r1, #144
 9166              	.LBE231:
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (UseGPSNavigator)
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     missionNbPoint = readFloat(GPS_MISSION_NB_POINT_ADR);
 342:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].longitude = readLong(WAYPOINT_ADR[location].longitude);
 348:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].latitude = readLong(WAYPOINT_ADR[location].latitude);
 349:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       waypoint[location].altitude = readLong(WAYPOINT_ADR[location].altitude);
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     }    
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 353:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Camera Control
 354:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef CameraControl
 355:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     cameraMode = readFloat(CAMERAMODE_ADR);
 356:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraPitch = readFloat(MCAMERAPITCH_ADR);
 357:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraRoll = readFloat(MCAMERAROLL_ADR);    
 358:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     mCameraYaw = readFloat(MCAMERAYAW_ADR);
 359:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterPitch = readFloat(SERVOCENTERPITCH_ADR);
 360:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterRoll = readFloat(SERVOCENTERROLL_ADR);
 361:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoCenterYaw = readFloat(SERVOCENTERYAW_ADR);
 362:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinPitch = readFloat(SERVOMINPITCH_ADR);
 363:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinRoll = readFloat(SERVOMINROLL_ADR);
 364:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMinYaw = readFloat(SERVOMINYAW_ADR);
 365:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxPitch = readFloat(SERVOMAXPITCH_ADR);
 366:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxRoll = readFloat(SERVOMAXROLL_ADR);
 367:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     servoMaxYaw = readFloat(SERVOMAXYAW_ADR);
 368:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #ifdef CameraTXControl
 369:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       servoTXChannels = readFloat(SERVOTXCHANNELS_ADR);
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       servoActualCenter = readFloat(SERVOCENTERPITCH_ADR);
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 372:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif   
 373:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 9167              		.loc 32 373 0
 9168 0164 BDE81040 		pop	{r4, lr}
 9169              	.LBB232:
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);  
 9170              		.loc 32 337 0
 9171 0168 FFF7FEBF 		b	_Z10nvrReadPIDhj
 9172              	.L554:
 9173              		.align	2
 9174              	.L553:
 9175 016c 00000000 		.word	.LANCHOR120
 9176 0170 00000000 		.word	.LANCHOR9
 9177 0174 00000000 		.word	.LANCHOR74
 9178 0178 00000000 		.word	.LANCHOR107
 9179 017c 00000000 		.word	.LANCHOR106
 9180 0180 00000000 		.word	.LANCHOR113
 9181 0184 00000000 		.word	.LANCHOR114
 9182 0188 00000000 		.word	.LANCHOR139
 9183 018c 00000000 		.word	.LANCHOR125
 9184 0190 00000000 		.word	.LANCHOR140
 9185 0194 00000000 		.word	.LANCHOR119
 9186 0198 00000000 		.word	.LANCHOR31
 9187 019c 00000000 		.word	.LANCHOR130
 9188              	.LBE232:
 9189              		.cfi_endproc
 9190              	.LFE247:
 9192              		.section	.text._Z11writeEEPROMv,"ax",%progbits
 9193              		.align	1
 9194              		.global	_Z11writeEEPROMv
 9195              		.thumb
 9196              		.thumb_func
 9198              	_Z11writeEEPROMv:
 9199              	.LFB248:
 374:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 375:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void writeEEPROM(){
 9200              		.loc 32 375 0
 9201              		.cfi_startproc
 9202              		@ args = 0, pretend = 0, frame = 0
 9203              		@ frame_needed = 0, uses_anonymous_args = 0
 9204 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 9205              	.LCFI86:
 9206              		.cfi_def_cfa_offset 24
 9207              		.cfi_offset 14, -4
 9208              		.cfi_offset 7, -8
 9209              		.cfi_offset 6, -12
 9210              		.cfi_offset 5, -16
 9211              		.cfi_offset 4, -20
 9212              		.cfi_offset 3, -24
 9213              	.LBB239:
 9214              	.LBB240:
 9215              	.LBB241:
 9216              		.file 33 "../Libmaple/libmaple/libmaple/nvic.h"
   1:../Libmaple/libmaple/libmaple/nvic.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/nvic.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/nvic.h ****  *
   4:../Libmaple/libmaple/libmaple/nvic.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/nvic.h ****  *
   6:../Libmaple/libmaple/libmaple/nvic.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/nvic.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/nvic.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/nvic.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/nvic.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/nvic.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/nvic.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/nvic.h ****  *
  14:../Libmaple/libmaple/libmaple/nvic.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/nvic.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/nvic.h ****  *
  17:../Libmaple/libmaple/libmaple/nvic.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/nvic.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/nvic.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/nvic.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/nvic.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/nvic.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/nvic.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/nvic.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/nvic.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/nvic.h **** 
  27:../Libmaple/libmaple/libmaple/nvic.h **** /**
  28:../Libmaple/libmaple/libmaple/nvic.h ****  * @file nvic.h
  29:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Nested vector interrupt controller support.
  30:../Libmaple/libmaple/libmaple/nvic.h ****  *
  31:../Libmaple/libmaple/libmaple/nvic.h ****  * Basic usage:
  32:../Libmaple/libmaple/libmaple/nvic.h ****  *
  33:../Libmaple/libmaple/libmaple/nvic.h ****  * @code
  34:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Initialise the interrupt controller and point to the vector
  35:../Libmaple/libmaple/libmaple/nvic.h ****  *   // table at the start of flash.
  36:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_init(0x08000000, 0);
  37:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Bind in a timer interrupt handler
  38:../Libmaple/libmaple/libmaple/nvic.h ****  *   timer_attach_interrupt(TIMER_CC1_INTERRUPT, handler);
  39:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Optionally set the priority
  40:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_irq_set_priority(NVIC_TIMER1_CC, 5);
  41:../Libmaple/libmaple/libmaple/nvic.h ****  *   // All done, enable all interrupts
  42:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_globalirq_enable();
  43:../Libmaple/libmaple/libmaple/nvic.h ****  * @endcode
  44:../Libmaple/libmaple/libmaple/nvic.h ****  */
  45:../Libmaple/libmaple/libmaple/nvic.h **** 
  46:../Libmaple/libmaple/libmaple/nvic.h **** #ifndef _NVIC_H_
  47:../Libmaple/libmaple/libmaple/nvic.h **** #define _NVIC_H_
  48:../Libmaple/libmaple/libmaple/nvic.h **** 
  49:../Libmaple/libmaple/libmaple/nvic.h **** #include "libmaple_types.h"
  50:../Libmaple/libmaple/libmaple/nvic.h **** #include "util.h"
  51:../Libmaple/libmaple/libmaple/nvic.h **** 
  52:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef __cplusplus
  53:../Libmaple/libmaple/libmaple/nvic.h **** extern "C"{
  54:../Libmaple/libmaple/libmaple/nvic.h **** #endif
  55:../Libmaple/libmaple/libmaple/nvic.h **** 
  56:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map type. */
  57:../Libmaple/libmaple/libmaple/nvic.h **** typedef struct nvic_reg_map {
  58:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISER[8];      /**< Interrupt Set Enable Registers */
  59:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED0[24];     /**< Reserved */
  60:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICER[8];      /**< Interrupt Clear Enable Registers */
  61:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RSERVED1[24];      /**< Reserved */
  62:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISPR[8];      /**< Interrupt Set Pending Registers */
  63:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED2[24];     /**< Reserved */
  64:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICPR[8];      /**< Interrupt Clear Pending Registers */
  65:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED3[24];     /**< Reserved */
  66:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 IABR[8];      /**< Interrupt Active bit Registers */
  67:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED4[56];     /**< Reserved */
  68:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint8  IP[240];      /**< Interrupt Priority Registers */
  69:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED5[644];    /**< Reserved */
  70:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 STIR;         /**< Software Trigger Interrupt Registers */
  71:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_reg_map;
  72:../Libmaple/libmaple/libmaple/nvic.h **** 
  73:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map base pointer. */
  74:../Libmaple/libmaple/libmaple/nvic.h **** #define NVIC_BASE                       ((struct nvic_reg_map*)0xE000E100)
  75:../Libmaple/libmaple/libmaple/nvic.h **** 
  76:../Libmaple/libmaple/libmaple/nvic.h **** /**
  77:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Interrupt vector table interrupt numbers.
  78:../Libmaple/libmaple/libmaple/nvic.h ****  *
  79:../Libmaple/libmaple/libmaple/nvic.h ****  * Each positive-valued enumerator is the position of the
  80:../Libmaple/libmaple/libmaple/nvic.h ****  * corresponding interrupt in the vector table.  Negative-valued
  81:../Libmaple/libmaple/libmaple/nvic.h ****  * enumerators correspond to interrupts controlled by the system
  82:../Libmaple/libmaple/libmaple/nvic.h ****  * handler block.
  83:../Libmaple/libmaple/libmaple/nvic.h ****  *
  84:../Libmaple/libmaple/libmaple/nvic.h ****  * @see scb.h
  85:../Libmaple/libmaple/libmaple/nvic.h ****  */
  86:../Libmaple/libmaple/libmaple/nvic.h **** typedef enum nvic_irq_num {
  87:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_NMI            = -14,  /**< Non-maskable interrupt */
  88:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_HARDFAULT      = -13,  /**< Hard fault (all class of fault) */
  89:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_MEM_MANAGE     = -12,  /**< Memory management */
  90:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_BUS_FAULT      = -11,  /**< Bus fault: prefetch fault, memory
  91:../Libmaple/libmaple/libmaple/nvic.h ****                                      access fault. */
  92:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USAGE_FAULT    = -10,  /**< Usage fault: Undefined instruction or
  93:../Libmaple/libmaple/libmaple/nvic.h ****                                      illegal state. */
  94:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SVC            = -5,   /**< System service call via SWI insruction */
  95:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DEBUG_MON      = -4,   /**< Debug monitor */
  96:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PEND_SVC       = -2,   /**< Pendable request for system service */
  97:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SYSTICK        = -1,   /**< System tick timer */
  98:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_WWDG           = 0,    /**< Window watchdog interrupt */
  99:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PVD            = 1,    /**< PVD through EXTI line detection */
 100:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TAMPER         = 2,    /**< Tamper */
 101:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTC            = 3,    /**< Real-time clock */
 102:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FLASH          = 4,    /**< Flash */
 103:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RCC            = 5,    /**< Reset and clock control */
 104:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI0          = 6,    /**< EXTI line 0 */
 105:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI1          = 7,    /**< EXTI line 1 */
 106:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI2          = 8,    /**< EXTI line 2 */
 107:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI3          = 9,    /**< EXTI line 3 */
 108:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI4          = 10,   /**< EXTI line 4 */
 109:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH1        = 11,   /**< DMA1 channel 1 */
 110:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH2        = 12,   /**< DMA1 channel 2 */
 111:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH3        = 13,   /**< DMA1 channel 3 */
 112:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH4        = 14,   /**< DMA1 channel 4 */
 113:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH5        = 15,   /**< DMA1 channel 5 */
 114:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH6        = 16,   /**< DMA1 channel 6 */
 115:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH7        = 17,   /**< DMA1 channel 7 */
 116:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC_1_2        = 18,   /**< ADC1 and ADC2 */
 117:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_HP_CAN_TX  = 19,   /**< USB high priority or CAN TX */
 118:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_LP_CAN_RX0 = 20,   /**< USB low priority or CAN RX0 */
 119:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_RX1        = 21,   /**< CAN RX1 */
 120:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_SCE        = 22,   /**< CAN SCE */
 121:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_9_5       = 23,   /**< EXTI line [9:5] */
 122:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_BRK     = 24,   /**< Timer 1 break */
 123:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_UP      = 25,   /**< Timer 1 update */
 124:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_TRG_COM = 26,   /**< Timer 1 trigger and commutation */
 125:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_CC      = 27,   /**< Timer 1 capture/compare */
 126:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER2         = 28,   /**< Timer 2 */
 127:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER3         = 29,   /**< Timer 3 */
 128:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER4         = 30,   /**< Timer 4 */
 129:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_EV        = 31,   /**< I2C1 event */
 130:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_ER        = 32,   /**< I2C1 error */
 131:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_EV        = 33,   /**< I2C2 event */
 132:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_ER        = 34,   /**< I2C2 error */
 133:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI1           = 35,   /**< SPI1 */
 134:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI2           = 36,   /**< SPI2 */
 135:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART1         = 37,   /**< USART1 */
 136:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART2         = 38,   /**< USART2 */
 137:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART3         = 39,   /**< USART3 */
 138:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_15_10     = 40,   /**< EXTI line [15:10] */
 139:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTCALARM       = 41,   /**< RTC alarm through EXTI line */
 140:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USBWAKEUP      = 42,   /**< USB wakeup from suspend through
 141:../Libmaple/libmaple/libmaple/nvic.h ****                                      EXTI line */
 142:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_BRK     = 43,   /**< Timer 8 break */
 143:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_UP      = 44,   /**< Timer 8 update */
 144:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_TRG_COM = 45,   /**< Timer 8 trigger and commutation */
 145:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_CC      = 46,   /**< Timer 8 capture/compare */
 146:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef STM32_HIGH_DENSITY
 147:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC3           = 47,   /**< ADC3 */
 148:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FSMC           = 48,   /**< FSMC */
 149:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SDIO           = 49,   /**< SDIO */
 150:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER5         = 50,   /**< Timer 5 */
 151:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI3           = 51,   /**< SPI3 */
 152:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART4          = 52,   /**< UART4 */
 153:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART5          = 53,   /**< UART5 */
 154:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER6         = 54,   /**< Timer 6 */
 155:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER7         = 55,   /**< Timer 7 */
 156:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH1       = 56,   /**< DMA2 channel 1 */
 157:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH2       = 57,   /**< DMA2 channel 2 */
 158:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH3       = 58,   /**< DMA2 channel 3 */
 159:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH_4_5    = 59,   /**< DMA2 channels 4 and 5 */
 160:../Libmaple/libmaple/libmaple/nvic.h **** #endif
 161:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_irq_num;
 162:../Libmaple/libmaple/libmaple/nvic.h **** 
 163:../Libmaple/libmaple/libmaple/nvic.h **** /*
 164:../Libmaple/libmaple/libmaple/nvic.h ****  * Initialises the interrupt controller and sets all interrupts to the
 165:../Libmaple/libmaple/libmaple/nvic.h ****  * lowest priority.
 166:../Libmaple/libmaple/libmaple/nvic.h ****  *
 167:../Libmaple/libmaple/libmaple/nvic.h ****  * For stand-alone products, the base address is normally the start of
 168:../Libmaple/libmaple/libmaple/nvic.h ****  * flash (0x08000000).
 169:../Libmaple/libmaple/libmaple/nvic.h ****  *
 170:../Libmaple/libmaple/libmaple/nvic.h ****  * @param vector_table_address  base address of the vector table
 171:../Libmaple/libmaple/libmaple/nvic.h ****  */
 172:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_init(uint32 vector_table_address, uint32 offset);
 173:../Libmaple/libmaple/libmaple/nvic.h **** 
 174:../Libmaple/libmaple/libmaple/nvic.h **** /**
 175:../Libmaple/libmaple/libmaple/nvic.h ****  * Sets the base address of the vector table.
 176:../Libmaple/libmaple/libmaple/nvic.h ****  */
 177:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_set_vector_table(uint32 address, uint32 offset);
 178:../Libmaple/libmaple/libmaple/nvic.h **** 
 179:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_irq_set_priority(nvic_irq_num irqn, uint8 priority);
 180:../Libmaple/libmaple/libmaple/nvic.h **** 
 181:../Libmaple/libmaple/libmaple/nvic.h **** /**
 182:../Libmaple/libmaple/libmaple/nvic.h ****  * Enables interrupts and configurable fault handlers (clear PRIMASK).
 183:../Libmaple/libmaple/libmaple/nvic.h ****  */
 184:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_enable() {
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 186:../Libmaple/libmaple/libmaple/nvic.h **** }
 187:../Libmaple/libmaple/libmaple/nvic.h **** 
 188:../Libmaple/libmaple/libmaple/nvic.h **** /**
 189:../Libmaple/libmaple/libmaple/nvic.h ****  * Disable interrupts and configurable fault handlers (set PRIMASK).
 190:../Libmaple/libmaple/libmaple/nvic.h ****  */
 191:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_disable() {
 192:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsid i");
 9217              		.loc 33 192 0
 9218              	@ 192 "../Libmaple/libmaple/libmaple/nvic.h" 1
 9219 0002 72B6     		cpsid i
 9220              	@ 0 "" 2
 9221              		.thumb
 9222              	.LBE241:
 9223              	.LBE240:
 376:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   cli(); // Needed so that APM sensor data does not overflow
 377:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(XAXIS, ROLL_PID_GAIN_ADR);
 9224              		.loc 32 377 0
 9225 0004 0020     		movs	r0, #0
 9226 0006 0146     		mov	r1, r0
 9227 0008 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 378:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(YAXIS, PITCH_PID_GAIN_ADR);
 9228              		.loc 32 378 0
 9229 000c 0120     		movs	r0, #1
 9230 000e 2421     		movs	r1, #36
 9231 0010 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 379:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 9232              		.loc 32 379 0
 9233 0014 0320     		movs	r0, #3
 9234 0016 0C21     		movs	r1, #12
 9235 0018 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 380:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 9236              		.loc 32 380 0
 9237 001c 0420     		movs	r0, #4
 9238 001e 3021     		movs	r1, #48
 9239 0020 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 381:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ZAXIS, YAW_PID_GAIN_ADR);
 9240              		.loc 32 381 0
 9241 0024 0220     		movs	r0, #2
 9242 0026 1821     		movs	r1, #24
 9243 0028 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 382:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 9244              		.loc 32 382 0
 9245 002c 0520     		movs	r0, #5
 9246 002e 3C21     		movs	r1, #60
 9247 0030 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 383:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 384:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 385:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 386:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 9248              		.loc 32 386 0
 9249 0034 624C     		ldr	r4, .L558
 387:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 388:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro
 389:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 390:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 391:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 392:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 393:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 394:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #if defined AltitudeHoldBaro
 395:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 396:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #else
 397:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(0.0, ALTITUDE_SMOOTH_ADR);
 398:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 399:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 400:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 9250              		.loc 32 400 0
 9251 0036 634F     		ldr	r7, .L558+4
 401:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 9252              		.loc 32 401 0
 9253 0038 634D     		ldr	r5, .L558+8
 383:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 9254              		.loc 32 383 0
 9255 003a 0620     		movs	r0, #6
 9256 003c 4821     		movs	r1, #72
 9257 003e FFF7FEFF 		bl	_Z11nvrWritePIDhj
 384:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 9258              		.loc 32 384 0
 9259 0042 0720     		movs	r0, #7
 9260 0044 5421     		movs	r1, #84
 9261 0046 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 386:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 9262              		.loc 32 386 0
 9263 004a 2068     		ldr	r0, [r4, #0]	@ float
 9264 004c 4FF4A671 		mov	r1, #332
 9265 0050 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 389:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 9266              		.loc 32 389 0
 9267 0054 0820     		movs	r0, #8
 9268 0056 6021     		movs	r1, #96
 9269 0058 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 390:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard, ALTITUDE_WINDUP_ADR);
 9270              		.loc 32 390 0
 9271 005c 5B4A     		ldr	r2, .L558+12
 9272 005e 4FF4A071 		mov	r1, #320
 9273 0062 D2F8F800 		ldr	r0, [r2, #248]	@ float
 9274 0066 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 395:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 9275              		.loc 32 395 0
 9276 006a 5949     		ldr	r1, .L558+16
 9277 006c 0868     		ldr	r0, [r1, #0]	@ float
 9278 006e 4FF49E71 		mov	r1, #316
 9279 0072 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 399:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 9280              		.loc 32 399 0
 9281 0076 5748     		ldr	r0, .L558+20
 9282 0078 0368     		ldr	r3, [r0, #0]
 9283 007a 03EE103A 		fmsr	s6, r3	@ int
 9284 007e F8EEC32A 		fsitos	s5, s6
 9285 0082 4FF4A271 		mov	r1, #324
 9286 0086 12EE900A 		fmrs	r0, s5
 9287 008a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 400:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 9288              		.loc 32 400 0
 9289 008e 3E68     		ldr	r6, [r7, #0]
 402:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 403:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 404:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #else
 405:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 406:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(90, ALTITUDE_BUMP_ADR);
 407:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(250, ALTITUDE_PANIC_ADR);
 408:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(-50, ALTITUDE_MIN_THROTTLE_ADR);
 409:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(50, ALTITUDE_MAX_THROTTLE_ADR);
 410:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 411:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 412:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 413:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef HeadingMagHold
 414:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 415:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 416:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 417:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 418:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 419:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(receiverXmitFactor, XMITFACTOR_ADR);
 9290              		.loc 32 419 0
 9291 0090 514F     		ldr	r7, .L558+24
 400:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 9292              		.loc 32 400 0
 9293 0092 02EE106A 		fmsr	s4, r6	@ int
 9294 0096 F8EEC21A 		fsitos	s3, s4
 9295 009a 4FF4A471 		mov	r1, #328
 9296 009e 11EE900A 		fmrs	r0, s3
 9297 00a2 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 401:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 9298              		.loc 32 401 0
 9299 00a6 2C68     		ldr	r4, [r5, #0]
 9300              		.loc 32 419 0
 9301 00a8 4C4E     		ldr	r6, .L558+28
 9302 00aa 4D4D     		ldr	r5, .L558+32
 401:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 9303              		.loc 32 401 0
 9304 00ac 01EE104A 		fmsr	s2, r4	@ int
 9305 00b0 F8EEC10A 		fsitos	s1, s2
 9306 00b4 4FF49C71 		mov	r1, #312
 9307 00b8 10EE900A 		fmrs	r0, s1
 9308 00bc FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 402:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 9309              		.loc 32 402 0
 9310 00c0 484A     		ldr	r2, .L558+36
 9311 00c2 1168     		ldr	r1, [r2, #0]
 9312 00c4 00EE101A 		fmsr	s0, r1	@ int
 9313 00c8 F8EEC07A 		fsitos	s15, s0
 9314 00cc 4FF49A71 		mov	r1, #308
 9315 00d0 17EE900A 		fmrs	r0, s15
 9316 00d4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 403:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 9317              		.loc 32 403 0
 9318 00d8 0920     		movs	r0, #9
 9319 00da 6C21     		movs	r1, #108
 9320 00dc FFF7FEFF 		bl	_Z11nvrWritePIDhj
 418:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(windupGuard, WINDUPGUARD_ADR);
 9321              		.loc 32 418 0
 9322 00e0 4148     		ldr	r0, .L558+40
 9323 00e2 4FF48C71 		mov	r1, #280
 9324 00e6 0068     		ldr	r0, [r0, #0]	@ float
 9325 00e8 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9326              		.loc 32 419 0
 9327 00ec 3F4B     		ldr	r3, .L558+44
 9328 00ee 4FF48E71 		mov	r1, #284
 9329 00f2 1868     		ldr	r0, [r3, #0]	@ float
 9330 00f4 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9331              	.LVL449:
 9332 00f8 0024     		movs	r4, #0
 9333              	.LVL450:
 9334              	.L556:
 9335              	.LBB242:
 420:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 421:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 422:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(receiverSlope[channel],  RECEIVER_DATA[channel].slope);
 9336              		.loc 32 422 0 discriminator 2
 9337 00fa 04F19C01 		add	r1, r4, #156
 9338 00fe 57F8040F 		ldr	r0, [r7, #4]!	@ float
 9339 0102 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 423:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(receiverOffset[channel], RECEIVER_DATA[channel].offset);
 9340              		.loc 32 423 0 discriminator 2
 9341 0106 04F1A001 		add	r1, r4, #160
 9342 010a 56F8040F 		ldr	r0, [r6, #4]!	@ float
 9343 010e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 424:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(receiverSmoothFactor[channel], RECEIVER_DATA[channel].smooth_factor);
 9344              		.loc 32 424 0 discriminator 2
 9345 0112 04F1A401 		add	r1, r4, #164
 9346 0116 55F8040F 		ldr	r0, [r5, #4]!	@ float
 9347 011a 0C34     		adds	r4, r4, #12
 9348 011c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 421:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9349              		.loc 32 421 0 discriminator 2
 9350 0120 602C     		cmp	r4, #96
 9351 0122 EAD1     		bne	.L556
 9352              	.LBE242:
 425:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 426:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 427:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(minArmedThrottle, MINARMEDTHROTTLE_ADR);
 9353              		.loc 32 427 0
 9354 0124 3249     		ldr	r1, .L558+48
 9355 0126 0868     		ldr	r0, [r1, #0]
 9356 0128 06EE100A 		fmsr	s12, r0	@ int
 9357 012c F8EEC65A 		fsitos	s11, s12
 9358 0130 4FF49071 		mov	r1, #288
 9359 0134 15EE900A 		fmrs	r0, s11
 9360 0138 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 428:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(aref, AREF_ADR);
 9361              		.loc 32 428 0
 9362 013c 2D4B     		ldr	r3, .L558+52
 9363 013e 4FF49271 		mov	r1, #292
 9364 0142 1868     		ldr	r0, [r3, #0]	@ float
 9365 0144 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 429:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(flightMode, FLIGHTMODE_ADR);
 9366              		.loc 32 429 0
 9367 0148 2B4A     		ldr	r2, .L558+56
 9368 014a 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 9369 014c 05EE101A 		fmsr	s10, r1	@ int
 9370 0150 F8EE454A 		fuitos	s9, s10
 9371 0154 4FF49471 		mov	r1, #296
 9372 0158 14EE900A 		fmrs	r0, s9
 9373 015c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 430:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(headingHoldConfig, HEADINGHOLD_ADR);
 9374              		.loc 32 430 0
 9375 0160 2648     		ldr	r0, .L558+60
 9376 0162 90F800C0 		ldrb	ip, [r0, #0]	@ zero_extendqisi2
 9377 0166 04EE10CA 		fmsr	s8, ip	@ int
 9378 016a F8EE443A 		fuitos	s7, s8
 9379 016e 4FF49671 		mov	r1, #300
 9380 0172 13EE900A 		fmrs	r0, s7
 9381 0176 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 431:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 9382              		.loc 32 431 0
 9383 017a 214B     		ldr	r3, .L558+64
 9384 017c 4FF49871 		mov	r1, #304
 9385 0180 1868     		ldr	r0, [r3, #0]	@ float
 9386 0182 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 432:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(SOFTWARE_VERSION, SOFTWARE_VERSION_ADR);
 9387              		.loc 32 432 0
 9388 0186 1F48     		ldr	r0, .L558+68
 9389 0188 4FF48A71 		mov	r1, #276
 9390 018c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 433:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 434:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Battery Monitor
 435:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef BattMonitor
 436:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(batteryMonitorAlarmVoltage, BATT_ALARM_VOLTAGE_ADR);
 437:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(batteryMonitorThrottleTarget, BATT_THROTTLE_TARGET_ADR);
 438:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(batteryMonitorGoingDownTime, BATT_DOWN_TIME_ADR);
 439:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 440:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 441:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Range Finder
 442:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 443:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(maxRangeFinderRange, RANGE_FINDER_MAX_ADR);
 444:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(minRangeFinderRange, RANGE_FINDER_MIN_ADR);
 445:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #else
 446:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0, RANGE_FINDER_MAX_ADR);
 9391              		.loc 32 446 0
 9392 0190 0020     		movs	r0, #0
 9393 0192 4FF4C071 		mov	r1, #384
 9394 0196 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 447:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(0, RANGE_FINDER_MIN_ADR);
 9395              		.loc 32 447 0
 9396 019a 0020     		movs	r0, #0
 9397 019c 4FF4C271 		mov	r1, #388
 9398 01a0 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 448:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 449:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 450:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined (Lidar2D)
 451:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 9399              		.loc 32 451 0
 9400 01a4 0C20     		movs	r0, #12
 9401 01a6 7821     		movs	r1, #120
 9402 01a8 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 452:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 9403              		.loc 32 452 0
 9404 01ac 0B20     		movs	r0, #11
 9405 01ae 8421     		movs	r1, #132
 9406 01b0 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 453:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);       
 9407              		.loc 32 453 0
 9408 01b4 0D20     		movs	r0, #13
 9409 01b6 9021     		movs	r1, #144
 9410 01b8 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 9411              	.LBB243:
 9412              	.LBB244:
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 9413              		.loc 33 185 0
 9414              	@ 185 "../Libmaple/libmaple/libmaple/nvic.h" 1
 9415 01bc 62B6     		cpsie i
 9416              	@ 0 "" 2
 9417              		.thumb
 9418              	.LBE244:
 9419              	.LBE243:
 9420              	.LBE239:
 454:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 455:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 456:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #if defined UseGPSNavigator
 457:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(missionNbPoint, GPS_MISSION_NB_POINT_ADR);
 458:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 459:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 460:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writePID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 461:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     
 462:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 463:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeLong(waypoint[location].longitude, WAYPOINT_ADR[location].longitude);
 464:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeLong(waypoint[location].latitude, WAYPOINT_ADR[location].latitude);
 465:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeLong(waypoint[location].altitude, WAYPOINT_ADR[location].altitude);
 466:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     }       
 467:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif
 468:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 469:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     // Camera Control
 470:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #ifdef CameraControl
 471:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(cameraMode, CAMERAMODE_ADR);
 472:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(mCameraPitch, MCAMERAPITCH_ADR);
 473:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(mCameraRoll, MCAMERAROLL_ADR);    
 474:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(mCameraYaw, MCAMERAYAW_ADR);
 475:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoCenterPitch, SERVOCENTERPITCH_ADR);
 476:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoCenterRoll, SERVOCENTERROLL_ADR);
 477:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoCenterYaw, SERVOCENTERYAW_ADR);
 478:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMinPitch, SERVOMINPITCH_ADR);
 479:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMinRoll, SERVOMINROLL_ADR);
 480:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMinYaw, SERVOMINYAW_ADR);
 481:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMaxPitch, SERVOMAXPITCH_ADR);
 482:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMaxRoll, SERVOMAXROLL_ADR);
 483:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     writeFloat(servoMaxYaw, SERVOMAXYAW_ADR);
 484:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #ifdef CameraTXControl
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****       writeFloat(servoTXChannels, SERVOTXCHANNELS_ADR);
 486:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     #endif
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   #endif 
 488:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   sei(); // Restart interrupts
 489:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 9421              		.loc 32 489 0
 9422 01be F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 9423              	.L559:
 9424              		.align	2
 9425              	.L558:
 9426 01c0 00000000 		.word	.LANCHOR120
 9427 01c4 00000000 		.word	.LANCHOR106
 9428 01c8 00000000 		.word	.LANCHOR113
 9429 01cc 00000000 		.word	.LANCHOR9
 9430 01d0 00000000 		.word	.LANCHOR74
 9431 01d4 00000000 		.word	.LANCHOR107
 9432 01d8 FCFFFFFF 		.word	.LANCHOR4-4
 9433 01dc FCFFFFFF 		.word	.LANCHOR5-4
 9434 01e0 FCFFFFFF 		.word	.LANCHOR6-4
 9435 01e4 00000000 		.word	.LANCHOR114
 9436 01e8 00000000 		.word	.LANCHOR139
 9437 01ec 00000000 		.word	.LANCHOR55
 9438 01f0 00000000 		.word	.LANCHOR125
 9439 01f4 00000000 		.word	.LANCHOR140
 9440 01f8 00000000 		.word	.LANCHOR119
 9441 01fc 00000000 		.word	.LANCHOR130
 9442 0200 00000000 		.word	.LANCHOR31
 9443 0204 CDCC4C40 		.word	1078774989
 9444              		.cfi_endproc
 9445              	.LFE248:
 9447              		.section	.text._Z25initSensorsZeroFromEEPROMv,"ax",%progbits
 9448              		.align	1
 9449              		.global	_Z25initSensorsZeroFromEEPROMv
 9450              		.thumb
 9451              		.thumb_func
 9453              	_Z25initSensorsZeroFromEEPROMv:
 9454              	.LFB249:
 490:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 491:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void initSensorsZeroFromEEPROM() {
 9455              		.loc 32 491 0
 9456              		.cfi_startproc
 9457              		@ args = 0, pretend = 0, frame = 0
 9458              		@ frame_needed = 0, uses_anonymous_args = 0
 9459 0000 38B5     		push	{r3, r4, r5, lr}
 9460              	.LCFI87:
 9461              		.cfi_def_cfa_offset 16
 9462              		.cfi_offset 14, -4
 9463              		.cfi_offset 5, -8
 9464              		.cfi_offset 4, -12
 9465              		.cfi_offset 3, -16
 492:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 493:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Accel initialization from EEPROM
 494:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9466              		.loc 32 494 0
 9467 0002 4FF49870 		mov	r0, #304
 9468 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 9469 000a 114B     		ldr	r3, .L561
 495:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Accel calibration
 496:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9470              		.loc 32 496 0
 9471 000c 114D     		ldr	r5, .L561+4
 494:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 9472              		.loc 32 494 0
 9473 000e 1860     		str	r0, [r3, #0]	@ float
 9474              		.loc 32 496 0
 9475 0010 4FF4AA70 		mov	r0, #340
 9476 0014 FFF7FEFF 		bl	_Z12nvrReadFloati
 9477 0018 2860     		str	r0, [r5, #0]	@ float
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   runTimeAccelBias[XAXIS] = readFloat(XAXIS_ACCEL_BIAS_ADR);
 9478              		.loc 32 497 0
 9479 001a 4FF4A870 		mov	r0, #336
 9480 001e FFF7FEFF 		bl	_Z12nvrReadFloati
 9481 0022 0D4C     		ldr	r4, .L561+8
 9482 0024 2060     		str	r0, [r4, #0]	@ float
 498:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelScaleFactor[YAXIS] = readFloat(YAXIS_ACCEL_SCALE_FACTOR_ADR);
 9483              		.loc 32 498 0
 9484 0026 4FF4AE70 		mov	r0, #348
 9485 002a FFF7FEFF 		bl	_Z12nvrReadFloati
 9486 002e 6860     		str	r0, [r5, #4]	@ float
 499:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   runTimeAccelBias[YAXIS] = readFloat(YAXIS_ACCEL_BIAS_ADR);
 9487              		.loc 32 499 0
 9488 0030 4FF4AC70 		mov	r0, #344
 9489 0034 FFF7FEFF 		bl	_Z12nvrReadFloati
 9490 0038 6060     		str	r0, [r4, #4]	@ float
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   accelScaleFactor[ZAXIS] = readFloat(ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 9491              		.loc 32 500 0
 9492 003a 4FF4B270 		mov	r0, #356
 9493 003e FFF7FEFF 		bl	_Z12nvrReadFloati
 9494 0042 A860     		str	r0, [r5, #8]	@ float
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   runTimeAccelBias[ZAXIS] = readFloat(ZAXIS_ACCEL_BIAS_ADR);
 9495              		.loc 32 501 0
 9496 0044 4FF4B070 		mov	r0, #352
 9497 0048 FFF7FEFF 		bl	_Z12nvrReadFloati
 9498 004c A060     		str	r0, [r4, #8]	@ float
 502:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 9499              		.loc 32 502 0
 9500 004e 38BD     		pop	{r3, r4, r5, pc}
 9501              	.L562:
 9502              		.align	2
 9503              	.L561:
 9504 0050 00000000 		.word	.LANCHOR31
 9505 0054 00000000 		.word	.LANCHOR27
 9506 0058 00000000 		.word	.LANCHOR28
 9507              		.cfi_endproc
 9508              	.LFE249:
 9510              		.section	.text._Z24storeSensorsZeroToEEPROMv,"ax",%progbits
 9511              		.align	1
 9512              		.global	_Z24storeSensorsZeroToEEPROMv
 9513              		.thumb
 9514              		.thumb_func
 9516              	_Z24storeSensorsZeroToEEPROMv:
 9517              	.LFB250:
 503:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 504:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void storeSensorsZeroToEEPROM() {
 9518              		.loc 32 504 0
 9519              		.cfi_startproc
 9520              		@ args = 0, pretend = 0, frame = 0
 9521              		@ frame_needed = 0, uses_anonymous_args = 0
 9522 0000 38B5     		push	{r3, r4, r5, lr}
 9523              	.LCFI88:
 9524              		.cfi_def_cfa_offset 16
 9525              		.cfi_offset 14, -4
 9526              		.cfi_offset 5, -8
 9527              		.cfi_offset 4, -12
 9528              		.cfi_offset 3, -16
 505:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 506:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Store accel data to EEPROM
 507:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 9529              		.loc 32 507 0
 9530 0002 144B     		ldr	r3, .L564
 508:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   // Accel Cal
 509:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9531              		.loc 32 509 0
 9532 0004 144D     		ldr	r5, .L564+4
 507:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 9533              		.loc 32 507 0
 9534 0006 1868     		ldr	r0, [r3, #0]	@ float
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[XAXIS], XAXIS_ACCEL_BIAS_ADR);
 9535              		.loc 32 510 0
 9536 0008 144C     		ldr	r4, .L564+8
 507:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 9537              		.loc 32 507 0
 9538 000a 4FF49871 		mov	r1, #304
 9539 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 509:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 9540              		.loc 32 509 0
 9541 0012 2868     		ldr	r0, [r5, #0]	@ float
 9542 0014 4FF4AA71 		mov	r1, #340
 9543 0018 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 9544              		.loc 32 510 0
 9545 001c 2068     		ldr	r0, [r4, #0]	@ float
 9546 001e 4FF4A871 		mov	r1, #336
 9547 0022 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 511:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[YAXIS], YAXIS_ACCEL_SCALE_FACTOR_ADR);
 9548              		.loc 32 511 0
 9549 0026 6868     		ldr	r0, [r5, #4]	@ float
 9550 0028 4FF4AE71 		mov	r1, #348
 9551 002c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[YAXIS], YAXIS_ACCEL_BIAS_ADR);
 9552              		.loc 32 512 0
 9553 0030 6068     		ldr	r0, [r4, #4]	@ float
 9554 0032 4FF4AC71 		mov	r1, #344
 9555 0036 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 513:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(accelScaleFactor[ZAXIS], ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 9556              		.loc 32 513 0
 9557 003a A868     		ldr	r0, [r5, #8]	@ float
 9558 003c 4FF4B271 		mov	r1, #356
 9559 0040 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 514:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 9560              		.loc 32 514 0
 9561 0044 A068     		ldr	r0, [r4, #8]	@ float
 9562 0046 4FF4B071 		mov	r1, #352
 515:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 9563              		.loc 32 515 0
 9564 004a BDE83840 		pop	{r3, r4, r5, lr}
 514:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 9565              		.loc 32 514 0
 9566 004e FFF7FEBF 		b	_Z13nvrWriteFloatfi
 9567              	.L565:
 9568 0052 00BF     		.align	2
 9569              	.L564:
 9570 0054 00000000 		.word	.LANCHOR31
 9571 0058 00000000 		.word	.LANCHOR27
 9572 005c 00000000 		.word	.LANCHOR28
 9573              		.cfi_endproc
 9574              	.LFE250:
 9576              		.section	.text._Z46processZeroThrottleFunctionFromReceiverCommandv,"ax",%progbits
 9577              		.align	1
 9578              		.global	_Z46processZeroThrottleFunctionFromReceiverCommandv
 9579              		.thumb
 9580              		.thumb_func
 9582              	_Z46processZeroThrottleFunctionFromReceiverCommandv:
 9583              	.LFB237:
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (AutoLanding)
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processAutoLandingStateFromReceiverCommand() {
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (receiverCommand[AUX3] < 1750) {
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (isAutoLandingInitialized) {
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           autoLandingState = BARO_AUTO_DESCENT_STATE;
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           #endif
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAutoLandingInitialized = true;
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         altitudeHoldState = ON;
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       autoLandingState = OFF;
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       autoLandingThrottleCorrection = 0;
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isAutoLandingInitialized = false;
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       #if defined (UseGPSNavigator)
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if ((receiverCommand[AUX1] > 1750) && (receiverCommand[AUX2] > 1750)) {
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldState = OFF;
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAltitudeHoldInitialized = false;
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       #else
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         if (receiverCommand[AUX1] > 1750) {
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           altitudeHoldState = OFF;
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****           isAltitudeHoldInitialized = false;
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         }
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       #endif
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #if defined (UseGPSNavigator)
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   void processGpsNavigationStateFromReceiverCommand() {
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     // Init home command
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (motorArmed == OFF && 
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         receiverCommand[THROTTLE] < MINCHECK && receiverCommand[ZAXIS] < MINCHECK &&
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         receiverCommand[YAXIS] > MAXCHECK && receiverCommand[XAXIS] > MAXCHECK &&
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         haveAGpsLock()) {
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       homePosition.latitude = currentPosition.latitude;
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       homePosition.longitude = currentPosition.longitude;
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       homePosition.altitude = DEFAULT_HOME_ALTITUDE;
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (receiverCommand[AUX2] < 1750) {  // Enter in execute mission state, if none, go back home, 
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (!isGpsNavigationInitialized) {
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsRollAxisCorrection = 0;
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsPitchAxisCorrection = 0;
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsYawAxisCorrection = 0;
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         isGpsNavigationInitialized = true;
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       positionHoldState = OFF;         // disable the position hold while navigating
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isPositionHoldInitialized = false;
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       navigationState = ON;
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else if (receiverCommand[AUX1] < 1250) {  // Enter in position hold state
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (!isPositionHoldInitialized) {
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsRollAxisCorrection = 0;
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsPitchAxisCorrection = 0;
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         gpsYawAxisCorrection = 0;
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         positionHoldPointToReach.latitude = currentPosition.latitude;
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         positionHoldPointToReach.longitude = currentPosition.longitude;
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         positionHoldPointToReach.altitude = getBaroAltitude();
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         isPositionHoldInitialized = true;
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isGpsNavigationInitialized = false;  // disable navigation
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       navigationState = OFF;
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       positionHoldState = ON;
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     else {
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       // Navigation and position hold are disabled
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       positionHoldState = OFF;
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isPositionHoldInitialized = false;
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       navigationState = OFF;
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       isGpsNavigationInitialized = false;
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       gpsRollAxisCorrection = 0;
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       gpsPitchAxisCorrection = 0;
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       gpsYawAxisCorrection = 0;
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** #endif
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 230:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** void processZeroThrottleFunctionFromReceiverCommand() {
 9584              		.loc 30 230 0
 9585              		.cfi_startproc
 9586              		@ args = 0, pretend = 0, frame = 0
 9587              		@ frame_needed = 0, uses_anonymous_args = 0
 9588 0000 38B5     		push	{r3, r4, r5, lr}
 9589              	.LCFI89:
 9590              		.cfi_def_cfa_offset 16
 9591              		.cfi_offset 14, -4
 9592              		.cfi_offset 5, -8
 9593              		.cfi_offset 4, -12
 9594              		.cfi_offset 3, -16
 9595              	.LBB245:
 231:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Disarm motors (left stick lower left corner)
 232:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] < MINCHECK && motorArmed == ON) {
 9596              		.loc 30 232 0
 9597 0002 254C     		ldr	r4, .L571
 9598 0004 A268     		ldr	r2, [r4, #8]
 9599 0006 40F24B43 		movw	r3, #1099
 9600 000a 9A42     		cmp	r2, r3
 9601 000c 0BDC     		bgt	.L567
 9602              		.loc 30 232 0 is_stmt 0 discriminator 1
 9603 000e 234D     		ldr	r5, .L571+4
 9604 0010 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 9605 0012 0128     		cmp	r0, #1
 9606 0014 07D1     		bne	.L567
 233:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     commandAllMotors(MINCOMMAND);
 9607              		.loc 30 233 0 is_stmt 1
 9608 0016 4FF47A70 		mov	r0, #1000
 9609 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     motorArmed = OFF;
 235:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     inFlight = false;
 9610              		.loc 30 235 0
 9611 001e 2049     		ldr	r1, .L571+8
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     motorArmed = OFF;
 9612              		.loc 30 234 0
 9613 0020 0022     		movs	r2, #0
 9614 0022 2A70     		strb	r2, [r5, #0]
 9615              		.loc 30 235 0
 9616 0024 0A70     		strb	r2, [r1, #0]
 9617              	.L567:
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 237:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #ifdef OSD
 238:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       notifyOSD(OSD_CENTER|OSD_WARN, "MOTORS UNARMED");
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
 240:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #if defined BattMonitorAutoDescent
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       batteryMonitorAlarmCounter = 0;
 243:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       batteryMonitorStartThrottle = 0;
 244:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       batteyMonitorThrottleCorrection = 0.0;
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }    
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Zero Gyro and Accel sensors (left stick lower left, right stick lower right corner)
 249:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if ((receiverCommand[ZAXIS] < MINCHECK) && (receiverCommand[XAXIS] > MAXCHECK) && (receiverComman
 9618              		.loc 30 249 0
 9619 0026 A068     		ldr	r0, [r4, #8]
 9620 0028 1B4A     		ldr	r2, .L571
 9621 002a 40F24B43 		movw	r3, #1099
 9622 002e 9842     		cmp	r0, r3
 9623 0030 12DC     		bgt	.L568
 9624              		.loc 30 249 0 is_stmt 0 discriminator 1
 9625 0032 1068     		ldr	r0, [r2, #0]
 9626 0034 40F26C7C 		movw	ip, #1900
 9627 0038 6045     		cmp	r0, ip
 9628 003a 0DDD     		ble	.L568
 9629              		.loc 30 249 0 discriminator 2
 9630 003c 5168     		ldr	r1, [r2, #4]
 9631 003e 9942     		cmp	r1, r3
 9632 0040 0ADC     		bgt	.L568
 250:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     calibrateGyro();
 9633              		.loc 30 250 0 is_stmt 1
 9634 0042 FFF7FEFF 		bl	_Z13calibrateGyrov
 251:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     computeAccelBias();
 9635              		.loc 30 251 0
 9636 0046 FFF7FEFF 		bl	_Z16computeAccelBiasv
 252:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     storeSensorsZeroToEEPROM();
 9637              		.loc 30 252 0
 9638 004a FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 253:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     calibrateKinematics();
 254:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     zeroIntegralError();
 9639              		.loc 30 254 0
 9640 004e FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     pulseMotors(3);
 9641              		.loc 30 255 0
 9642 0052 0320     		movs	r0, #3
 9643 0054 FFF7FEFF 		bl	_Z11pulseMotorsh
 9644              	.L568:
 9645              	.LBB246:
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }   
 257:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Arm motors (left stick lower right corner)
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] > MAXCHECK && motorArmed == OFF && safetyCheck == ON) {
 9646              		.loc 30 259 0
 9647 0058 A268     		ldr	r2, [r4, #8]
 9648 005a 40F26C73 		movw	r3, #1900
 9649 005e 9A42     		cmp	r2, r3
 9650 0060 10DD     		ble	.L569
 9651              		.loc 30 259 0 is_stmt 0 discriminator 1
 9652 0062 0E4B     		ldr	r3, .L571+4
 9653 0064 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 9654 0066 68B9     		cbnz	r0, .L569
 9655              		.loc 30 259 0 discriminator 2
 9656 0068 0E49     		ldr	r1, .L571+12
 9657 006a 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 9658 006c 012A     		cmp	r2, #1
 9659 006e 09D1     		bne	.L569
 9660              	.LVL451:
 9661              	.LBB247:
 9662              	.LBB248:
 260:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 261:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #ifdef OSD_SYSTEM_MENU
 262:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       if (menuOwnsSticks) {
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         return;
 264:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       }
 265:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif
 266:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       motorCommand[motor] = MINTHROTTLE;
 9663              		.loc 30 268 0 is_stmt 1 discriminator 1
 9664 0070 0D49     		ldr	r1, .L571+16
 9665              	.LBE248:
 269:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     motorArmed = ON;
 9666              		.loc 30 270 0 discriminator 1
 9667 0072 1A70     		strb	r2, [r3, #0]
 9668              	.LBB249:
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       motorCommand[motor] = MINTHROTTLE;
 9669              		.loc 30 268 0 discriminator 1
 9670 0074 40F24C40 		movw	r0, #1100
 9671 0078 0860     		str	r0, [r1, #0]
 9672              	.LVL452:
 9673 007a 4860     		str	r0, [r1, #4]
 9674              	.LVL453:
 9675 007c 8860     		str	r0, [r1, #8]
 9676              	.LVL454:
 9677 007e C860     		str	r0, [r1, #12]
 9678              	.LVL455:
 9679              	.LBE249:
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #ifdef OSD
 273:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       notifyOSD(OSD_CENTER|OSD_WARN, "!MOTORS ARMED!");
 274:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     #endif  
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 276:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     zeroIntegralError();
 9680              		.loc 30 276 0 discriminator 1
 9681 0080 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 9682              	.LVL456:
 9683              	.L569:
 9684              	.LBE247:
 9685              	.LBE246:
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   // Prevents accidental arming of motor output if no transmitter command received
 280:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] > MINCHECK) {
 9686              		.loc 30 280 0
 9687 0084 A268     		ldr	r2, [r4, #8]
 9688 0086 40F24C4C 		movw	ip, #1100
 9689 008a 6245     		cmp	r2, ip
 9690 008c 02DD     		ble	.L566
 281:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     safetyCheck = ON; 
 9691              		.loc 30 281 0
 9692 008e 054B     		ldr	r3, .L571+12
 9693 0090 0120     		movs	r0, #1
 9694 0092 1870     		strb	r0, [r3, #0]
 9695              	.L566:
 9696 0094 38BD     		pop	{r3, r4, r5, pc}
 9697              	.L572:
 9698 0096 00BF     		.align	2
 9699              	.L571:
 9700 0098 00000000 		.word	.LANCHOR1
 9701 009c 00000000 		.word	.LANCHOR138
 9702 00a0 00000000 		.word	.LANCHOR8
 9703 00a4 00000000 		.word	.LANCHOR124
 9704 00a8 00000000 		.word	.LANCHOR56
 9705              	.LBE245:
 9706              		.cfi_endproc
 9707              	.LFE237:
 9709              		.section	.text._Z17readPilotCommandsv,"ax",%progbits
 9710              		.align	1
 9711              		.global	_Z17readPilotCommandsv
 9712              		.thumb
 9713              		.thumb_func
 9715              	_Z17readPilotCommandsv:
 9716              	.LFB238:
 282:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 283:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** }
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 287:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** /**
 289:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * readPilotCommands
 290:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * 
 291:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * This function is responsible to read receiver
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  * and process command from the users
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****  */
 294:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** void readPilotCommands() {
 9717              		.loc 30 294 0
 9718              		.cfi_startproc
 9719              		@ args = 0, pretend = 0, frame = 0
 9720              		@ frame_needed = 0, uses_anonymous_args = 0
 9721 0000 38B5     		push	{r3, r4, r5, lr}
 9722              	.LCFI90:
 9723              		.cfi_def_cfa_offset 16
 9724              		.cfi_offset 14, -4
 9725              		.cfi_offset 5, -8
 9726              		.cfi_offset 4, -12
 9727              		.cfi_offset 3, -16
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   readReceiver(); 
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 298:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 9728              		.loc 30 298 0
 9729 0002 144C     		ldr	r4, .L577
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   readReceiver(); 
 9730              		.loc 30 296 0
 9731 0004 FFF7FEFF 		bl	_Z12readReceiverv
 9732              		.loc 30 298 0
 9733 0008 E268     		ldr	r2, [r4, #12]
 9734 000a 40F24B43 		movw	r3, #1099
 9735 000e 9A42     		cmp	r2, r3
 9736 0010 01DC     		bgt	.L574
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processZeroThrottleFunctionFromReceiverCommand();
 9737              		.loc 30 299 0
 9738 0012 FFF7FEFF 		bl	_Z46processZeroThrottleFunctionFromReceiverCommandv
 9739              	.L574:
 300:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 302:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   if (!inFlight) {
 9740              		.loc 30 302 0
 9741 0016 104B     		ldr	r3, .L577+4
 9742 0018 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 9743 001a 48B9     		cbnz	r0, .L575
 303:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (motorArmed == ON && receiverCommand[THROTTLE] > minArmedThrottle) {
 9744              		.loc 30 303 0
 9745 001c 0F49     		ldr	r1, .L577+8
 9746 001e 0A78     		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 9747 0020 012A     		cmp	r2, #1
 9748 0022 05D1     		bne	.L575
 9749              		.loc 30 303 0 is_stmt 0 discriminator 1
 9750 0024 0E48     		ldr	r0, .L577+12
 9751 0026 E468     		ldr	r4, [r4, #12]
 9752 0028 0568     		ldr	r5, [r0, #0]
 9753 002a AC42     		cmp	r4, r5
 304:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       inFlight = true;
 9754              		.loc 30 304 0 is_stmt 1 discriminator 1
 9755 002c C8BF     		it	gt
 9756 002e 1A70     		strbgt	r2, [r3, #0]
 9757              	.L575:
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   }
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     // Check Mode switch for Acro or Stable
 309:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     //if (receiverCommand[MODE] > 1500) {
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 	flightMode = ATTITUDE_FLIGHT_MODE;
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     //}
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     /*else {
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****         flightMode = RATE_FLIGHT_MODE;
 314:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }*/
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     if (previousFlightMode != flightMode) {
 9758              		.loc 30 316 0
 9759 0030 0C4C     		ldr	r4, .L577+16
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 	flightMode = ATTITUDE_FLIGHT_MODE;
 9760              		.loc 30 310 0
 9761 0032 0D4D     		ldr	r5, .L577+20
 9762              		.loc 30 316 0
 9763 0034 2278     		ldrb	r2, [r4, #0]	@ zero_extendqisi2
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 	flightMode = ATTITUDE_FLIGHT_MODE;
 9764              		.loc 30 310 0
 9765 0036 0123     		movs	r3, #1
 9766              		.loc 30 316 0
 9767 0038 012A     		cmp	r2, #1
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 	flightMode = ATTITUDE_FLIGHT_MODE;
 9768              		.loc 30 310 0
 9769 003a 2B70     		strb	r3, [r5, #0]
 9770              		.loc 30 316 0
 9771 003c 03D0     		beq	.L576
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       zeroIntegralError();
 9772              		.loc 30 317 0
 9773 003e FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****       previousFlightMode = flightMode;
 9774              		.loc 30 318 0
 9775 0042 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 9776 0044 2170     		strb	r1, [r4, #0]
 9777              	.L576:
 319:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     }
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processAltitudeHoldStateFromReceiverCommand();
 9778              		.loc 30 323 0
 9779 0046 FFF7FEFF 		bl	_Z43processAltitudeHoldStateFromReceiverCommandv
 324:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #endif
 325:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #if defined (Lidar2D)
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processHokuyoHoldStateFromReceiverCommand();
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #endif
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #if defined (AutoLanding)
 331:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processAutoLandingStateFromReceiverCommand();
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #endif
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** 
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #if defined (UseGPSNavigator)
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processGpsNavigationStateFromReceiverCommand();
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****   #endif
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h **** }
 9780              		.loc 30 337 0
 9781 004a BDE83840 		pop	{r3, r4, r5, lr}
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h ****     processHokuyoHoldStateFromReceiverCommand();
 9782              		.loc 30 327 0
 9783 004e FFF7FEBF 		b	_Z41processHokuyoHoldStateFromReceiverCommandv
 9784              	.L578:
 9785 0052 00BF     		.align	2
 9786              	.L577:
 9787 0054 00000000 		.word	.LANCHOR1
 9788 0058 00000000 		.word	.LANCHOR8
 9789 005c 00000000 		.word	.LANCHOR138
 9790 0060 00000000 		.word	.LANCHOR125
 9791 0064 00000000 		.word	.LANCHOR141
 9792 0068 00000000 		.word	.LANCHOR119
 9793              		.cfi_endproc
 9794              	.LFE238:
 9796              		.section	.text._Z22initReceiverFromEEPROMv,"ax",%progbits
 9797              		.align	1
 9798              		.global	_Z22initReceiverFromEEPROMv
 9799              		.thumb
 9800              		.thumb_func
 9802              	_Z22initReceiverFromEEPROMv:
 9803              	.LFB251:
 516:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** 
 517:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** void initReceiverFromEEPROM() {
 9804              		.loc 32 517 0
 9805              		.cfi_startproc
 9806              		@ args = 0, pretend = 0, frame = 0
 9807              		@ frame_needed = 0, uses_anonymous_args = 0
 9808 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 9809              	.LCFI91:
 9810              		.cfi_def_cfa_offset 24
 9811              		.cfi_offset 14, -4
 9812              		.cfi_offset 7, -8
 9813              		.cfi_offset 6, -12
 9814              		.cfi_offset 5, -16
 9815              		.cfi_offset 4, -20
 9816              		.cfi_offset 3, -24
 9817              	.LBB250:
 518:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   receiverXmitFactor = readFloat(XMITFACTOR_ADR);
 9818              		.loc 32 518 0
 9819 0002 4FF48E70 		mov	r0, #284
 9820 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 9821 000a 0E4B     		ldr	r3, .L582
 9822 000c 0E4F     		ldr	r7, .L582+4
 9823 000e 0F4E     		ldr	r6, .L582+8
 9824 0010 0F4D     		ldr	r5, .L582+12
 9825 0012 1860     		str	r0, [r3, #0]	@ float
 9826              	.LVL457:
 9827 0014 0024     		movs	r4, #0
 9828              	.LVL458:
 9829              	.L580:
 9830              	.LBB251:
 519:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   
 520:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 521:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSlope[channel] = readFloat(RECEIVER_DATA[channel].slope);
 9831              		.loc 32 521 0 discriminator 2
 9832 0016 04F19C00 		add	r0, r4, #156
 9833 001a FFF7FEFF 		bl	_Z12nvrReadFloati
 9834 001e 47F8040F 		str	r0, [r7, #4]!	@ float
 522:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverOffset[channel] = readFloat(RECEIVER_DATA[channel].offset);
 9835              		.loc 32 522 0 discriminator 2
 9836 0022 04F1A000 		add	r0, r4, #160
 9837 0026 FFF7FEFF 		bl	_Z12nvrReadFloati
 9838 002a 46F8040F 		str	r0, [r6, #4]!	@ float
 523:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****     receiverSmoothFactor[channel] = readFloat(RECEIVER_DATA[channel].smooth_factor);
 9839              		.loc 32 523 0 discriminator 2
 9840 002e 04F1A400 		add	r0, r4, #164
 9841 0032 FFF7FEFF 		bl	_Z12nvrReadFloati
 9842 0036 0C34     		adds	r4, r4, #12
 520:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9843              		.loc 32 520 0 discriminator 2
 9844 0038 602C     		cmp	r4, #96
 9845              		.loc 32 523 0 discriminator 2
 9846 003a 45F8040F 		str	r0, [r5, #4]!	@ float
 520:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 9847              		.loc 32 520 0 discriminator 2
 9848 003e EAD1     		bne	.L580
 9849              	.LBE251:
 9850              	.LBE250:
 524:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h ****   }
 525:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/DataStorage.h **** }
 9851              		.loc 32 525 0
 9852 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 9853              	.L583:
 9854 0042 00BF     		.align	2
 9855              	.L582:
 9856 0044 00000000 		.word	.LANCHOR55
 9857 0048 FCFFFFFF 		.word	.LANCHOR4-4
 9858 004c FCFFFFFF 		.word	.LANCHOR5-4
 9859 0050 FCFFFFFF 		.word	.LANCHOR6-4
 9860              		.cfi_endproc
 9861              	.LFE251:
 9863              		.section	.text._Z17initCommunicationv,"ax",%progbits
 9864              		.align	1
 9865              		.global	_Z17initCommunicationv
 9866              		.thumb
 9867              		.thumb_func
 9869              	_Z17initCommunicationv:
 9870              	.LFB252:
 9871              		.file 34 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   This program is free software: you can redistribute it and/or modify
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   it under the terms of the GNU General Public License as published by
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   the Free Software Foundation, either version 3 of the License, or
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   (at your option) any later version.
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   This program is distributed in the hope that it will be useful,
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   GNU General Public License for more details.
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   You should have received a copy of the GNU General Public License
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // SerialCom.pde is responsible for the serial communication for commands and telemetry from the Ae
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // This comtains readSerialCommand() which listens for a serial command and it's arguments
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // This also contains readSerialTelemetry() which listens for a telemetry request and responds with
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // For more information on each command/telemetry look at: http://aeroquad.com/content.php?117
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // Includes re-write / fixes from Aadamson and ala42, special thanks to those guys!
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // http://aeroquad.com/showthread.php?1461-We-have-some-hidden-warnings&p=14618&viewfull=1#post1461
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #ifndef _AQ_SERIAL_COMM_
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #define _AQ_SERIAL_COMM_
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** char queryType = 'X';
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void initCommunication() {
 9872              		.loc 34 34 0
 9873              		.cfi_startproc
 9874              		@ args = 0, pretend = 0, frame = 0
 9875              		@ frame_needed = 0, uses_anonymous_args = 0
 9876              		@ link register save eliminated.
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // do nothing here for now
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 9877              		.loc 34 36 0
 9878 0000 7047     		bx	lr
 9879              		.cfi_endproc
 9880              	.LFE252:
 9882              		.section	.text._Z10getHeadingv,"ax",%progbits
 9883              		.align	1
 9884              		.global	_Z10getHeadingv
 9885              		.thumb
 9886              		.thumb_func
 9888              	_Z10getHeadingv:
 9889              	.LFB266:
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //********************************** Serial Commands **********************************************
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** bool validateCalibrateCommand(byte command)
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     motorArmed = OFF;
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = command;
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return true;
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   else {
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = 0;
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     testCommand = 1000;
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return false;
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialPID(unsigned char PIDid) {
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->P = readFloatSerial();
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->I = readFloatSerial();
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->D = readFloatSerial();
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->lastError = 0;
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->integratedError = 0;
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void skipSerialValues(byte number) {
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     readFloatSerial();
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialCommand() {
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Check for serial message
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (SERIAL_AVAILABLE()) {
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = SERIAL_READ();
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     //SERIAL_PRINTLN(queryType);
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     switch (queryType) {
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'A': // Receive roll and pitch rate mode PID
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'B': // Receive roll/pitch attitude mode PID
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'C': // Receive yaw PID
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       headingHoldConfig = readFloatSerial();
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'D': // Altitude hold PID
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         altitudeHoldBump = readFloatSerial();
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         minThrottleAdjust = readFloatSerial();
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #if defined AltitudeHoldBaro
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           baroSmoothFactor = readFloatSerial();
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #else
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #endif
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'E': // Receive sensor filtering values
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       aref = readFloatSerial();
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       minArmedThrottle = readFloatSerial();
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'F': // Receive transmitter smoothing values
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'G': // Receive transmitter calibration values
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'H': // Receive transmitter calibration values
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'I': // Initialize EEPROM with default values
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM();
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef HeadingMagHold
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         initializeMagnetometer();
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef AltitudeHoldBaro
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         initializeBaro();
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'J': // calibrate gyros
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'K': // Write accel calibration values
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       computeAccelBias();    
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'L': // generate accel bias
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       computeAccelBias();
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateKinematics();
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         accelOneG = meterPerSecSec[ZAXIS];
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'M': // calibrate magnetometer
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef HeadingMagHold
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         writeEEPROM();
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(3);
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'N': // battery monitor
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef BattMonitor
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(3);
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'O': // define waypoints
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef UseGPSNavigator
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         missionNbPoint = readIntegerSerial();
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         waypoint[missionNbPoint].latitude = readIntegerSerial();
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         waypoint[missionNbPoint].longitude = readIntegerSerial();
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         waypoint[missionNbPoint].altitude = readIntegerSerial();
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for(byte i = 0; i < 4; i++) {
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         }
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'P': //  read Camera values
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef CameraControl
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         cameraMode = readFloatSerial();
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterPitch = readFloatSerial();
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterRoll = readFloatSerial();
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoCenterYaw = readFloatSerial();
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraPitch = readFloatSerial();
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraRoll = readFloatSerial();
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         mCameraYaw = readFloatSerial();
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinPitch = readFloatSerial();
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinRoll = readFloatSerial();
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMinYaw = readFloatSerial();
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxPitch = readFloatSerial();
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxRoll = readFloatSerial();
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         servoMaxYaw = readFloatSerial();
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #ifdef CameraTXControl
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           servoTXChannels = readFloatSerial();
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #endif
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #ifdef CameraTXControl
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           skipSerialValues(14)
 228:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #else
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           skipSerialValues(13);
 230:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         #endif
 231:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 232:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 233:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 234:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'U': // Range Finder
 235:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined (AltitudeHoldRangeFinder)
 236:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         maxRangeFinderRange = readFloatSerial();
 237:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         minRangeFinderRange = readFloatSerial();
 238:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(2);
 240:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 241:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 242:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 243:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'V': // GPS
 244:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined UseGPSNavigator || defined Lidar2D
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSROLL_PID_IDX);
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSPITCH_PID_IDX);
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSYAW_PID_IDX);
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         writeEEPROM();
 249:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 250:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(9);
 251:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 252:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 253:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 254:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'W': // Write all user configurable values to EEPROM
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 257:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 258:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 259:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'X': // Stop sending messages
 260:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 261:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 262:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '1': // Calibrate ESCS's by setting Throttle high on all channels
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(1);
 264:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 265:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 266:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '2': // Calibrate ESC's by setting Throttle low on all channels
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(2);
 268:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 269:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 270:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '3': // Test ESC calibration
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(3)) {
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = readFloatSerial();
 273:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 274:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 275:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 276:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '4': // Turn off ESC calibration
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(4)) {
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 280:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 281:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 282:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 283:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case '5': // Send individual motor commands (motor, command)
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(5)) {
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++) {
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 287:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         }
 288:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 289:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 290:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 291:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     case 'Z': // fast telemetry transfer <--- get rid if this?
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (readFloatSerial() == 1.0)
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = ON;
 294:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       else
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = OFF;
 296:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 297:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 298:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 300:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 301:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
 302:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //********************************* Serial Telemetry **********************************************
 303:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //*************************************************************************************************
 304:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(float val) {
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 309:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(double val) {
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 314:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(char val) {
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 319:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(int val) {
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 324:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 325:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(unsigned long val)
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 330:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 331:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(byte val)
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(long int val)
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 342:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintPID(unsigned char IDPid)
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 348:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 349:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintDummyValues(byte number) {
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(0);
 353:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 354:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 355:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 356:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 357:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** float getHeading()
 358:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 9890              		.loc 34 358 0
 9891              		.cfi_startproc
 9892              		@ args = 0, pretend = 0, frame = 0
 9893              		@ frame_needed = 0, uses_anonymous_args = 0
 9894              		@ link register save eliminated.
 359:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 360:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     float heading = trueNorthHeading;
 361:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     if (heading < 0) { 
 362:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       heading += (2.0 * M_PI);
 363:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 364:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return heading;
 365:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #else
 366:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return(gyroHeading);
 367:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #endif
 368:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 9895              		.loc 34 368 0
 9896 0000 014B     		ldr	r3, .L586
 9897 0002 1868     		ldr	r0, [r3, #0]	@ float
 9898 0004 7047     		bx	lr
 9899              	.L587:
 9900 0006 00BF     		.align	2
 9901              	.L586:
 9902 0008 00000000 		.word	.LANCHOR20
 9903              		.cfi_endproc
 9904              	.LFE266:
 9906              		.section	.text._Z15readValueSerialPch,"ax",%progbits
 9907              		.align	1
 9908              		.global	_Z15readValueSerialPch
 9909              		.thumb
 9910              		.thumb_func
 9912              	_Z15readValueSerialPch:
 9913              	.LFB268:
 369:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 372:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '=': // Reserved debug command to view any variable from Serial Monitor
 373:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 374:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   
 375:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'a': // Send roll and pitch rate mode PID values
 376:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 377:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 378:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 379:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 380:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 381:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 382:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 383:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'b': // Send roll and pitch attitude mode PID values
 384:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 385:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 386:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 387:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 388:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 389:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 390:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 391:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 392:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'c': // Send yaw PID values
 393:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 394:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 395:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 396:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 397:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 398:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 399:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'd': // Altitude Hold
 400:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 401:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 402:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 403:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 404:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 405:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 406:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 407:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined AltitudeHoldBaro
 408:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 409:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 410:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 411:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 412:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 413:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 414:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(10);
 415:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 416:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 417:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 418:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 419:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 420:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'e': // miscellaneous config values
 421:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(aref);
 422:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 423:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 424:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 425:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 426:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'f': // Send transmitter smoothing values
 427:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 428:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 429:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 430:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 431:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(10 - LASTCHANNEL);
 432:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 433:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 434:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 435:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 436:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'g': // Send transmitter calibration data
 437:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 438:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 439:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 440:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 441:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 442:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 443:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 444:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 445:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'h': // Send transmitter calibration data
 446:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 447:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 448:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 449:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 450:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 451:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 452:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 453:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 454:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'i': // Send sensor data
 455:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 456:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 457:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 458:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 459:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 460:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 461:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 462:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined(HeadingMagHold)
 463:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 464:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 465:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 466:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 467:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 468:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 469:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 470:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 471:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'j': // Send raw mag values
 472:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef HeadingMagHold
 473:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 474:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 475:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 476:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 477:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 478:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 479:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'k': // Send accelerometer cal values
 480:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 481:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 482:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 483:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 484:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 486:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 488:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 489:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 490:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 491:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 492:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 493:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 494:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'l': // Send raw accel values
 495:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     measureAccelSum();
 496:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[XAXIS] = 0;
 498:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 499:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[YAXIS] = 0;
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[ZAXIS] = 0;
 502:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSampleCount = 0;
 503:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 504:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 505:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'm': // Send magnetometer cal values
 506:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef HeadingMagHold
 507:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 508:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       comma();
 509:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       comma();
 511:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 513:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 514:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 515:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 516:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'n': // battery monitor
 517:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef BattMonitor
 518:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 519:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 520:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(batteryMonitorGoingDownTime);
 521:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 522:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 523:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 524:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 525:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 526:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 527:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 528:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'o': // send waypoints
 529:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef UseGPSNavigator
 530:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       for (byte index = 0; index < MAX_WAYPOINTS; index++) {
 531:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(index);
 532:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(waypoint[index].latitude);
 533:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(waypoint[index].longitude);
 534:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(waypoint[index].altitude);
 535:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       }
 536:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 537:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(4);
 538:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 539:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 540:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 541:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 542:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 543:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'p': // Send Camera values
 544:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef CameraControl
 545:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(cameraMode);
 546:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterPitch);
 547:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterRoll);
 548:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoCenterYaw);
 549:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraPitch);
 550:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraRoll);
 551:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(mCameraYaw);
 552:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinPitch);
 553:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinRoll);
 554:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMinYaw);
 555:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxPitch);
 556:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxRoll);
 557:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(servoMaxYaw);
 558:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef CameraTXControl
 559:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(servoTXChannels);
 560:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 561:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 562:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #ifdef CameraTXControl
 563:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(14);
 564:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 565:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(13);
 566:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 567:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 568:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 569:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 570:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 571:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 572:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'q': // Send Vehicle State Value
 573:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 574:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 575:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 576:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 577:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'r': // Vehicle attitude
 578:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 579:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 580:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(getHeading());
 581:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 582:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 583:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 's': // Send all flight data
 584:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(motorArmed);
 585:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 586:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 587:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(getHeading());
 588:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 589:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined AltitudeHoldBaro
 590:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(getBaroAltitude());
 591:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #elif defined AltitudeHoldRangeFinder
 592:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] != INVALID_RANGE ? rangeFinde
 593:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 594:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 595:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 596:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 597:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 598:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 599:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 600:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 601:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 602:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 603:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 604:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 605:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 606:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 607:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 608:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 609:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef BattMonitor
 610:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 611:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 612:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 613:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 614:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(flightMode);
 615:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 616:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 617:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'S':
 618:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 	for (byte motor = 0; motor < LASTMOTOR; motor++) {
 619:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 620:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 	PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 622:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 	SERIAL_PRINTLN();
 623:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 	break;
 624:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 't': // Send processed transmitter values
 625:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 626:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 627:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 628:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 629:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 630:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 631:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'u': // Send range finder values
 632:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (AltitudeHoldRangeFinder)
 633:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(maxRangeFinderRange);
 634:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(minRangeFinderRange);
 635:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     /*
 636:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #elif defined (AltitudeLidar)
 637:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldState);
 638:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(baroAltitudeToHoldTarget);
 639:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(estimatedAltitude);
 640:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldThrottleCorrectionGLOBAL);
 641:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(LidarHoldThrottle);
 642:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldThrottle);
 643:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(throttle);
 644:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       //SERIAL_PRINTLN(zDirection);
 645:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       //SERIAL_PRINTLN(meanAltitude);
 646:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       //PrintValueComma(zDampeningThrottleCorrection);
 647:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       //SERIAL_PRINTLN();    //Terminate CMD
 648:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       */
 649:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #elif defined (Lidar2D)     
 650:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(HokuyoHoldState);
 651:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyo_YRaw);  //pitch
 652:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(distance2D[plus_Y]);  //pitch
 653:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyo_XRaw);  //roll
 654:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(distance2D[plus_X]);  //roll
 655:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(HokuyoPositionToHoldTarget_X); 
 656:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyoHoldThrottleCorrection_X);
 657:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorAxisCommandRoll);
 658:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(temphokuyoHoldThrottleCorrection_XGLOBAL);
 659:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 660:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else  
 661:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 662:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         SERIAL_PRINTLN(0);
 663:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 664:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     //queryType = 'X';
 665:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 666:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 667:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'v': // Send GPS PIDs
 668:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (UseGPSNavigator) || defined (Lidar2D)
 669:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSROLL_PID_IDX);
 670:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSPITCH_PID_IDX);
 671:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSYAW_PID_IDX);
 672:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       queryType = 'X';
 673:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 674:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(9);
 675:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 676:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 677:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 678:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 679:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'y': // send GPS info
 680:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (UseGPS)
 681:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.state);
 682:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.lat);
 683:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.lon);
 684:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.height);
 685:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.course);
 686:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.speed);
 687:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.accuracy);
 688:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.sats);
 689:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.fixtime);
 690:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.sentences);
 691:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gpsData.idlecount);
 692:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 693:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(11);
 694:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif    
 695:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 696:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 697:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****  
 698:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'z': // Send all Altitude data 
 699:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (AltitudeHoldBaro) 
 700:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getBaroAltitude()); 
 701:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 702:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 703:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif 
 704:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (AltitudeHoldRangeFinder) 
 705:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX]);
 706:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 707:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0); 
 708:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif 
 709:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 710:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     
 711:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '$': // send BatteryMonitor voltage/current readings
 712:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (BattMonitor)
 713:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 714:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #if defined (BM_EXTENDED)
 715:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma((float)batteryData[0].current/100.0);
 716:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma((float)batteryData[0].usedCapacity/1000.0);
 717:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #else
 718:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(2);
 719:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       #endif
 720:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 721:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 722:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 723:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 724:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 725:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     
 726:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '%': // send RSSI
 727:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #if defined (UseAnalogRSSIReader) || defined (UseEzUHFRSSIReader) || defined (UseSBUSRSSIReader
 728:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(rssiRawValue);
 729:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 730:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 731:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 732:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 733:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 734:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case 'x': // Stop sending messages
 735:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 736:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 737:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '!': // Send flight software version
 738:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 739:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 740:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 741:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 742:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '#': // Send configuration
 743:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     reportVehicleState();
 744:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 745:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 746:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 747:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '6': // Report remote commands
 748:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 749:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 750:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 751:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 752:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 753:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 754:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 755:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #if defined(OSD) && defined(OSD_LOADFONT)
 756:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   case '&': // fontload
 757:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     if (OFF == motorArmed) {
 758:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       max7456LoadFont();
 759:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 760:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 761:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 762:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #endif
 763:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** //default : SERIAL_PRINTLN(queryType);break;
 764:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 765:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 766:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 767:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 768:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readValueSerial(char *data, byte size) {
 9914              		.loc 34 768 0
 9915              		.cfi_startproc
 9916              		@ args = 0, pretend = 0, frame = 0
 9917              		@ frame_needed = 0, uses_anonymous_args = 0
 9918              	.LVL459:
 9919 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 9920              	.LCFI92:
 9921              		.cfi_def_cfa_offset 24
 9922              		.cfi_offset 14, -4
 9923              		.cfi_offset 7, -8
 9924              		.cfi_offset 6, -12
 9925              		.cfi_offset 5, -16
 9926              		.cfi_offset 4, -20
 9927              		.cfi_offset 3, -24
 9928              	.LBB252:
 769:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte index = 0;
 770:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte timeout = 0;
 771:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   data[0] = '\0';
 9929              		.loc 34 771 0
 9930 0002 0026     		movs	r6, #0
 9931              	.LBE252:
 768:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readValueSerial(char *data, byte size) {
 9932              		.loc 34 768 0
 9933 0004 0446     		mov	r4, r0
 9934 0006 0F46     		mov	r7, r1
 9935              	.LBB253:
 9936              		.loc 34 771 0
 9937 0008 0670     		strb	r6, [r0, #0]
 769:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte index = 0;
 9938              		.loc 34 769 0
 9939 000a 3546     		mov	r5, r6
 9940              	.LVL460:
 9941              	.L593:
 772:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 773:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 774:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     if (SERIAL_AVAILABLE() == 0) {
 9942              		.loc 34 774 0
 9943 000c 0F48     		ldr	r0, .L595
 9944 000e FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 9945 0012 28B9     		cbnz	r0, .L589
 775:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       delay(1);
 9946              		.loc 34 775 0
 9947 0014 0120     		movs	r0, #1
 776:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       timeout++;
 9948              		.loc 34 776 0
 9949 0016 0136     		adds	r6, r6, #1
 9950              	.LVL461:
 775:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       delay(1);
 9951              		.loc 34 775 0
 9952 0018 FFF7FEFF 		bl	_Z5delaym
 9953              		.loc 34 776 0
 9954 001c F6B2     		uxtb	r6, r6
 9955              	.LVL462:
 9956 001e 06E0     		b	.L590
 9957              	.L589:
 777:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     } else {
 778:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       data[index] = SERIAL_READ();
 9958              		.loc 34 778 0
 9959 0020 0A48     		ldr	r0, .L595
 9960 0022 FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 9961 0026 6055     		strb	r0, [r4, r5]
 9962              	.LVL463:
 779:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       timeout = 0;
 780:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       index++;
 9963              		.loc 34 780 0
 9964 0028 0135     		adds	r5, r5, #1
 9965              	.LVL464:
 9966 002a EDB2     		uxtb	r5, r5
 9967              	.LVL465:
 779:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       timeout = 0;
 9968              		.loc 34 779 0
 9969 002c 0026     		movs	r6, #0
 9970              	.LVL466:
 9971              	.L590:
 773:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 9972              		.loc 34 773 0
 9973 002e 25B1     		cbz	r5, .L591
 773:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 9974              		.loc 34 773 0 is_stmt 0 discriminator 2
 9975 0030 6019     		adds	r0, r4, r5
 9976 0032 10F8013C 		ldrb	r3, [r0, #-1]	@ zero_extendqisi2
 9977 0036 3B2B     		cmp	r3, #59
 9978 0038 04D0     		beq	.L592
 9979              	.L591:
 773:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 9980              		.loc 34 773 0 discriminator 1
 9981 003a 092E     		cmp	r6, #9
 9982 003c 02D8     		bhi	.L592
 773:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   do {
 9983              		.loc 34 773 0 discriminator 4
 9984 003e 791E     		subs	r1, r7, #1
 9985 0040 8D42     		cmp	r5, r1
 9986 0042 E3DB     		blt	.L593
 9987              	.L592:
 781:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     }
 782:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   } while ((index == 0 || data[index-1] != ';') && (timeout < 10) && (index < size-1));
 783:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 784:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   data[index] = '\0';
 9988              		.loc 34 784 0 is_stmt 1
 9989 0044 0022     		movs	r2, #0
 9990 0046 6255     		strb	r2, [r4, r5]
 9991              	.LBE253:
 785:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 9992              		.loc 34 785 0
 9993 0048 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 9994              	.L596:
 9995 004a 00BF     		.align	2
 9996              	.L595:
 9997 004c 00000000 		.word	Serial1
 9998              		.cfi_endproc
 9999              	.LFE268:
 10001              		.section	.text._Z15readFloatSerialv,"ax",%progbits
 10002              		.align	1
 10003              		.global	_Z15readFloatSerialv
 10004              		.thumb
 10005              		.thumb_func
 10007              	_Z15readFloatSerialv:
 10008              	.LFB269:
 786:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 787:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 788:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // Used to read floating point values from the serial port
 789:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** float readFloatSerial() {
 10009              		.loc 34 789 0
 10010              		.cfi_startproc
 10011              		@ args = 0, pretend = 0, frame = 16
 10012              		@ frame_needed = 0, uses_anonymous_args = 0
 10013 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 10014              	.LCFI93:
 10015              		.cfi_def_cfa_offset 24
 10016              		.cfi_offset 14, -4
 10017              		.cfi_offset 4, -8
 10018              		.cfi_offset 3, -12
 10019              		.cfi_offset 2, -16
 10020              		.cfi_offset 1, -20
 10021              		.cfi_offset 0, -24
 10022              	.LBB254:
 790:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   char data[15] = "";
 10023              		.loc 34 790 0
 10024 0002 0021     		movs	r1, #0
 10025 0004 0B22     		movs	r2, #11
 10026 0006 01A8     		add	r0, sp, #4
 10027 0008 0091     		str	r1, [sp, #0]
 10028 000a FFF7FEFF 		bl	memset
 791:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 792:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   readValueSerial(data, sizeof(data));
 10029              		.loc 34 792 0
 10030 000e 6846     		mov	r0, sp
 10031 0010 0F21     		movs	r1, #15
 10032 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 793:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   return atof(data);
 10033              		.loc 34 793 0
 10034 0016 6846     		mov	r0, sp
 10035 0018 FFF7FEFF 		bl	atof
 10036 001c FFF7FEFF 		bl	__aeabi_d2f
 10037              	.LBE254:
 794:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10038              		.loc 34 794 0
 10039 0020 05B0     		add	sp, sp, #20
 10040 0022 00BD     		pop	{pc}
 10041              		.cfi_endproc
 10042              	.LFE269:
 10044              		.section	.text._Z16skipSerialValuesh,"ax",%progbits
 10045              		.align	1
 10046              		.global	_Z16skipSerialValuesh
 10047              		.thumb
 10048              		.thumb_func
 10050              	_Z16skipSerialValuesh:
 10051              	.LFB255:
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void skipSerialValues(byte number) {
 10052              		.loc 34 64 0
 10053              		.cfi_startproc
 10054              		@ args = 0, pretend = 0, frame = 0
 10055              		@ frame_needed = 0, uses_anonymous_args = 0
 10056              	.LVL467:
 10057 0000 38B5     		push	{r3, r4, r5, lr}
 10058              	.LCFI94:
 10059              		.cfi_def_cfa_offset 16
 10060              		.cfi_offset 14, -4
 10061              		.cfi_offset 5, -8
 10062              		.cfi_offset 4, -12
 10063              		.cfi_offset 3, -16
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void skipSerialValues(byte number) {
 10064              		.loc 34 64 0
 10065 0002 0546     		mov	r5, r0
 10066              	.LBB255:
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 10067              		.loc 34 65 0
 10068 0004 0024     		movs	r4, #0
 10069 0006 03E0     		b	.L599
 10070              	.LVL468:
 10071              	.L600:
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     readFloatSerial();
 10072              		.loc 34 66 0 discriminator 2
 10073 0008 FFF7FEFF 		bl	_Z15readFloatSerialv
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 10074              		.loc 34 65 0 discriminator 2
 10075 000c 0134     		adds	r4, r4, #1
 10076              	.LVL469:
 10077 000e E4B2     		uxtb	r4, r4
 10078              	.LVL470:
 10079              	.L599:
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 10080              		.loc 34 65 0 is_stmt 0 discriminator 1
 10081 0010 AC42     		cmp	r4, r5
 10082 0012 F9D1     		bne	.L600
 10083              	.LBE255:
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10084              		.loc 34 68 0 is_stmt 1
 10085 0014 38BD     		pop	{r3, r4, r5, pc}
 10086              		.cfi_endproc
 10087              	.LFE255:
 10089              		.section	.text._Z13readSerialPIDh,"ax",%progbits
 10090              		.align	1
 10091              		.global	_Z13readSerialPIDh
 10092              		.thumb
 10093              		.thumb_func
 10095              	_Z13readSerialPIDh:
 10096              	.LFB254:
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 10097              		.loc 34 55 0
 10098              		.cfi_startproc
 10099              		@ args = 0, pretend = 0, frame = 0
 10100              		@ frame_needed = 0, uses_anonymous_args = 0
 10101              	.LVL471:
 10102              	.LBB256:
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 10103              		.loc 34 56 0
 10104 0000 0849     		ldr	r1, .L602
 10105              	.LBE256:
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 10106              		.loc 34 55 0
 10107 0002 10B5     		push	{r4, lr}
 10108              	.LCFI95:
 10109              		.cfi_def_cfa_offset 8
 10110              		.cfi_offset 14, -4
 10111              		.cfi_offset 4, -8
 10112              	.LBB257:
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 10113              		.loc 34 56 0
 10114 0004 1C24     		movs	r4, #28
 10115 0006 04FB0014 		mla	r4, r4, r0, r1
 10116              	.LVL472:
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->P = readFloatSerial();
 10117              		.loc 34 57 0
 10118 000a FFF7FEFF 		bl	_Z15readFloatSerialv
 10119              	.LVL473:
 10120 000e 2060     		str	r0, [r4, #0]	@ float
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->I = readFloatSerial();
 10121              		.loc 34 58 0
 10122 0010 FFF7FEFF 		bl	_Z15readFloatSerialv
 10123 0014 6060     		str	r0, [r4, #4]	@ float
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->D = readFloatSerial();
 10124              		.loc 34 59 0
 10125 0016 FFF7FEFF 		bl	_Z15readFloatSerialv
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->lastError = 0;
 10126              		.loc 34 60 0
 10127 001a 0023     		movs	r3, #0
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->D = readFloatSerial();
 10128              		.loc 34 59 0
 10129 001c A060     		str	r0, [r4, #8]	@ float
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->lastError = 0;
 10130              		.loc 34 60 0
 10131 001e E360     		str	r3, [r4, #12]	@ float
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   pid->integratedError = 0;
 10132              		.loc 34 61 0
 10133 0020 6361     		str	r3, [r4, #20]	@ float
 10134              	.LBE257:
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10135              		.loc 34 62 0
 10136 0022 10BD     		pop	{r4, pc}
 10137              	.L603:
 10138              		.align	2
 10139              	.L602:
 10140 0024 00000000 		.word	.LANCHOR9
 10141              		.cfi_endproc
 10142              	.LFE254:
 10144              		.section	.text._Z24validateCalibrateCommandh,"ax",%progbits
 10145              		.align	1
 10146              		.global	_Z24validateCalibrateCommandh
 10147              		.thumb
 10148              		.thumb_func
 10150              	_Z24validateCalibrateCommandh:
 10151              	.LFB253:
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10152              		.loc 34 42 0
 10153              		.cfi_startproc
 10154              		@ args = 0, pretend = 0, frame = 0
 10155              		@ frame_needed = 0, uses_anonymous_args = 0
 10156              	.LVL474:
 10157 0000 10B5     		push	{r4, lr}
 10158              	.LCFI96:
 10159              		.cfi_def_cfa_offset 8
 10160              		.cfi_offset 14, -4
 10161              		.cfi_offset 4, -8
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10162              		.loc 34 42 0
 10163 0002 0446     		mov	r4, r0
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
 10164              		.loc 34 43 0
 10165 0004 FFF7FEFF 		bl	_Z15readFloatSerialv
 10166              	.LVL475:
 10167 0008 DFED0B7A 		flds	s15, .L607
 10168 000c 07EE100A 		fmsr	s14, r0
 10169 0010 B4EE677A 		fcmps	s14, s15
 10170 0014 F1EE10FA 		fmstat
 10171 0018 4FF00000 		mov	r0, #0
 10172 001c 074B     		ldr	r3, .L607+4
 10173 001e 04D1     		bne	.L605
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     motorArmed = OFF;
 10174              		.loc 34 44 0
 10175 0020 074A     		ldr	r2, .L607+8
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = command;
 10176              		.loc 34 45 0
 10177 0022 1C70     		strb	r4, [r3, #0]
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     motorArmed = OFF;
 10178              		.loc 34 44 0
 10179 0024 1070     		strb	r0, [r2, #0]
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     return true;
 10180              		.loc 34 46 0
 10181 0026 0120     		movs	r0, #1
 10182 0028 10BD     		pop	{r4, pc}
 10183              	.L605:
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     calibrateESC = 0;
 10184              		.loc 34 49 0
 10185 002a 1870     		strb	r0, [r3, #0]
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     testCommand = 1000;
 10186              		.loc 34 50 0
 10187 002c 054B     		ldr	r3, .L607+12
 10188 002e 4FF47A71 		mov	r1, #1000
 10189 0032 1960     		str	r1, [r3, #0]
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10190              		.loc 34 53 0
 10191 0034 10BD     		pop	{r4, pc}
 10192              	.L608:
 10193 0036 00BF     		.align	2
 10194              	.L607:
 10195 0038 66E6F642 		.word	1123477094
 10196 003c 00000000 		.word	.LANCHOR121
 10197 0040 00000000 		.word	.LANCHOR138
 10198 0044 00000000 		.word	.LANCHOR122
 10199              		.cfi_endproc
 10200              	.LFE253:
 10202              		.section	.text._Z17readSerialCommandv,"ax",%progbits
 10203              		.align	1
 10204              		.global	_Z17readSerialCommandv
 10205              		.thumb
 10206              		.thumb_func
 10208              	_Z17readSerialCommandv:
 10209              	.LFB256:
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialCommand() {
 10210              		.loc 34 70 0
 10211              		.cfi_startproc
 10212              		@ args = 0, pretend = 0, frame = 0
 10213              		@ frame_needed = 0, uses_anonymous_args = 0
 10214 0000 38B5     		push	{r3, r4, r5, lr}
 10215              	.LCFI97:
 10216              		.cfi_def_cfa_offset 16
 10217              		.cfi_offset 14, -4
 10218              		.cfi_offset 5, -8
 10219              		.cfi_offset 4, -12
 10220              		.cfi_offset 3, -16
 10221              	.LBB258:
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (SERIAL_AVAILABLE()) {
 10222              		.loc 34 72 0
 10223 0002 8748     		ldr	r0, .L646
 10224 0004 FFF7FEFF 		bl	_ZN14HardwareSerial9availableEv
 10225 0008 0028     		cmp	r0, #0
 10226 000a 00F09081 		beq	.L609
 10227              	.LBB259:
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = SERIAL_READ();
 10228              		.loc 34 73 0
 10229 000e 8448     		ldr	r0, .L646
 10230 0010 FFF7FEFF 		bl	_ZN14HardwareSerial4readEv
 10231 0014 834B     		ldr	r3, .L646+4
 10232 0016 C0B2     		uxtb	r0, r0
 10233 0018 1870     		strb	r0, [r3, #0]
 10234              	.LBB260:
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     switch (queryType) {
 10235              		.loc 34 75 0
 10236 001a 3138     		subs	r0, r0, #49
 10237 001c 2928     		cmp	r0, #41
 10238 001e 00F28681 		bhi	.L609
 10239 0022 DFE810F0 		tbh	[pc, r0, lsl #1]
 10240              	.L636:
 10241 0026 3D01     		.2byte	(.L611-.L636)/2
 10242 0028 3F01     		.2byte	(.L612-.L636)/2
 10243 002a 4401     		.2byte	(.L613-.L636)/2
 10244 002c 5301     		.2byte	(.L614-.L636)/2
 10245 002e 6001     		.2byte	(.L615-.L636)/2
 10246 0030 8401     		.2byte	(.L609-.L636)/2
 10247 0032 8401     		.2byte	(.L609-.L636)/2
 10248 0034 8401     		.2byte	(.L609-.L636)/2
 10249 0036 8401     		.2byte	(.L609-.L636)/2
 10250 0038 8401     		.2byte	(.L609-.L636)/2
 10251 003a 8401     		.2byte	(.L609-.L636)/2
 10252 003c 8401     		.2byte	(.L609-.L636)/2
 10253 003e 8401     		.2byte	(.L609-.L636)/2
 10254 0040 8401     		.2byte	(.L609-.L636)/2
 10255 0042 8401     		.2byte	(.L609-.L636)/2
 10256 0044 8401     		.2byte	(.L609-.L636)/2
 10257 0046 3400     		.2byte	(.L616-.L636)/2
 10258 0048 3E00     		.2byte	(.L617-.L636)/2
 10259 004a 4F00     		.2byte	(.L618-.L636)/2
 10260 004c 6000     		.2byte	(.L619-.L636)/2
 10261 004e 9500     		.2byte	(.L620-.L636)/2
 10262 0050 A300     		.2byte	(.L621-.L636)/2
 10263 0052 B100     		.2byte	(.L622-.L636)/2
 10264 0054 C000     		.2byte	(.L623-.L636)/2
 10265 0056 D200     		.2byte	(.L624-.L636)/2
 10266 0058 E000     		.2byte	(.L625-.L636)/2
 10267 005a E400     		.2byte	(.L626-.L636)/2
 10268 005c F400     		.2byte	(.L627-.L636)/2
 10269 005e FA00     		.2byte	(.L629-.L636)/2
 10270 0060 FA00     		.2byte	(.L629-.L636)/2
 10271 0062 2A00     		.2byte	(.L630-.L636)/2
 10272 0064 2301     		.2byte	(.L631-.L636)/2
 10273 0066 8401     		.2byte	(.L609-.L636)/2
 10274 0068 8401     		.2byte	(.L609-.L636)/2
 10275 006a 8401     		.2byte	(.L609-.L636)/2
 10276 006c 8401     		.2byte	(.L609-.L636)/2
 10277 006e 2801     		.2byte	(.L632-.L636)/2
 10278 0070 2A01     		.2byte	(.L633-.L636)/2
 10279 0072 3701     		.2byte	(.L634-.L636)/2
 10280 0074 8401     		.2byte	(.L609-.L636)/2
 10281 0076 8401     		.2byte	(.L609-.L636)/2
 10282 0078 7301     		.2byte	(.L635-.L636)/2
 10283              	.L630:
 10284              	.LVL476:
 10285              	.LBB261:
 10286              	.LBB262:
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 10287              		.loc 34 203 0 discriminator 1
 10288 007a FFF7FEFF 		bl	_Z15readFloatSerialv
 10289              	.LVL477:
 10290 007e FFF7FEFF 		bl	_Z15readFloatSerialv
 10291              	.LVL478:
 10292 0082 FFF7FEFF 		bl	_Z15readFloatSerialv
 10293              	.LVL479:
 10294              	.LBE262:
 10295              	.LBE261:
 10296              	.LBE260:
 10297              	.LBE259:
 10298              	.LBE258:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10299              		.loc 34 299 0 discriminator 1
 10300 0086 BDE83840 		pop	{r3, r4, r5, lr}
 10301              	.LBB294:
 10302              	.LBB285:
 10303              	.LBB276:
 10304              	.LBB267:
 10305              	.LBB263:
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           readFloatSerial();
 10306              		.loc 34 203 0 discriminator 1
 10307 008a FFF7FEBF 		b	_Z15readFloatSerialv
 10308              	.LVL480:
 10309              	.L616:
 10310              	.LBE263:
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
 10311              		.loc 34 77 0
 10312 008e 0020     		movs	r0, #0
 10313 0090 FFF7FEFF 		bl	_Z13readSerialPIDh
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
 10314              		.loc 34 78 0
 10315 0094 0120     		movs	r0, #1
 10316 0096 FFF7FEFF 		bl	_Z13readSerialPIDh
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
 10317              		.loc 34 79 0
 10318 009a FFF7FEFF 		bl	_Z15readFloatSerialv
 10319 009e 624B     		ldr	r3, .L646+8
 10320 00a0 0EE0     		b	.L645
 10321              	.L617:
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
 10322              		.loc 34 83 0
 10323 00a2 0320     		movs	r0, #3
 10324 00a4 FFF7FEFF 		bl	_Z13readSerialPIDh
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
 10325              		.loc 34 84 0
 10326 00a8 0420     		movs	r0, #4
 10327 00aa FFF7FEFF 		bl	_Z13readSerialPIDh
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 10328              		.loc 34 85 0
 10329 00ae 0620     		movs	r0, #6
 10330 00b0 FFF7FEFF 		bl	_Z13readSerialPIDh
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 10331              		.loc 34 86 0
 10332 00b4 0720     		movs	r0, #7
 10333 00b6 FFF7FEFF 		bl	_Z13readSerialPIDh
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       windupGuard = readFloatSerial(); // defaults found in setup() of AeroQuad.pde
 10334              		.loc 34 87 0
 10335 00ba FFF7FEFF 		bl	_Z15readFloatSerialv
 10336 00be 5B4B     		ldr	r3, .L646+12
 10337              	.L645:
 10338 00c0 1860     		str	r0, [r3, #0]	@ float
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 10339              		.loc 34 88 0
 10340 00c2 38BD     		pop	{r3, r4, r5, pc}
 10341              	.L618:
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
 10342              		.loc 34 91 0
 10343 00c4 0220     		movs	r0, #2
 10344 00c6 FFF7FEFF 		bl	_Z13readSerialPIDh
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
 10345              		.loc 34 92 0
 10346 00ca 0520     		movs	r0, #5
 10347 00cc FFF7FEFF 		bl	_Z13readSerialPIDh
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       headingHoldConfig = readFloatSerial();
 10348              		.loc 34 93 0
 10349 00d0 FFF7FEFF 		bl	_Z15readFloatSerialv
 10350 00d4 00EE100A 		fmsr	s0, r0
 10351 00d8 BCEEC07A 		ftouizs	s14, s0
 10352 00dc 544A     		ldr	r2, .L646+16
 10353 00de 17EE101A 		fmrs	r1, s14	@ int
 10354 00e2 1170     		strb	r1, [r2, #0]
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 10355              		.loc 34 94 0
 10356 00e4 38BD     		pop	{r3, r4, r5, pc}
 10357              	.L619:
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
 10358              		.loc 34 98 0
 10359 00e6 0820     		movs	r0, #8
 10360 00e8 FFF7FEFF 		bl	_Z13readSerialPIDh
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard = readFloatSerial();
 10361              		.loc 34 99 0
 10362 00ec FFF7FEFF 		bl	_Z15readFloatSerialv
 10363 00f0 5049     		ldr	r1, .L646+20
 10364 00f2 C1F8F800 		str	r0, [r1, #248]	@ float
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         altitudeHoldBump = readFloatSerial();
 10365              		.loc 34 100 0
 10366 00f6 FFF7FEFF 		bl	_Z15readFloatSerialv
 10367 00fa 03EE900A 		fmsr	s7, r0
 10368 00fe 4E4B     		ldr	r3, .L646+24
 10369 0100 BDEEE33A 		ftosizs	s6, s7
 10370 0104 83ED003A 		fsts	s6, [r3, #0]	@ int
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
 10371              		.loc 34 101 0
 10372 0108 FFF7FEFF 		bl	_Z15readFloatSerialv
 10373 010c 02EE900A 		fmsr	s5, r0
 10374 0110 4A4A     		ldr	r2, .L646+28
 10375 0112 BDEEE22A 		ftosizs	s4, s5
 10376 0116 82ED002A 		fsts	s4, [r2, #0]	@ int
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         minThrottleAdjust = readFloatSerial();
 10377              		.loc 34 102 0
 10378 011a FFF7FEFF 		bl	_Z15readFloatSerialv
 10379 011e 01EE900A 		fmsr	s3, r0
 10380 0122 4749     		ldr	r1, .L646+32
 10381 0124 FDEEE17A 		ftosizs	s15, s3
 10382 0128 C1ED007A 		fsts	s15, [r1, #0]	@ int
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
 10383              		.loc 34 103 0
 10384 012c FFF7FEFF 		bl	_Z15readFloatSerialv
 10385 0130 01EE100A 		fmsr	s2, r0
 10386 0134 4348     		ldr	r0, .L646+36
 10387 0136 FDEEC10A 		ftosizs	s1, s2
 10388 013a C0ED000A 		fsts	s1, [r0, #0]	@ int
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           baroSmoothFactor = readFloatSerial();
 10389              		.loc 34 105 0
 10390 013e FFF7FEFF 		bl	_Z15readFloatSerialv
 10391 0142 414B     		ldr	r3, .L646+40
 10392 0144 1860     		str	r0, [r3, #0]	@ float
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 10393              		.loc 34 109 0
 10394 0146 0920     		movs	r0, #9
 10395              	.LBE267:
 10396              	.LBE276:
 10397              	.LBE285:
 10398              	.LBE294:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10399              		.loc 34 299 0
 10400 0148 BDE83840 		pop	{r3, r4, r5, lr}
 10401              	.LBB295:
 10402              	.LBB286:
 10403              	.LBB277:
 10404              	.LBB268:
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 10405              		.loc 34 109 0
 10406 014c FFF7FEBF 		b	_Z13readSerialPIDh
 10407              	.L620:
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       aref = readFloatSerial();
 10408              		.loc 34 114 0
 10409 0150 FFF7FEFF 		bl	_Z15readFloatSerialv
 10410 0154 3D4A     		ldr	r2, .L646+44
 10411 0156 1060     		str	r0, [r2, #0]	@ float
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       minArmedThrottle = readFloatSerial();
 10412              		.loc 34 115 0
 10413 0158 FFF7FEFF 		bl	_Z15readFloatSerialv
 10414 015c 04EE900A 		fmsr	s9, r0
 10415 0160 3B48     		ldr	r0, .L646+48
 10416 0162 BDEEE44A 		ftosizs	s8, s9
 10417 0166 80ED004A 		fsts	s8, [r0, #0]	@ int
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 10418              		.loc 34 116 0
 10419 016a 38BD     		pop	{r3, r4, r5, pc}
 10420              	.L621:
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 10421              		.loc 34 119 0
 10422 016c FFF7FEFF 		bl	_Z15readFloatSerialv
 10423 0170 384C     		ldr	r4, .L646+52
 10424 0172 2060     		str	r0, [r4, #0]	@ float
 10425              	.LVL481:
 10426 0174 384C     		ldr	r4, .L646+56
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void readSerialCommand() {
 10427              		.loc 34 70 0
 10428 0176 04F12005 		add	r5, r4, #32
 10429              	.LVL482:
 10430              	.L637:
 10431              	.LBB264:
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 10432              		.loc 34 121 0 discriminator 2
 10433 017a FFF7FEFF 		bl	_Z15readFloatSerialv
 10434 017e 44F8040F 		str	r0, [r4, #4]!	@ float
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 10435              		.loc 34 120 0 discriminator 2
 10436 0182 AC42     		cmp	r4, r5
 10437 0184 F9D1     		bne	.L637
 10438 0186 38BD     		pop	{r3, r4, r5, pc}
 10439              	.L622:
 10440              	.LBE264:
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 10441              		.loc 34 126 0
 10442 0188 FFF7FEFF 		bl	_Z15readFloatSerialv
 10443 018c 05EE900A 		fmsr	s11, r0
 10444 0190 324B     		ldr	r3, .L646+60
 10445 0192 BDEEE55A 		ftosizs	s10, s11
 10446 0196 83ED005A 		fsts	s10, [r3, #0]	@ int
 10447 019a 15EE104A 		fmrs	r4, s10	@ int
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 10448              		.loc 34 127 0
 10449 019e FFF7FEFF 		bl	_Z15readFloatSerialv
 10450 01a2 2F4B     		ldr	r3, .L646+64
 10451 01a4 0DE0     		b	.L644
 10452              	.L623:
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       channelCal = (int)readFloatSerial();
 10453              		.loc 34 131 0
 10454 01a6 FFF7FEFF 		bl	_Z15readFloatSerialv
 10455 01aa 06EE900A 		fmsr	s13, r0
 10456 01ae 2B49     		ldr	r1, .L646+60
 10457 01b0 BDEEE66A 		ftosizs	s12, s13
 10458 01b4 81ED006A 		fsts	s12, [r1, #0]	@ int
 10459 01b8 16EE104A 		fmrs	r4, s12	@ int
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 10460              		.loc 34 132 0
 10461 01bc FFF7FEFF 		bl	_Z15readFloatSerialv
 10462 01c0 284B     		ldr	r3, .L646+68
 10463              	.L644:
 10464 01c2 03EB8404 		add	r4, r3, r4, lsl #2
 10465 01c6 2060     		str	r0, [r4, #0]	@ float
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       break;
 10466              		.loc 34 133 0
 10467 01c8 38BD     		pop	{r3, r4, r5, pc}
 10468              	.L624:
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 10469              		.loc 34 136 0
 10470 01ca FFF7FEFF 		bl	_Z16initializeEEPROMv
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM();
 10471              		.loc 34 137 0
 10472 01ce FFF7FEFF 		bl	_Z11writeEEPROMv
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 10473              		.loc 34 138 0
 10474 01d2 FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 10475              		.loc 34 139 0
 10476 01d6 FFF7FEFF 		bl	_Z13calibrateGyrov
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 10477              		.loc 34 140 0
 10478 01da FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 10479              	.LBE268:
 10480              	.LBE277:
 10481              	.LBE286:
 10482              	.LBE295:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10483              		.loc 34 299 0
 10484 01de BDE83840 		pop	{r3, r4, r5, lr}
 10485              	.LBB296:
 10486              	.LBB287:
 10487              	.LBB278:
 10488              	.LBB269:
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         initializeBaro();
 10489              		.loc 34 145 0
 10490 01e2 FFF7FEBF 		b	_Z14initializeBarov
 10491              	.L625:
 10492              	.LBE269:
 10493              	.LBE278:
 10494              	.LBE287:
 10495              	.LBE296:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10496              		.loc 34 299 0
 10497 01e6 BDE83840 		pop	{r3, r4, r5, lr}
 10498              	.LBB297:
 10499              	.LBB288:
 10500              	.LBB279:
 10501              	.LBB270:
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       calibrateGyro();
 10502              		.loc 34 150 0
 10503 01ea FFF7FEBF 		b	_Z13calibrateGyrov
 10504              	.L626:
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 10505              		.loc 34 154 0
 10506 01ee FFF7FEFF 		bl	_Z15readFloatSerialv
 10507 01f2 1D4C     		ldr	r4, .L646+72
 10508 01f4 2060     		str	r0, [r4, #0]	@ float
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 10509              		.loc 34 155 0
 10510 01f6 FFF7FEFF 		bl	_Z15readFloatSerialv
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 10511              		.loc 34 156 0
 10512 01fa FFF7FEFF 		bl	_Z15readFloatSerialv
 10513 01fe 6060     		str	r0, [r4, #4]	@ float
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 10514              		.loc 34 157 0
 10515 0200 FFF7FEFF 		bl	_Z15readFloatSerialv
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 10516              		.loc 34 158 0
 10517 0204 FFF7FEFF 		bl	_Z15readFloatSerialv
 10518 0208 A060     		str	r0, [r4, #8]	@ float
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       readFloatSerial();
 10519              		.loc 34 159 0
 10520 020a FFF7FEFF 		bl	_Z15readFloatSerialv
 10521              	.L627:
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       computeAccelBias();
 10522              		.loc 34 165 0
 10523 020e FFF7FEFF 		bl	_Z16computeAccelBiasv
 10524              	.LBE270:
 10525              	.LBE279:
 10526              	.LBE288:
 10527              	.LBE297:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10528              		.loc 34 299 0
 10529 0212 BDE83840 		pop	{r3, r4, r5, lr}
 10530              	.LBB298:
 10531              	.LBB289:
 10532              	.LBB280:
 10533              	.LBB271:
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       storeSensorsZeroToEEPROM();
 10534              		.loc 34 170 0
 10535 0216 FFF7FEBF 		b	_Z24storeSensorsZeroToEEPROMv
 10536              	.L629:
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(3);
 10537              		.loc 34 191 0
 10538 021a 0320     		movs	r0, #3
 10539 021c 27E0     		b	.L642
 10540              	.L647:
 10541 021e 00BF     		.align	2
 10542              	.L646:
 10543 0220 00000000 		.word	Serial1
 10544 0224 00000000 		.word	.LANCHOR142
 10545 0228 00000000 		.word	.LANCHOR120
 10546 022c 00000000 		.word	.LANCHOR139
 10547 0230 00000000 		.word	.LANCHOR130
 10548 0234 00000000 		.word	.LANCHOR9
 10549 0238 00000000 		.word	.LANCHOR107
 10550 023c 00000000 		.word	.LANCHOR106
 10551 0240 00000000 		.word	.LANCHOR113
 10552 0244 00000000 		.word	.LANCHOR114
 10553 0248 00000000 		.word	.LANCHOR74
 10554 024c 00000000 		.word	.LANCHOR140
 10555 0250 00000000 		.word	.LANCHOR125
 10556 0254 00000000 		.word	.LANCHOR55
 10557 0258 FCFFFFFF 		.word	.LANCHOR6-4
 10558 025c 00000000 		.word	.LANCHOR143
 10559 0260 00000000 		.word	.LANCHOR4
 10560 0264 00000000 		.word	.LANCHOR5
 10561 0268 00000000 		.word	.LANCHOR27
 10562              	.L631:
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           skipSerialValues(13);
 10563              		.loc 34 229 0
 10564 026c 0D20     		movs	r0, #13
 10565              	.L642:
 10566              	.LBE271:
 10567              	.LBE280:
 10568              	.LBE289:
 10569              	.LBE298:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10570              		.loc 34 299 0
 10571 026e BDE83840 		pop	{r3, r4, r5, lr}
 10572              	.LBB299:
 10573              	.LBB290:
 10574              	.LBB281:
 10575              	.LBB272:
 229:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           skipSerialValues(13);
 10576              		.loc 34 229 0
 10577 0272 FFF7FEBF 		b	_Z16skipSerialValuesh
 10578              	.L632:
 239:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         skipSerialValues(2);
 10579              		.loc 34 239 0
 10580 0276 0220     		movs	r0, #2
 10581 0278 F9E7     		b	.L642
 10582              	.L633:
 245:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSROLL_PID_IDX);
 10583              		.loc 34 245 0
 10584 027a 0C20     		movs	r0, #12
 10585 027c FFF7FEFF 		bl	_Z13readSerialPIDh
 246:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSPITCH_PID_IDX);
 10586              		.loc 34 246 0
 10587 0280 0B20     		movs	r0, #11
 10588 0282 FFF7FEFF 		bl	_Z13readSerialPIDh
 247:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         readSerialPID(GPSYAW_PID_IDX);
 10589              		.loc 34 247 0
 10590 0286 0D20     		movs	r0, #13
 10591 0288 FFF7FEFF 		bl	_Z13readSerialPIDh
 10592              	.LBE272:
 10593              	.LBE281:
 10594              	.LBE290:
 10595              	.LBE299:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10596              		.loc 34 299 0
 10597 028c BDE83840 		pop	{r3, r4, r5, lr}
 10598              	.LBB300:
 10599              	.LBB291:
 10600              	.LBB282:
 10601              	.LBB273:
 248:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         writeEEPROM();
 10602              		.loc 34 248 0
 10603 0290 FFF7FEBF 		b	_Z11writeEEPROMv
 10604              	.L634:
 255:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 10605              		.loc 34 255 0
 10606 0294 FFF7FEFF 		bl	_Z11writeEEPROMv
 10607              	.LBE273:
 10608              	.LBE282:
 10609              	.LBE291:
 10610              	.LBE300:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10611              		.loc 34 299 0
 10612 0298 BDE83840 		pop	{r3, r4, r5, lr}
 10613              	.LBB301:
 10614              	.LBB292:
 10615              	.LBB283:
 10616              	.LBB274:
 256:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       zeroIntegralError();
 10617              		.loc 34 256 0
 10618 029c FFF7FEBF 		b	_Z17zeroIntegralErrorv
 10619              	.L611:
 263:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(1);
 10620              		.loc 34 263 0
 10621 02a0 0120     		movs	r0, #1
 10622 02a2 00E0     		b	.L643
 10623              	.L612:
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(2);
 10624              		.loc 34 267 0
 10625 02a4 0220     		movs	r0, #2
 10626              	.L643:
 10627              	.LBE274:
 10628              	.LBE283:
 10629              	.LBE292:
 10630              	.LBE301:
 299:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10631              		.loc 34 299 0
 10632 02a6 BDE83840 		pop	{r3, r4, r5, lr}
 10633              	.LBB302:
 10634              	.LBB293:
 10635              	.LBB284:
 10636              	.LBB275:
 267:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       validateCalibrateCommand(2);
 10637              		.loc 34 267 0
 10638 02aa FFF7FEBF 		b	_Z24validateCalibrateCommandh
 10639              	.L613:
 271:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(3)) {
 10640              		.loc 34 271 0
 10641 02ae 0320     		movs	r0, #3
 10642 02b0 FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10643 02b4 0028     		cmp	r0, #0
 10644 02b6 3AD0     		beq	.L609
 272:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = readFloatSerial();
 10645              		.loc 34 272 0
 10646 02b8 FFF7FEFF 		bl	_Z15readFloatSerialv
 10647 02bc 00EE100A 		fmsr	s0, r0
 10648 02c0 1B48     		ldr	r0, .L648
 10649 02c2 BDEEC07A 		ftosizs	s14, s0
 10650 02c6 80ED007A 		fsts	s14, [r0, #0]	@ int
 10651 02ca 38BD     		pop	{r3, r4, r5, pc}
 10652              	.L614:
 277:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(4)) {
 10653              		.loc 34 277 0
 10654 02cc 0420     		movs	r0, #4
 10655 02ce FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10656 02d2 0028     		cmp	r0, #0
 10657 02d4 2BD0     		beq	.L609
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 10658              		.loc 34 278 0
 10659 02d6 1748     		ldr	r0, .L648+4
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 10660              		.loc 34 279 0
 10661 02d8 154B     		ldr	r3, .L648
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 10662              		.loc 34 278 0
 10663 02da 0021     		movs	r1, #0
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 10664              		.loc 34 279 0
 10665 02dc 4FF47A72 		mov	r2, #1000
 278:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         calibrateESC = 0;
 10666              		.loc 34 278 0
 10667 02e0 0170     		strb	r1, [r0, #0]
 279:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         testCommand = 1000;
 10668              		.loc 34 279 0
 10669 02e2 1A60     		str	r2, [r3, #0]
 10670 02e4 38BD     		pop	{r3, r4, r5, pc}
 10671              	.L615:
 10672              	.LBB265:
 284:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (validateCalibrateCommand(5)) {
 10673              		.loc 34 284 0
 10674 02e6 0520     		movs	r0, #5
 10675 02e8 FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 10676 02ec F8B1     		cbz	r0, .L609
 10677 02ee 0024     		movs	r4, #0
 10678              	.L638:
 10679              	.LBB266:
 286:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 10680              		.loc 34 286 0 discriminator 2
 10681 02f0 FFF7FEFF 		bl	_Z15readFloatSerialv
 10682 02f4 01EE100A 		fmsr	s2, r0
 10683 02f8 FDEEC10A 		ftosizs	s1, s2
 10684 02fc 0E4B     		ldr	r3, .L648+8
 10685 02fe 10EE902A 		fmrs	r2, s1	@ int
 10686 0302 E250     		str	r2, [r4, r3]
 10687 0304 0434     		adds	r4, r4, #4
 285:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++) {
 10688              		.loc 34 285 0 discriminator 2
 10689 0306 102C     		cmp	r4, #16
 10690 0308 F2D1     		bne	.L638
 10691 030a 38BD     		pop	{r3, r4, r5, pc}
 10692              	.LVL483:
 10693              	.L635:
 10694              	.LBE266:
 10695              	.LBE265:
 292:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       if (readFloatSerial() == 1.0)
 10696              		.loc 34 292 0
 10697 030c FFF7FEFF 		bl	_Z15readFloatSerialv
 10698 0310 01EE900A 		fmsr	s3, r0
 10699 0314 F7EE007A 		fconsts	s15, #112
 10700 0318 F4EE671A 		fcmps	s3, s15
 10701 031c F1EE10FA 		fmstat
 10702 0320 064B     		ldr	r3, .L648+12
 10703 0322 02D1     		bne	.L639
 293:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = ON;
 10704              		.loc 34 293 0
 10705 0324 0121     		movs	r1, #1
 10706 0326 1970     		strb	r1, [r3, #0]
 10707 0328 38BD     		pop	{r3, r4, r5, pc}
 10708              	.L639:
 295:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         fastTransfer = OFF;
 10709              		.loc 34 295 0
 10710 032a 0020     		movs	r0, #0
 10711 032c 1870     		strb	r0, [r3, #0]
 10712              	.L609:
 10713 032e 38BD     		pop	{r3, r4, r5, pc}
 10714              	.L649:
 10715              		.align	2
 10716              	.L648:
 10717 0330 00000000 		.word	.LANCHOR122
 10718 0334 00000000 		.word	.LANCHOR121
 10719 0338 00000000 		.word	.LANCHOR123
 10720 033c 00000000 		.word	.LANCHOR144
 10721              	.LBE275:
 10722              	.LBE284:
 10723              	.LBE293:
 10724              	.LBE302:
 10725              		.cfi_endproc
 10726              	.LFE256:
 10728              		.section	.text._Z17readIntegerSerialv,"ax",%progbits
 10729              		.align	1
 10730              		.global	_Z17readIntegerSerialv
 10731              		.thumb
 10732              		.thumb_func
 10734              	_Z17readIntegerSerialv:
 10735              	.LFB270:
 795:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 796:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** // Used to read integer values from the serial port
 797:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** long readIntegerSerial() {
 10736              		.loc 34 797 0
 10737              		.cfi_startproc
 10738              		@ args = 0, pretend = 0, frame = 16
 10739              		@ frame_needed = 0, uses_anonymous_args = 0
 10740 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 10741              	.LCFI98:
 10742              		.cfi_def_cfa_offset 24
 10743              		.cfi_offset 14, -4
 10744              		.cfi_offset 4, -8
 10745              		.cfi_offset 3, -12
 10746              		.cfi_offset 2, -16
 10747              		.cfi_offset 1, -20
 10748              		.cfi_offset 0, -24
 10749              	.LBB303:
 798:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   char data[16] = "";
 10750              		.loc 34 798 0
 10751 0002 0021     		movs	r1, #0
 10752 0004 0C22     		movs	r2, #12
 10753 0006 01A8     		add	r0, sp, #4
 10754 0008 0091     		str	r1, [sp, #0]
 10755 000a FFF7FEFF 		bl	memset
 799:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 800:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   readValueSerial(data, sizeof(data));
 10756              		.loc 34 800 0
 10757 000e 6846     		mov	r0, sp
 10758 0010 1021     		movs	r1, #16
 10759 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 801:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   return atol(data);
 10760              		.loc 34 801 0
 10761 0016 6846     		mov	r0, sp
 10762 0018 FFF7FEFF 		bl	atol
 10763              	.LBE303:
 802:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10764              		.loc 34 802 0
 10765 001c 05B0     		add	sp, sp, #20
 10766 001e 00BD     		pop	{pc}
 10767              		.cfi_endproc
 10768              	.LFE270:
 10770              		.section	.text._Z5commav,"ax",%progbits
 10771              		.align	1
 10772              		.global	_Z5commav
 10773              		.thumb
 10774              		.thumb_func
 10776              	_Z5commav:
 10777              	.LFB271:
 803:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 804:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void comma() {
 10778              		.loc 34 804 0
 10779              		.cfi_startproc
 10780              		@ args = 0, pretend = 0, frame = 0
 10781              		@ frame_needed = 0, uses_anonymous_args = 0
 10782              		@ link register save eliminated.
 805:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(',');
 10783              		.loc 34 805 0
 10784 0000 0148     		ldr	r0, .L652
 10785 0002 2C21     		movs	r1, #44
 806:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10786              		.loc 34 806 0
 805:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(',');
 10787              		.loc 34 805 0
 10788 0004 FFF7FEBF 		b	_ZN5Print5printEc
 10789              	.L653:
 10790              		.align	2
 10791              	.L652:
 10792 0008 00000000 		.word	Serial1
 10793              		.cfi_endproc
 10794              	.LFE271:
 10796              		.section	.text._Z15PrintValueCommal,"ax",%progbits
 10797              		.align	1
 10798              		.global	_Z15PrintValueCommal
 10799              		.thumb
 10800              		.thumb_func
 10802              	_Z15PrintValueCommal:
 10803              	.LFB263:
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10804              		.loc 34 338 0
 10805              		.cfi_startproc
 10806              		@ args = 0, pretend = 0, frame = 0
 10807              		@ frame_needed = 0, uses_anonymous_args = 0
 10808              	.LVL484:
 10809 0000 08B5     		push	{r3, lr}
 10810              	.LCFI99:
 10811              		.cfi_def_cfa_offset 8
 10812              		.cfi_offset 14, -4
 10813              		.cfi_offset 3, -8
 338:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10814              		.loc 34 338 0
 10815 0002 0146     		mov	r1, r0
 339:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 10816              		.loc 34 339 0
 10817 0004 0A22     		movs	r2, #10
 10818 0006 0348     		ldr	r0, .L655
 10819              	.LVL485:
 10820 0008 FFF7FEFF 		bl	_ZN5Print5printEli
 10821              	.LVL486:
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10822              		.loc 34 341 0
 10823 000c BDE80840 		pop	{r3, lr}
 340:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 10824              		.loc 34 340 0
 10825 0010 FFF7FEBF 		b	_Z5commav
 10826              	.L656:
 10827              		.align	2
 10828              	.L655:
 10829 0014 00000000 		.word	Serial1
 10830              		.cfi_endproc
 10831              	.LFE263:
 10833              		.section	.text._Z15PrintValueCommah,"ax",%progbits
 10834              		.align	1
 10835              		.global	_Z15PrintValueCommah
 10836              		.thumb
 10837              		.thumb_func
 10839              	_Z15PrintValueCommah:
 10840              	.LFB262:
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10841              		.loc 34 332 0
 10842              		.cfi_startproc
 10843              		@ args = 0, pretend = 0, frame = 0
 10844              		@ frame_needed = 0, uses_anonymous_args = 0
 10845              	.LVL487:
 10846 0000 08B5     		push	{r3, lr}
 10847              	.LCFI100:
 10848              		.cfi_def_cfa_offset 8
 10849              		.cfi_offset 14, -4
 10850              		.cfi_offset 3, -8
 332:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10851              		.loc 34 332 0
 10852 0002 0146     		mov	r1, r0
 333:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 10853              		.loc 34 333 0
 10854 0004 0A22     		movs	r2, #10
 10855 0006 0348     		ldr	r0, .L658
 10856              	.LVL488:
 10857 0008 FFF7FEFF 		bl	_ZN5Print5printEhi
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10858              		.loc 34 335 0
 10859 000c BDE80840 		pop	{r3, lr}
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 10860              		.loc 34 334 0
 10861 0010 FFF7FEBF 		b	_Z5commav
 10862              	.L659:
 10863              		.align	2
 10864              	.L658:
 10865 0014 00000000 		.word	Serial1
 10866              		.cfi_endproc
 10867              	.LFE262:
 10869              		.section	.text._Z15PrintValueCommam,"ax",%progbits
 10870              		.align	1
 10871              		.global	_Z15PrintValueCommam
 10872              		.thumb
 10873              		.thumb_func
 10875              	_Z15PrintValueCommam:
 10876              	.LFB261:
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10877              		.loc 34 326 0
 10878              		.cfi_startproc
 10879              		@ args = 0, pretend = 0, frame = 0
 10880              		@ frame_needed = 0, uses_anonymous_args = 0
 10881              	.LVL489:
 10882 0000 08B5     		push	{r3, lr}
 10883              	.LCFI101:
 10884              		.cfi_def_cfa_offset 8
 10885              		.cfi_offset 14, -4
 10886              		.cfi_offset 3, -8
 326:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 10887              		.loc 34 326 0
 10888 0002 0146     		mov	r1, r0
 327:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 10889              		.loc 34 327 0
 10890 0004 0A22     		movs	r2, #10
 10891 0006 0348     		ldr	r0, .L661
 10892              	.LVL490:
 10893 0008 FFF7FEFF 		bl	_ZN5Print5printEmi
 10894              	.LVL491:
 329:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10895              		.loc 34 329 0
 10896 000c BDE80840 		pop	{r3, lr}
 328:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 10897              		.loc 34 328 0
 10898 0010 FFF7FEBF 		b	_Z5commav
 10899              	.L662:
 10900              		.align	2
 10901              	.L661:
 10902 0014 00000000 		.word	Serial1
 10903              		.cfi_endproc
 10904              	.LFE261:
 10906              		.section	.text._Z15PrintValueCommai,"ax",%progbits
 10907              		.align	1
 10908              		.global	_Z15PrintValueCommai
 10909              		.thumb
 10910              		.thumb_func
 10912              	_Z15PrintValueCommai:
 10913              	.LFB260:
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(int val) {
 10914              		.loc 34 320 0
 10915              		.cfi_startproc
 10916              		@ args = 0, pretend = 0, frame = 0
 10917              		@ frame_needed = 0, uses_anonymous_args = 0
 10918              	.LVL492:
 10919 0000 08B5     		push	{r3, lr}
 10920              	.LCFI102:
 10921              		.cfi_def_cfa_offset 8
 10922              		.cfi_offset 14, -4
 10923              		.cfi_offset 3, -8
 320:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(int val) {
 10924              		.loc 34 320 0
 10925 0002 0146     		mov	r1, r0
 321:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 10926              		.loc 34 321 0
 10927 0004 0A22     		movs	r2, #10
 10928 0006 0348     		ldr	r0, .L664
 10929              	.LVL493:
 10930 0008 FFF7FEFF 		bl	_ZN5Print5printEii
 10931              	.LVL494:
 323:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10932              		.loc 34 323 0
 10933 000c BDE80840 		pop	{r3, lr}
 322:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 10934              		.loc 34 322 0
 10935 0010 FFF7FEBF 		b	_Z5commav
 10936              	.L665:
 10937              		.align	2
 10938              	.L664:
 10939 0014 00000000 		.word	Serial1
 10940              		.cfi_endproc
 10941              	.LFE260:
 10943              		.section	.text._Z16PrintDummyValuesh,"ax",%progbits
 10944              		.align	1
 10945              		.global	_Z16PrintDummyValuesh
 10946              		.thumb
 10947              		.thumb_func
 10949              	_Z16PrintDummyValuesh:
 10950              	.LFB265:
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintDummyValues(byte number) {
 10951              		.loc 34 350 0
 10952              		.cfi_startproc
 10953              		@ args = 0, pretend = 0, frame = 0
 10954              		@ frame_needed = 0, uses_anonymous_args = 0
 10955              	.LVL495:
 10956 0000 38B5     		push	{r3, r4, r5, lr}
 10957              	.LCFI103:
 10958              		.cfi_def_cfa_offset 16
 10959              		.cfi_offset 14, -4
 10960              		.cfi_offset 5, -8
 10961              		.cfi_offset 4, -12
 10962              		.cfi_offset 3, -16
 350:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintDummyValues(byte number) {
 10963              		.loc 34 350 0
 10964 0002 0546     		mov	r5, r0
 10965              	.LBB304:
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 10966              		.loc 34 351 0
 10967 0004 0024     		movs	r4, #0
 10968 0006 04E0     		b	.L667
 10969              	.LVL496:
 10970              	.L668:
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(0);
 10971              		.loc 34 352 0 discriminator 2
 10972 0008 0020     		movs	r0, #0
 10973 000a FFF7FEFF 		bl	_Z15PrintValueCommai
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 10974              		.loc 34 351 0 discriminator 2
 10975 000e 0134     		adds	r4, r4, #1
 10976              	.LVL497:
 10977 0010 E4B2     		uxtb	r4, r4
 10978              	.LVL498:
 10979              	.L667:
 351:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   for(byte i=0; i<number; i++) {
 10980              		.loc 34 351 0 is_stmt 0 discriminator 1
 10981 0012 AC42     		cmp	r4, r5
 10982 0014 F8D1     		bne	.L668
 10983              	.LBE304:
 354:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 10984              		.loc 34 354 0 is_stmt 1
 10985 0016 38BD     		pop	{r3, r4, r5, pc}
 10986              		.cfi_endproc
 10987              	.LFE265:
 10989              		.section	.text._Z15PrintValueCommac,"ax",%progbits
 10990              		.align	1
 10991              		.global	_Z15PrintValueCommac
 10992              		.thumb
 10993              		.thumb_func
 10995              	_Z15PrintValueCommac:
 10996              	.LFB259:
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(char val) {
 10997              		.loc 34 315 0
 10998              		.cfi_startproc
 10999              		@ args = 0, pretend = 0, frame = 0
 11000              		@ frame_needed = 0, uses_anonymous_args = 0
 11001              	.LVL499:
 11002 0000 08B5     		push	{r3, lr}
 11003              	.LCFI104:
 11004              		.cfi_def_cfa_offset 8
 11005              		.cfi_offset 14, -4
 11006              		.cfi_offset 3, -8
 315:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(char val) {
 11007              		.loc 34 315 0
 11008 0002 0146     		mov	r1, r0
 316:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 11009              		.loc 34 316 0
 11010 0004 0348     		ldr	r0, .L670
 11011              	.LVL500:
 11012 0006 FFF7FEFF 		bl	_ZN5Print5printEc
 318:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11013              		.loc 34 318 0
 11014 000a BDE80840 		pop	{r3, lr}
 317:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 11015              		.loc 34 317 0
 11016 000e FFF7FEBF 		b	_Z5commav
 11017              	.L671:
 11018 0012 00BF     		.align	2
 11019              	.L670:
 11020 0014 00000000 		.word	Serial1
 11021              		.cfi_endproc
 11022              	.LFE259:
 11024              		.section	.text._Z15PrintValueCommad,"ax",%progbits
 11025              		.align	1
 11026              		.global	_Z15PrintValueCommad
 11027              		.thumb
 11028              		.thumb_func
 11030              	_Z15PrintValueCommad:
 11031              	.LFB258:
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(double val) {
 11032              		.loc 34 310 0
 11033              		.cfi_startproc
 11034              		@ args = 0, pretend = 0, frame = 0
 11035              		@ frame_needed = 0, uses_anonymous_args = 0
 11036              	.LVL501:
 11037 0000 07B5     		push	{r0, r1, r2, lr}
 11038              	.LCFI105:
 11039              		.cfi_def_cfa_offset 16
 11040              		.cfi_offset 14, -4
 11041              		.cfi_offset 2, -8
 11042              		.cfi_offset 1, -12
 11043              		.cfi_offset 0, -16
 310:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(double val) {
 11044              		.loc 34 310 0
 11045 0002 0B46     		mov	r3, r1
 11046 0004 0246     		mov	r2, r0
 311:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 11047              		.loc 34 311 0
 11048 0006 0221     		movs	r1, #2
 11049 0008 0448     		ldr	r0, .L673
 11050              	.LVL502:
 11051 000a 0091     		str	r1, [sp, #0]
 11052 000c FFF7FEFF 		bl	_ZN5Print5printEdi
 313:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11053              		.loc 34 313 0
 11054 0010 03B0     		add	sp, sp, #12
 11055 0012 5DF804EB 		pop	{lr}
 312:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 11056              		.loc 34 312 0
 11057 0016 FFF7FEBF 		b	_Z5commav
 11058              	.L674:
 11059 001a 00BF     		.align	2
 11060              	.L673:
 11061 001c 00000000 		.word	Serial1
 11062              		.cfi_endproc
 11063              	.LFE258:
 11065              		.section	.text._Z15PrintValueCommaf,"ax",%progbits
 11066              		.align	1
 11067              		.global	_Z15PrintValueCommaf
 11068              		.thumb
 11069              		.thumb_func
 11071              	_Z15PrintValueCommaf:
 11072              	.LFB257:
 305:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void PrintValueComma(float val) {
 11073              		.loc 34 305 0
 11074              		.cfi_startproc
 11075              		@ args = 0, pretend = 0, frame = 0
 11076              		@ frame_needed = 0, uses_anonymous_args = 0
 11077              	.LVL503:
 11078 0000 07B5     		push	{r0, r1, r2, lr}
 11079              	.LCFI106:
 11080              		.cfi_def_cfa_offset 16
 11081              		.cfi_offset 14, -4
 11082              		.cfi_offset 2, -8
 11083              		.cfi_offset 1, -12
 11084              		.cfi_offset 0, -16
 306:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(val);
 11085              		.loc 34 306 0
 11086 0002 FFF7FEFF 		bl	__aeabi_f2d
 11087              	.LVL504:
 11088 0006 0246     		mov	r2, r0
 11089 0008 0B46     		mov	r3, r1
 11090 000a 0548     		ldr	r0, .L676
 11091 000c 0221     		movs	r1, #2
 11092 000e 0091     		str	r1, [sp, #0]
 11093 0010 FFF7FEFF 		bl	_ZN5Print5printEdi
 308:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11094              		.loc 34 308 0
 11095 0014 03B0     		add	sp, sp, #12
 11096 0016 5DF804EB 		pop	{lr}
 307:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   comma();
 11097              		.loc 34 307 0
 11098 001a FFF7FEBF 		b	_Z5commav
 11099              	.L677:
 11100 001e 00BF     		.align	2
 11101              	.L676:
 11102 0020 00000000 		.word	Serial1
 11103              		.cfi_endproc
 11104              	.LFE257:
 11106              		.section	.text._Z8PrintPIDh,"ax",%progbits
 11107              		.align	1
 11108              		.global	_Z8PrintPIDh
 11109              		.thumb
 11110              		.thumb_func
 11112              	_Z8PrintPIDh:
 11113              	.LFB264:
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 11114              		.loc 34 344 0
 11115              		.cfi_startproc
 11116              		@ args = 0, pretend = 0, frame = 0
 11117              		@ frame_needed = 0, uses_anonymous_args = 0
 11118              	.LVL505:
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 11119              		.loc 34 345 0
 11120 0000 074B     		ldr	r3, .L679
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 11121              		.loc 34 344 0
 11122 0002 10B5     		push	{r4, lr}
 11123              	.LCFI107:
 11124              		.cfi_def_cfa_offset 8
 11125              		.cfi_offset 14, -4
 11126              		.cfi_offset 4, -8
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 11127              		.loc 34 345 0
 11128 0004 1C24     		movs	r4, #28
 11129 0006 04FB0034 		mla	r4, r4, r0, r3
 11130 000a 2068     		ldr	r0, [r4, #0]	@ float
 11131              	.LVL506:
 11132 000c FFF7FEFF 		bl	_Z15PrintValueCommaf
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 11133              		.loc 34 346 0
 11134 0010 6068     		ldr	r0, [r4, #4]	@ float
 11135 0012 FFF7FEFF 		bl	_Z15PrintValueCommaf
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 11136              		.loc 34 347 0
 11137 0016 A068     		ldr	r0, [r4, #8]	@ float
 348:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11138              		.loc 34 348 0
 11139 0018 BDE81040 		pop	{r4, lr}
 347:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 11140              		.loc 34 347 0
 11141 001c FFF7FEBF 		b	_Z15PrintValueCommaf
 11142              	.L680:
 11143              		.align	2
 11144              	.L679:
 11145 0020 00000000 		.word	.LANCHOR9
 11146              		.cfi_endproc
 11147              	.LFE264:
 11149              		.section	.text._Z17printVehicleStatePKcmS0_,"ax",%progbits
 11150              		.align	1
 11151              		.global	_Z17printVehicleStatePKcmS0_
 11152              		.thumb
 11153              		.thumb_func
 11155              	_Z17printVehicleStatePKcmS0_:
 11156              	.LFB272:
 807:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 808:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 809:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #ifdef BinaryWrite
 810:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printInt(int data) {
 811:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   byte msb, lsb;
 812:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 813:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   msb = data >> 8;
 814:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   lsb = data & 0xff;
 815:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 816:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(msb);
 817:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(lsb);
 818:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 819:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 820:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendBinaryFloat(float data) {
 821:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   union binaryFloatType {
 822:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     byte floatByte[4];
 823:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     float floatVal;
 824:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   } binaryFloat;
 825:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 826:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryFloat.floatVal = data;
 827:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[3]);
 828:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[2]);
 829:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[1]);
 830:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[0]);
 831:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 832:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 833:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendBinaryuslong(unsigned long data) {
 834:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   union binaryuslongType {
 835:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     byte uslongByte[4];
 836:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     unsigned long uslongVal;
 837:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   } binaryuslong;
 838:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 839:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryuslong.uslongVal = data;
 840:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[3]);
 841:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[2]);
 842:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[1]);
 843:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[0]);
 844:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 845:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 846:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 847:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void fastTelemetry()
 848:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** {
 849:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // **************************************************************
 850:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // ***************** Fast Transfer Of Sensor Data ***************
 851:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // **************************************************************
 852:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // AeroQuad.h defines the output rate to be 10ms
 853:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Since writing to UART is done by hardware, unable to measure data rate directly
 854:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Through analysis:  115200 baud = 115200 bits/second = 14400 bytes/second
 855:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // If float = 4 bytes, then 3600 floats/second
 856:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // If 10 ms output rate, then 36 floats/10ms
 857:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Number of floats written using sendBinaryFloat is 15
 858:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 859:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (motorArmed == ON) {
 860:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #ifdef OpenlogBinaryWrite
 861:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        printInt(21845); // Start word of 0x5555
 862:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        sendBinaryuslong(currentTime);
 863:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         printInt((int)flightMode);
 864:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 865:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 866:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 867:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 868:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 869:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 870:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        sendBinaryFloat(accelOneG);
 871:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #ifdef HeadingMagHold
 872:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           sendBinaryFloat(hdgX);
 873:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           sendBinaryFloat(hdgY);
 874:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 		  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 875:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 		       #if defined(HeadingMagHold)
 876:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 			      sendBinaryFloat(getMagnetometerData(axis));
 877:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 		       #endif
 878:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           }
 879:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #else
 880:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0.0);
 881:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0.0);
 882:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0.0);
 883:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #endif
 884:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 885:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****           sendBinaryFloat(kinematicsAngle[axis]);
 886:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         }
 887:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         printInt(32767); // Stop word of 0x7FFF
 888:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #else
 889:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        printInt(21845); // Start word of 0x5555
 890:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 891:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 892:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 893:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 894:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 895:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 896:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++)
 897:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #if defined(HeadingMagHold)
 898:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(getMagnetometerData(axis));
 899:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #else
 900:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(0);
 901:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        #endif
 902:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 903:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(getGyroUnbias(axis));
 904:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 905:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 906:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****          sendBinaryFloat(kinematicsAngle[axis]);
 907:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        }
 908:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****        printInt(32767); // Stop word of 0x7FFF
 909:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     #endif
 910:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 911:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 912:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #endif // BinaryWrite
 913:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 914:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 11157              		.loc 34 914 0
 11158              		.cfi_startproc
 11159              		@ args = 0, pretend = 0, frame = 0
 11160              		@ frame_needed = 0, uses_anonymous_args = 0
 11161              	.LVL507:
 11162 0000 8446     		mov	ip, r0
 11163 0002 38B5     		push	{r3, r4, r5, lr}
 11164              	.LCFI108:
 11165              		.cfi_def_cfa_offset 16
 11166              		.cfi_offset 14, -4
 11167              		.cfi_offset 5, -8
 11168              		.cfi_offset 4, -12
 11169              		.cfi_offset 3, -16
 915:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   
 916:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(sensorName);
 11170              		.loc 34 916 0
 11171 0004 0B48     		ldr	r0, .L683
 11172              	.LVL508:
 914:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 11173              		.loc 34 914 0
 11174 0006 0C46     		mov	r4, r1
 11175              		.loc 34 916 0
 11176 0008 6146     		mov	r1, ip
 11177              	.LVL509:
 914:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 11178              		.loc 34 914 0
 11179 000a 1546     		mov	r5, r2
 11180              		.loc 34 916 0
 11181 000c FFF7FEFF 		bl	_ZN5Print5printEPKc
 11182              	.LVL510:
 917:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT(": ");
 11183              		.loc 34 917 0
 11184 0010 0848     		ldr	r0, .L683
 11185 0012 0949     		ldr	r1, .L683+4
 11186 0014 FFF7FEFF 		bl	_ZN5Print5printEPKc
 918:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (!(vehicleState & state)) {
 11187              		.loc 34 918 0
 11188 0018 0848     		ldr	r0, .L683+8
 11189 001a 0368     		ldr	r3, [r0, #0]
 11190 001c 1C42     		tst	r4, r3
 11191 001e 03D1     		bne	.L682
 919:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT("Not ");
 11192              		.loc 34 919 0
 11193 0020 0448     		ldr	r0, .L683
 11194 0022 0749     		ldr	r1, .L683+12
 11195 0024 FFF7FEFF 		bl	_ZN5Print5printEPKc
 11196              	.L682:
 920:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
 921:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(message);
 11197              		.loc 34 921 0
 11198 0028 0248     		ldr	r0, .L683
 11199 002a 2946     		mov	r1, r5
 922:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11200              		.loc 34 922 0
 11201 002c BDE83840 		pop	{r3, r4, r5, lr}
 921:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(message);
 11202              		.loc 34 921 0
 11203 0030 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 11204              	.L684:
 11205              		.align	2
 11206              	.L683:
 11207 0034 00000000 		.word	Serial1
 11208 0038 15000000 		.word	.LC2
 11209 003c 00000000 		.word	.LANCHOR13
 11210 0040 18000000 		.word	.LC3
 11211              		.cfi_endproc
 11212              	.LFE272:
 11214              		.section	.text._Z18reportVehicleStatev,"ax",%progbits
 11215              		.align	1
 11216              		.global	_Z18reportVehicleStatev
 11217              		.thumb
 11218              		.thumb_func
 11220              	_Z18reportVehicleStatev:
 11221              	.LFB273:
 923:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 924:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void reportVehicleState() {
 11222              		.loc 34 924 0
 11223              		.cfi_startproc
 11224              		@ args = 0, pretend = 0, frame = 0
 11225              		@ frame_needed = 0, uses_anonymous_args = 0
 11226 0000 13B5     		push	{r0, r1, r4, lr}
 11227              	.LCFI109:
 11228              		.cfi_def_cfa_offset 16
 11229              		.cfi_offset 14, -4
 11230              		.cfi_offset 4, -8
 11231              		.cfi_offset 1, -12
 11232              		.cfi_offset 0, -16
 925:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   // Tell Configurator how many vehicle state values to expect
 926:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(15);
 11233              		.loc 34 926 0
 11234 0002 0A22     		movs	r2, #10
 11235 0004 0F21     		movs	r1, #15
 11236 0006 3648     		ldr	r0, .L686+8
 11237 0008 FFF7FEFF 		bl	_ZN5Print7printlnEii
 927:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Software Version: ");
 11238              		.loc 34 927 0
 11239 000c 3549     		ldr	r1, .L686+12
 11240 000e 3448     		ldr	r0, .L686+8
 11241 0010 FFF7FEFF 		bl	_ZN5Print5printEPKc
 928:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 11242              		.loc 34 928 0
 11243 0014 0124     		movs	r4, #1
 11244 0016 30A3     		adr	r3, .L686
 11245 0018 D3E90023 		ldrd	r2, [r3]
 11246 001c 3048     		ldr	r0, .L686+8
 11247 001e 0094     		str	r4, [sp, #0]
 11248 0020 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 929:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Board Type: ");
 11249              		.loc 34 929 0
 11250 0024 2E48     		ldr	r0, .L686+8
 11251 0026 3049     		ldr	r1, .L686+16
 11252 0028 FFF7FEFF 		bl	_ZN5Print5printEPKc
 930:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #if defined(AeroQuad_v1)
 931:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("v1.x");
 932:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_v1_IDG)
 933:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("v1.x IDG");
 934:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v1)
 935:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega v1.x");
 936:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_v18)
 937:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("v1.8 and greater");
 938:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v2)
 939:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega v2");
 940:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 941:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega v21");
 942:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 943:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("AutoNav");
 944:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AutonavShield)
 945:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("AutonavShield");
 946:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_Wii)
 947:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Wii");
 948:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_Wii)
 949:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mega Wii");
 950:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(ArduCopter)
 951:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("ArduCopter");
 952:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadMega_CHR6DM)
 953:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("CHR6DM");
 954:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(APM_OP_CHR6DM)
 955:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("APM w/ CHR6DM");
 956:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuad_Mini)
 957:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Mini");
 958:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(AeroQuadSTM32)
 959:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(STM32_BOARD_TYPE);
 11253              		.loc 34 959 0
 11254 002c 2C48     		ldr	r0, .L686+8
 11255 002e 2F49     		ldr	r1, .L686+20
 11256 0030 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 960:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #endif
 961:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 962:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Flight Config: ");
 11257              		.loc 34 962 0
 11258 0034 2A48     		ldr	r0, .L686+8
 11259 0036 2E49     		ldr	r1, .L686+24
 11260 0038 FFF7FEFF 		bl	_ZN5Print5printEPKc
 963:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #if defined(quadPlusConfig)
 964:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Quad +");
 11261              		.loc 34 964 0
 11262 003c 2848     		ldr	r0, .L686+8
 11263 003e 2D49     		ldr	r1, .L686+28
 11264 0040 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 965:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(quadXConfig)
 966:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Quad X");
 967:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined (quadY4Config)
 968:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Quad Y4");
 969:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined (triConfig)
 970:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Tri");
 971:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(hexPlusConfig)
 972:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Hex +");
 973:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(hexXConfig)
 974:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Hex X");
 975:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(hexY6Config)
 976:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Hex Y6");
 977:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(octoX8Config)
 978:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Octo X8");
 979:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(octoXConfig)
 980:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Octo X");
 981:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #elif defined(octoPlusConfig)
 982:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN("Octo +");
 983:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   #endif
 984:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 985:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Receiver Channels: ");
 11265              		.loc 34 985 0
 11266 0044 2648     		ldr	r0, .L686+8
 11267 0046 2C49     		ldr	r1, .L686+32
 11268 0048 FFF7FEFF 		bl	_ZN5Print5printEPKc
 986:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(LASTCHANNEL);
 11269              		.loc 34 986 0
 11270 004c 0A22     		movs	r2, #10
 11271 004e 0821     		movs	r1, #8
 11272 0050 2348     		ldr	r0, .L686+8
 11273 0052 FFF7FEFF 		bl	_ZN5Print7printlnEii
 987:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 988:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("Motors: ");
 11274              		.loc 34 988 0
 11275 0056 2248     		ldr	r0, .L686+8
 11276 0058 2849     		ldr	r1, .L686+36
 11277 005a FFF7FEFF 		bl	_ZN5Print5printEPKc
 989:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(LASTMOTOR);
 11278              		.loc 34 989 0
 11279 005e 0421     		movs	r1, #4
 11280 0060 0A22     		movs	r2, #10
 11281 0062 1F48     		ldr	r0, .L686+8
 11282 0064 FFF7FEFF 		bl	_ZN5Print7printlnEii
 990:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 
 991:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Gyroscope", GYRO_DETECTED, "Detected");
 11283              		.loc 34 991 0
 11284 0068 2146     		mov	r1, r4
 11285 006a 2548     		ldr	r0, .L686+40
 11286 006c 254A     		ldr	r2, .L686+44
 11287 006e FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 992:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Accelerometer", ACCEL_DETECTED, "Detected");
 11288              		.loc 34 992 0
 11289 0072 0221     		movs	r1, #2
 11290 0074 2448     		ldr	r0, .L686+48
 11291 0076 234A     		ldr	r2, .L686+44
 11292 0078 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 993:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Barometer", BARO_DETECTED, "Detected");
 11293              		.loc 34 993 0
 11294 007c 0821     		movs	r1, #8
 11295 007e 2348     		ldr	r0, .L686+52
 11296 0080 204A     		ldr	r2, .L686+44
 11297 0082 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 994:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Magnetometer", MAG_DETECTED, "Detected");
 11298              		.loc 34 994 0
 11299 0086 0421     		movs	r1, #4
 11300 0088 2148     		ldr	r0, .L686+56
 11301 008a 1E4A     		ldr	r2, .L686+44
 11302 008c FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 995:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Heading Hold", HEADINGHOLD_ENABLED, "Enabled");
 11303              		.loc 34 995 0
 11304 0090 1021     		movs	r1, #16
 11305 0092 2048     		ldr	r0, .L686+60
 11306 0094 204A     		ldr	r2, .L686+64
 11307 0096 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 996:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Altitude Hold", ALTITUDEHOLD_ENABLED, "Enabled");
 11308              		.loc 34 996 0
 11309 009a 2021     		movs	r1, #32
 11310 009c 1F48     		ldr	r0, .L686+68
 11311 009e 1E4A     		ldr	r2, .L686+64
 11312 00a0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 997:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Battery Monitor", BATTMONITOR_ENABLED, "Enabled");
 11313              		.loc 34 997 0
 11314 00a4 4021     		movs	r1, #64
 11315 00a6 1E48     		ldr	r0, .L686+72
 11316 00a8 1B4A     		ldr	r2, .L686+64
 11317 00aa FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 998:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Camera Stability", CAMERASTABLE_ENABLED, "Enabled");
 11318              		.loc 34 998 0
 11319 00ae 8021     		movs	r1, #128
 11320 00b0 1C48     		ldr	r0, .L686+76
 11321 00b2 194A     		ldr	r2, .L686+64
 11322 00b4 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 999:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 11323              		.loc 34 999 0
 11324 00b8 1B48     		ldr	r0, .L686+80
 11325 00ba 174A     		ldr	r2, .L686+64
 11326 00bc 4FF48071 		mov	r1, #256
 11327 00c0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
1000:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #ifdef UseGPS
1001:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("GPS: ");
1002:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT((gpsData.state==GPS_DETECTING)?"Scanning ":"Detected ");
1003:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   if (gpsData.state != GPS_DETECTING) {
1004:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(gpsTypes[gpsData.type].name);
1005:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   }
1006:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINT("@");
1007:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN(gpsBaudRates[gpsData.baudrate]);
1008:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #else
1009:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN("GPS: Not Enabled");
 11328              		.loc 34 1009 0
 11329 00c4 0648     		ldr	r0, .L686+8
 11330 00c6 1949     		ldr	r1, .L686+84
1010:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** #endif
1011:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11331              		.loc 34 1011 0
 11332 00c8 02B0     		add	sp, sp, #8
 11333 00ca BDE81040 		pop	{r4, lr}
1009:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   SERIAL_PRINTLN("GPS: Not Enabled");
 11334              		.loc 34 1009 0
 11335 00ce FFF7FEBF 		b	_ZN5Print7printlnEPKc
 11336              	.L687:
 11337 00d2 00BFAFF3 		.align	3
 11337      0080
 11338              	.L686:
 11339 00d8 000000A0 		.word	-1610612736
 11340 00dc 99990940 		.word	1074370969
 11341 00e0 00000000 		.word	Serial1
 11342 00e4 1D000000 		.word	.LC4
 11343 00e8 30000000 		.word	.LC5
 11344 00ec 3D000000 		.word	.LC6
 11345 00f0 48000000 		.word	.LC7
 11346 00f4 58000000 		.word	.LC8
 11347 00f8 5F000000 		.word	.LC9
 11348 00fc 73000000 		.word	.LC10
 11349 0100 7C000000 		.word	.LC11
 11350 0104 86000000 		.word	.LC12
 11351 0108 8F000000 		.word	.LC13
 11352 010c 9D000000 		.word	.LC14
 11353 0110 A7000000 		.word	.LC15
 11354 0114 B4000000 		.word	.LC16
 11355 0118 C1000000 		.word	.LC17
 11356 011c C9000000 		.word	.LC18
 11357 0120 D7000000 		.word	.LC19
 11358 0124 E7000000 		.word	.LC20
 11359 0128 F8000000 		.word	.LC21
 11360 012c 08010000 		.word	.LC22
 11361              		.cfi_endproc
 11362              	.LFE273:
 11364              		.section	.text._Z19sendSerialTelemetryv,"ax",%progbits
 11365              		.align	1
 11366              		.global	_Z19sendSerialTelemetryv
 11367              		.thumb
 11368              		.thumb_func
 11370              	_Z19sendSerialTelemetryv:
 11371              	.LFB267:
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 11372              		.loc 34 370 0
 11373              		.cfi_startproc
 11374              		@ args = 0, pretend = 0, frame = 0
 11375              		@ frame_needed = 0, uses_anonymous_args = 0
 11376 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 11377              	.LCFI110:
 11378              		.cfi_def_cfa_offset 32
 11379              		.cfi_offset 14, -4
 11380              		.cfi_offset 7, -8
 11381              		.cfi_offset 6, -12
 11382              		.cfi_offset 5, -16
 11383              		.cfi_offset 4, -20
 11384              		.cfi_offset 2, -24
 11385              		.cfi_offset 1, -28
 11386              		.cfi_offset 0, -32
 11387              	.LBB305:
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 11388              		.loc 34 371 0
 11389 0002 A94C     		ldr	r4, .L761
 11390 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 11391 0006 6B2B     		cmp	r3, #107
 11392 0008 2646     		mov	r6, r4
 11393 000a 00F00A81 		beq	.L705
 11394 000e 30D8     		bhi	.L719
 11395 0010 632B     		cmp	r3, #99
 11396 0012 00F09680 		beq	.L698
 11397 0016 19D8     		bhi	.L720
 11398 0018 362B     		cmp	r3, #54
 11399 001a 00F05182 		beq	.L732
 11400 001e 0ED8     		bhi	.L721
 11401 0020 232B     		cmp	r3, #35
 11402 0022 00F04882 		beq	.L691
 11403 0026 03D8     		bhi	.L722
 11404 0028 212B     		cmp	r3, #33
 11405 002a 40F05682 		bne	.L688
 11406 002e 39E2     		b	.L754
 11407              	.L722:
 11408 0030 242B     		cmp	r3, #36
 11409 0032 00F02B82 		beq	.L692
 11410 0036 252B     		cmp	r3, #37
 11411 0038 40F04F82 		bne	.L688
 11412 003c 2AE2     		b	.L693
 11413              	.L721:
 11414 003e 612B     		cmp	r3, #97
 11415 0040 5FD0     		beq	.L696
 11416 0042 69D8     		bhi	.L697
 11417 0044 532B     		cmp	r3, #83
 11418 0046 40F04882 		bne	.L688
 11419 004a D2E1     		b	.L755
 11420              	.L720:
 11421 004c 662B     		cmp	r3, #102
 11422 004e 00F0AD80 		beq	.L701
 11423 0052 05D8     		bhi	.L723
 11424 0054 642B     		cmp	r3, #100
 11425 0056 7ED0     		beq	.L699
 11426 0058 652B     		cmp	r3, #101
 11427 005a 40F03E82 		bne	.L688
 11428 005e 9AE0     		b	.L756
 11429              	.L723:
 11430 0060 682B     		cmp	r3, #104
 11431 0062 00F0C980 		beq	.L703
 11432 0066 C0F0B280 		bcc	.L702
 11433 006a 692B     		cmp	r3, #105
 11434 006c 40F03582 		bne	.L688
 11435 0070 29E0     		b	.L757
 11436              	.L719:
 11437 0072 722B     		cmp	r3, #114
 11438 0074 00F07381 		beq	.L712
 11439 0078 10D8     		bhi	.L724
 11440 007a 6E2B     		cmp	r3, #110
 11441 007c 00F05D81 		beq	.L708
 11442 0080 06D8     		bhi	.L725
 11443 0082 6C2B     		cmp	r3, #108
 11444 0084 00F03A81 		beq	.L706
 11445 0088 6D2B     		cmp	r3, #109
 11446 008a 40F02682 		bne	.L688
 11447 008e 14E2     		b	.L744
 11448              	.L725:
 11449 0090 702B     		cmp	r3, #112
 11450 0092 00F05681 		beq	.L710
 11451 0096 00F25B81 		bhi	.L711
 11452 009a 50E1     		b	.L758
 11453              	.L724:
 11454 009c 752B     		cmp	r3, #117
 11455 009e 00F0BB81 		beq	.L715
 11456 00a2 06D8     		bhi	.L726
 11457 00a4 732B     		cmp	r3, #115
 11458 00a6 00F06D81 		beq	.L713
 11459 00aa 742B     		cmp	r3, #116
 11460 00ac 40F01582 		bne	.L688
 11461 00b0 A9E1     		b	.L759
 11462              	.L726:
 11463 00b2 792B     		cmp	r3, #121
 11464 00b4 00F0E381 		beq	.L717
 11465 00b8 7A2B     		cmp	r3, #122
 11466 00ba 00F0E281 		beq	.L718
 11467 00be 762B     		cmp	r3, #118
 11468 00c0 40F00B82 		bne	.L688
 11469 00c4 CBE1     		b	.L760
 11470              	.L757:
 11471              	.LVL511:
 11472              	.LBB306:
 11473              	.LBB307:
 456:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 11474              		.loc 34 456 0 discriminator 1
 11475 00c6 794C     		ldr	r4, .L761+4
 11476 00c8 2068     		ldr	r0, [r4, #0]	@ float
 11477 00ca FFF7FEFF 		bl	_Z15PrintValueCommaf
 11478              	.LVL512:
 11479 00ce 6068     		ldr	r0, [r4, #4]	@ float
 11480 00d0 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11481              	.LVL513:
 11482 00d4 A068     		ldr	r0, [r4, #8]	@ float
 11483              	.LBE307:
 11484              	.LBB308:
 459:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 11485              		.loc 34 459 0 discriminator 1
 11486 00d6 764C     		ldr	r4, .L761+8
 11487              	.LBE308:
 11488              	.LBB309:
 456:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 11489              		.loc 34 456 0 discriminator 1
 11490 00d8 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11491              	.LVL514:
 11492              	.LBE309:
 11493              	.LBB310:
 459:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 11494              		.loc 34 459 0 discriminator 1
 11495 00dc 2068     		ldr	r0, [r4, #0]	@ float
 11496 00de FFF7FEFF 		bl	_Z15PrintValueCommaf
 11497              	.LVL515:
 11498 00e2 6068     		ldr	r0, [r4, #4]	@ float
 11499 00e4 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11500              	.LVL516:
 11501 00e8 A068     		ldr	r0, [r4, #8]	@ float
 11502 00ea FFF7FEFF 		bl	_Z15PrintValueCommaf
 11503              	.LVL517:
 11504              	.LBE310:
 11505              	.LBB311:
 465:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(0);
 11506              		.loc 34 465 0 discriminator 1
 11507 00ee 0020     		movs	r0, #0
 11508 00f0 FFF7FEFF 		bl	_Z15PrintValueCommai
 11509              	.LVL518:
 11510 00f4 0020     		movs	r0, #0
 11511 00f6 FFF7FEFF 		bl	_Z15PrintValueCommai
 11512              	.LVL519:
 11513 00fa 0020     		movs	r0, #0
 11514 00fc FFF7FEFF 		bl	_Z15PrintValueCommai
 11515              	.LVL520:
 11516 0100 71E1     		b	.L746
 11517              	.LVL521:
 11518              	.L696:
 11519              	.LBE311:
 376:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 11520              		.loc 34 376 0
 11521 0102 0020     		movs	r0, #0
 11522 0104 FFF7FEFF 		bl	_Z8PrintPIDh
 377:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 11523              		.loc 34 377 0
 11524 0108 0120     		movs	r0, #1
 11525 010a FFF7FEFF 		bl	_Z8PrintPIDh
 378:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 11526              		.loc 34 378 0
 11527 010e 694B     		ldr	r3, .L761+12
 11528 0110 1868     		ldr	r0, [r3, #0]	@ float
 11529 0112 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11530 0116 17E1     		b	.L749
 11531              	.L697:
 384:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 11532              		.loc 34 384 0
 11533 0118 0320     		movs	r0, #3
 11534 011a FFF7FEFF 		bl	_Z8PrintPIDh
 385:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 11535              		.loc 34 385 0
 11536 011e 0420     		movs	r0, #4
 11537 0120 FFF7FEFF 		bl	_Z8PrintPIDh
 386:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 11538              		.loc 34 386 0
 11539 0124 0620     		movs	r0, #6
 11540 0126 FFF7FEFF 		bl	_Z8PrintPIDh
 387:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 11541              		.loc 34 387 0
 11542 012a 0720     		movs	r0, #7
 11543 012c FFF7FEFF 		bl	_Z8PrintPIDh
 388:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(windupGuard);
 11544              		.loc 34 388 0
 11545 0130 6148     		ldr	r0, .L761+16
 11546 0132 0068     		ldr	r0, [r0, #0]	@ float
 11547 0134 FFF7FEFF 		bl	__aeabi_f2d
 11548 0138 0B46     		mov	r3, r1
 11549 013a 0221     		movs	r1, #2
 11550 013c 0246     		mov	r2, r0
 11551 013e 0091     		str	r1, [sp, #0]
 11552 0140 AFE0     		b	.L753
 11553              	.L698:
 393:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 11554              		.loc 34 393 0
 11555 0142 0220     		movs	r0, #2
 11556 0144 FFF7FEFF 		bl	_Z8PrintPIDh
 394:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 11557              		.loc 34 394 0
 11558 0148 0520     		movs	r0, #5
 11559 014a FFF7FEFF 		bl	_Z8PrintPIDh
 395:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 11560              		.loc 34 395 0
 11561 014e 5B4A     		ldr	r2, .L761+20
 11562 0150 5B48     		ldr	r0, .L761+24
 11563 0152 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 11564 0154 26E0     		b	.L751
 11565              	.L699:
 401:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 11566              		.loc 34 401 0
 11567 0156 0820     		movs	r0, #8
 11568 0158 FFF7FEFF 		bl	_Z8PrintPIDh
 402:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard);
 11569              		.loc 34 402 0
 11570 015c 5949     		ldr	r1, .L761+28
 11571 015e D1F8F800 		ldr	r0, [r1, #248]	@ float
 11572 0162 FFF7FEFF 		bl	_Z15PrintValueCommaf
 403:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 11573              		.loc 34 403 0
 11574 0166 584B     		ldr	r3, .L761+32
 11575 0168 1868     		ldr	r0, [r3, #0]
 11576 016a FFF7FEFF 		bl	_Z15PrintValueCommai
 404:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 11577              		.loc 34 404 0
 11578 016e 574A     		ldr	r2, .L761+36
 11579 0170 1068     		ldr	r0, [r2, #0]
 11580 0172 FFF7FEFF 		bl	_Z15PrintValueCommai
 405:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 11581              		.loc 34 405 0
 11582 0176 5648     		ldr	r0, .L761+40
 11583 0178 0068     		ldr	r0, [r0, #0]
 11584 017a FFF7FEFF 		bl	_Z15PrintValueCommai
 406:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 11585              		.loc 34 406 0
 11586 017e 5549     		ldr	r1, .L761+44
 11587 0180 0868     		ldr	r0, [r1, #0]
 11588 0182 FFF7FEFF 		bl	_Z15PrintValueCommai
 408:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 11589              		.loc 34 408 0
 11590 0186 544B     		ldr	r3, .L761+48
 11591 0188 1868     		ldr	r0, [r3, #0]	@ float
 11592 018a FFF7FEFF 		bl	_Z15PrintValueCommaf
 412:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 11593              		.loc 34 412 0
 11594 018e 0920     		movs	r0, #9
 11595 0190 FFF7FEFF 		bl	_Z8PrintPIDh
 11596 0194 D8E0     		b	.L749
 11597              	.L756:
 421:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(aref);
 11598              		.loc 34 421 0
 11599 0196 5148     		ldr	r0, .L761+52
 11600 0198 0068     		ldr	r0, [r0, #0]	@ float
 11601 019a FFF7FEFF 		bl	_Z15PrintValueCommaf
 422:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 11602              		.loc 34 422 0
 11603 019e 504A     		ldr	r2, .L761+56
 11604 01a0 4748     		ldr	r0, .L761+24
 11605 01a2 1168     		ldr	r1, [r2, #0]
 11606              	.L751:
 11607 01a4 0A22     		movs	r2, #10
 11608 01a6 FFF7FEFF 		bl	_ZN5Print7printlnEii
 11609 01aa 86E1     		b	.L744
 11610              	.L701:
 427:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 11611              		.loc 34 427 0
 11612 01ac 4D4D     		ldr	r5, .L761+60
 11613 01ae 4E4C     		ldr	r4, .L761+64
 11614 01b0 2868     		ldr	r0, [r5, #0]	@ float
 11615 01b2 FFF7FEFF 		bl	_Z15PrintValueCommaf
 11616              	.LVL522:
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 11617              		.loc 34 370 0
 11618 01b6 04F12005 		add	r5, r4, #32
 11619              	.LVL523:
 11620              	.L727:
 11621              	.LBB312:
 429:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 11622              		.loc 34 429 0 discriminator 2
 11623 01ba 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11624 01be FFF7FEFF 		bl	_Z15PrintValueCommaf
 428:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11625              		.loc 34 428 0 discriminator 2
 11626 01c2 AC42     		cmp	r4, r5
 11627 01c4 F9D1     		bne	.L727
 11628              	.LBE312:
 431:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(10 - LASTCHANNEL);
 11629              		.loc 34 431 0
 11630 01c6 0220     		movs	r0, #2
 11631 01c8 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 11632 01cc 80E1     		b	.L745
 11633              	.L702:
 434:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 11634              		.loc 34 434 0
 11635 01ce 474C     		ldr	r4, .L761+68
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 11636              		.loc 34 370 0
 11637 01d0 04F12005 		add	r5, r4, #32
 11638              	.L728:
 11639              	.LBB313:
 438:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 11640              		.loc 34 438 0 discriminator 2
 11641 01d4 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11642 01d8 FFF7FEFF 		bl	__aeabi_f2d
 11643 01dc 0246     		mov	r2, r0
 11644 01de 0B46     		mov	r3, r1
 11645 01e0 3748     		ldr	r0, .L761+24
 11646 01e2 0621     		movs	r1, #6
 11647 01e4 0091     		str	r1, [sp, #0]
 11648 01e6 FFF7FEFF 		bl	_ZN5Print5printEdi
 439:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 11649              		.loc 34 439 0 discriminator 2
 11650 01ea 2C21     		movs	r1, #44
 11651 01ec 3448     		ldr	r0, .L761+24
 11652 01ee FFF7FEFF 		bl	_ZN5Print5printEc
 437:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11653              		.loc 34 437 0 discriminator 2
 11654 01f2 AC42     		cmp	r4, r5
 11655 01f4 EED1     		bne	.L728
 11656 01f6 6BE1     		b	.L745
 11657              	.LVL524:
 11658              	.L703:
 11659              	.LBE313:
 443:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 11660              		.loc 34 443 0
 11661 01f8 3D4C     		ldr	r4, .L761+72
 370:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** void sendSerialTelemetry() {
 11662              		.loc 34 370 0
 11663 01fa 04F12005 		add	r5, r4, #32
 11664              	.L729:
 11665              	.LBB314:
 447:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 11666              		.loc 34 447 0 discriminator 2
 11667 01fe 54F8040F 		ldr	r0, [r4, #4]!	@ float
 11668 0202 FFF7FEFF 		bl	__aeabi_f2d
 11669 0206 0246     		mov	r2, r0
 11670 0208 0620     		movs	r0, #6
 11671 020a 0B46     		mov	r3, r1
 11672 020c 0090     		str	r0, [sp, #0]
 11673 020e 2C48     		ldr	r0, .L761+24
 11674 0210 FFF7FEFF 		bl	_ZN5Print5printEdi
 448:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       Serial.print(',');
 11675              		.loc 34 448 0 discriminator 2
 11676 0214 2C21     		movs	r1, #44
 11677 0216 2A48     		ldr	r0, .L761+24
 11678 0218 FFF7FEFF 		bl	_ZN5Print5printEc
 446:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 11679              		.loc 34 446 0 discriminator 2
 11680 021c AC42     		cmp	r4, r5
 11681 021e EED1     		bne	.L729
 11682 0220 56E1     		b	.L745
 11683              	.LVL525:
 11684              	.L705:
 11685              	.LBE314:
 480:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 11686              		.loc 34 480 0
 11687 0222 344E     		ldr	r6, .L761+76
 482:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 11688              		.loc 34 482 0
 11689 0224 344F     		ldr	r7, .L761+80
 480:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 11690              		.loc 34 480 0
 11691 0226 3068     		ldr	r0, [r6, #0]	@ float
 11692 0228 FFF7FEFF 		bl	__aeabi_f2d
 11693 022c 0625     		movs	r5, #6
 11694 022e 0246     		mov	r2, r0
 11695 0230 0B46     		mov	r3, r1
 11696 0232 2348     		ldr	r0, .L761+24
 11697 0234 0095     		str	r5, [sp, #0]
 11698 0236 FFF7FEFF 		bl	_ZN5Print5printEdi
 481:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 11699              		.loc 34 481 0
 11700 023a FFF7FEFF 		bl	_Z5commav
 482:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 11701              		.loc 34 482 0
 11702 023e 3868     		ldr	r0, [r7, #0]	@ float
 11703 0240 FFF7FEFF 		bl	__aeabi_f2d
 11704 0244 0246     		mov	r2, r0
 11705 0246 0B46     		mov	r3, r1
 11706 0248 1D48     		ldr	r0, .L761+24
 11707 024a 0095     		str	r5, [sp, #0]
 11708 024c FFF7FEFF 		bl	_ZN5Print5printEdi
 483:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 11709              		.loc 34 483 0
 11710 0250 FFF7FEFF 		bl	_Z5commav
 484:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 11711              		.loc 34 484 0
 11712 0254 7068     		ldr	r0, [r6, #4]	@ float
 11713 0256 FFF7FEFF 		bl	__aeabi_f2d
 11714 025a 0246     		mov	r2, r0
 11715 025c 0B46     		mov	r3, r1
 11716 025e 1848     		ldr	r0, .L761+24
 11717 0260 0095     		str	r5, [sp, #0]
 11718 0262 FFF7FEFF 		bl	_ZN5Print5printEdi
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 11719              		.loc 34 485 0
 11720 0266 FFF7FEFF 		bl	_Z5commav
 486:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 11721              		.loc 34 486 0
 11722 026a 7868     		ldr	r0, [r7, #4]	@ float
 11723 026c FFF7FEFF 		bl	__aeabi_f2d
 11724 0270 0246     		mov	r2, r0
 11725 0272 0B46     		mov	r3, r1
 11726 0274 1248     		ldr	r0, .L761+24
 11727 0276 0095     		str	r5, [sp, #0]
 11728 0278 FFF7FEFF 		bl	_ZN5Print5printEdi
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 11729              		.loc 34 487 0
 11730 027c FFF7FEFF 		bl	_Z5commav
 488:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 11731              		.loc 34 488 0
 11732 0280 B068     		ldr	r0, [r6, #8]	@ float
 11733 0282 FFF7FEFF 		bl	__aeabi_f2d
 11734 0286 0246     		mov	r2, r0
 11735 0288 0B46     		mov	r3, r1
 11736 028a 0D48     		ldr	r0, .L761+24
 11737 028c 0095     		str	r5, [sp, #0]
 11738 028e FFF7FEFF 		bl	_ZN5Print5printEdi
 489:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     comma();
 11739              		.loc 34 489 0
 11740 0292 FFF7FEFF 		bl	_Z5commav
 490:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 11741              		.loc 34 490 0
 11742 0296 B868     		ldr	r0, [r7, #8]	@ float
 11743 0298 FFF7FEFF 		bl	__aeabi_f2d
 11744 029c 0095     		str	r5, [sp, #0]
 11745 029e 0246     		mov	r2, r0
 11746 02a0 0B46     		mov	r3, r1
 11747              	.L753:
 11748 02a2 0748     		ldr	r0, .L761+24
 11749 02a4 04E1     		b	.L750
 11750              	.L762:
 11751 02a6 00BF     		.align	2
 11752              	.L761:
 11753 02a8 00000000 		.word	.LANCHOR142
 11754 02ac 00000000 		.word	.LANCHOR19
 11755 02b0 00000000 		.word	.LANCHOR145
 11756 02b4 00000000 		.word	.LANCHOR120
 11757 02b8 00000000 		.word	.LANCHOR139
 11758 02bc 00000000 		.word	.LANCHOR130
 11759 02c0 00000000 		.word	Serial1
 11760 02c4 00000000 		.word	.LANCHOR9
 11761 02c8 00000000 		.word	.LANCHOR107
 11762 02cc 00000000 		.word	.LANCHOR106
 11763 02d0 00000000 		.word	.LANCHOR113
 11764 02d4 00000000 		.word	.LANCHOR114
 11765 02d8 00000000 		.word	.LANCHOR74
 11766 02dc 00000000 		.word	.LANCHOR140
 11767 02e0 00000000 		.word	.LANCHOR125
 11768 02e4 00000000 		.word	.LANCHOR55
 11769 02e8 FCFFFFFF 		.word	.LANCHOR6-4
 11770 02ec FCFFFFFF 		.word	.LANCHOR4-4
 11771 02f0 FCFFFFFF 		.word	.LANCHOR5-4
 11772 02f4 00000000 		.word	.LANCHOR27
 11773 02f8 00000000 		.word	.LANCHOR28
 11774              	.L706:
 496:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 11775              		.loc 34 496 0
 11776 02fc 7A4C     		ldr	r4, .L763+8
 11777 02fe 7B4D     		ldr	r5, .L763+12
 495:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     measureAccelSum();
 11778              		.loc 34 495 0
 11779 0300 FFF7FEFF 		bl	_Z15measureAccelSumv
 496:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]/accelSampleCount));
 11780              		.loc 34 496 0
 11781 0304 2668     		ldr	r6, [r4, #0]
 11782 0306 2878     		ldrb	r0, [r5, #0]	@ zero_extendqisi2
 11783 0308 96FBF0F0 		sdiv	r0, r6, r0
 11784 030c FFF7FEFF 		bl	_Z15PrintValueCommai
 498:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 11785              		.loc 34 498 0
 11786 0310 2B78     		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 11787 0312 6168     		ldr	r1, [r4, #4]
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[XAXIS] = 0;
 11788              		.loc 34 497 0
 11789 0314 0026     		movs	r6, #0
 498:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 11790              		.loc 34 498 0
 11791 0316 91FBF3F0 		sdiv	r0, r1, r3
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[XAXIS] = 0;
 11792              		.loc 34 497 0
 11793 031a 2660     		str	r6, [r4, #0]
 498:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]/accelSampleCount));
 11794              		.loc 34 498 0
 11795 031c FFF7FEFF 		bl	_Z15PrintValueCommai
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 11796              		.loc 34 500 0
 11797 0320 A268     		ldr	r2, [r4, #8]
 11798 0322 95F800C0 		ldrb	ip, [r5, #0]	@ zero_extendqisi2
 499:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[YAXIS] = 0;
 11799              		.loc 34 499 0
 11800 0326 6660     		str	r6, [r4, #4]
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]/accelSampleCount));
 11801              		.loc 34 500 0
 11802 0328 92FBFCF1 		sdiv	r1, r2, ip
 11803 032c 7048     		ldr	r0, .L763+16
 11804 032e 0A22     		movs	r2, #10
 11805 0330 FFF7FEFF 		bl	_ZN5Print7printlnEii
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSample[ZAXIS] = 0;
 11806              		.loc 34 501 0
 11807 0334 A660     		str	r6, [r4, #8]
 502:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     accelSampleCount = 0;
 11808              		.loc 34 502 0
 11809 0336 2E70     		strb	r6, [r5, #0]
 503:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 11810              		.loc 34 503 0
 11811 0338 CFE0     		b	.L688
 11812              	.L708:
 522:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 11813              		.loc 34 522 0
 11814 033a 0320     		movs	r0, #3
 11815 033c 02E0     		b	.L752
 11816              	.L758:
 537:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(4);
 11817              		.loc 34 537 0
 11818 033e 0420     		movs	r0, #4
 11819 0340 00E0     		b	.L752
 11820              	.L710:
 565:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintDummyValues(13);
 11821              		.loc 34 565 0
 11822 0342 0D20     		movs	r0, #13
 11823              	.L752:
 11824 0344 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 11825              	.L749:
 568:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 11826              		.loc 34 568 0
 11827 0348 6948     		ldr	r0, .L763+16
 11828 034a FFF7FEFF 		bl	_ZN5Print7printlnEv
 11829 034e B4E0     		b	.L744
 11830              	.L711:
 573:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 11831              		.loc 34 573 0
 11832 0350 684A     		ldr	r2, .L763+20
 11833 0352 6748     		ldr	r0, .L763+16
 11834 0354 1168     		ldr	r1, [r2, #0]
 11835 0356 0A22     		movs	r2, #10
 11836 0358 FFF7FEFF 		bl	_ZN5Print7printlnEmi
 11837 035c ADE0     		b	.L744
 11838              	.L712:
 578:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 11839              		.loc 34 578 0
 11840 035e 664C     		ldr	r4, .L763+24
 11841 0360 2068     		ldr	r0, [r4, #0]	@ float
 11842 0362 FFF7FEFF 		bl	_Z15PrintValueCommaf
 579:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 11843              		.loc 34 579 0
 11844 0366 6068     		ldr	r0, [r4, #4]	@ float
 11845 0368 FFF7FEFF 		bl	_Z15PrintValueCommaf
 580:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(getHeading());
 11846              		.loc 34 580 0
 11847 036c FFF7FEFF 		bl	_Z10getHeadingv
 11848 0370 FFF7FEFF 		bl	__aeabi_f2d
 11849 0374 0246     		mov	r2, r0
 11850 0376 0B46     		mov	r3, r1
 11851 0378 5D48     		ldr	r0, .L763+16
 11852 037a 0221     		movs	r1, #2
 11853 037c 0091     		str	r1, [sp, #0]
 11854 037e FFF7FEFF 		bl	_ZN5Print7printlnEdi
 581:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 11855              		.loc 34 581 0
 11856 0382 AAE0     		b	.L688
 11857              	.L713:
 584:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(motorArmed);
 11858              		.loc 34 584 0
 11859 0384 5D4B     		ldr	r3, .L763+28
 585:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 11860              		.loc 34 585 0
 11861 0386 5C4C     		ldr	r4, .L763+24
 584:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(motorArmed);
 11862              		.loc 34 584 0
 11863 0388 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 11864 038a FFF7FEFF 		bl	_Z15PrintValueCommah
 585:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 11865              		.loc 34 585 0
 11866 038e 2068     		ldr	r0, [r4, #0]	@ float
 11867 0390 FFF7FEFF 		bl	_Z15PrintValueCommaf
 586:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 11868              		.loc 34 586 0
 11869 0394 6068     		ldr	r0, [r4, #4]	@ float
 594:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 11870              		.loc 34 594 0
 11871 0396 5A4C     		ldr	r4, .L763+32
 586:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 11872              		.loc 34 586 0
 11873 0398 FFF7FEFF 		bl	_Z15PrintValueCommaf
 587:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(getHeading());
 11874              		.loc 34 587 0
 11875 039c FFF7FEFF 		bl	_Z10getHeadingv
 11876 03a0 FFF7FEFF 		bl	_Z15PrintValueCommaf
 590:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****         PrintValueComma(getBaroAltitude());
 11877              		.loc 34 590 0
 11878 03a4 FFF7FEFF 		bl	_Z15getBaroAltitudev
 11879 03a8 FFF7FEFF 		bl	_Z15PrintValueCommaf
 594:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 11880              		.loc 34 594 0
 11881 03ac 2078     		ldrb	r0, [r4, #0]	@ zero_extendqisi2
 11882 03ae FFF7FEFF 		bl	_Z15PrintValueCommai
 11883              	.LVL526:
 11884 03b2 0024     		movs	r4, #0
 11885              	.LVL527:
 11886              	.L730:
 11887              	.LBB315:
 601:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 11888              		.loc 34 601 0 discriminator 1
 11889 03b4 5348     		ldr	r0, .L763+36
 11890 03b6 2058     		ldr	r0, [r4, r0]
 11891 03b8 0434     		adds	r4, r4, #4
 11892 03ba FFF7FEFF 		bl	_Z15PrintValueCommai
 600:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 11893              		.loc 34 600 0 discriminator 1
 11894 03be 202C     		cmp	r4, #32
 11895 03c0 F8D1     		bne	.L730
 600:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 11896              		.loc 34 600 0 is_stmt 0
 11897 03c2 0024     		movs	r4, #0
 11898              	.L731:
 11899              	.LBE315:
 11900              	.LBB316:
 605:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 11901              		.loc 34 605 0 is_stmt 1 discriminator 2
 11902 03c4 504A     		ldr	r2, .L763+40
 11903 03c6 A058     		ldr	r0, [r4, r2]
 11904 03c8 0434     		adds	r4, r4, #4
 11905 03ca FFF7FEFF 		bl	_Z15PrintValueCommai
 604:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 11906              		.loc 34 604 0 discriminator 2
 11907 03ce 102C     		cmp	r4, #16
 11908 03d0 F8D1     		bne	.L731
 11909              	.LBE316:
 607:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 11910              		.loc 34 607 0
 11911 03d2 0420     		movs	r0, #4
 11912 03d4 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 612:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(0);
 11913              		.loc 34 612 0
 11914 03d8 0020     		movs	r0, #0
 11915 03da FFF7FEFF 		bl	_Z15PrintValueCommai
 614:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     PrintValueComma(flightMode);
 11916              		.loc 34 614 0
 11917 03de 4B49     		ldr	r1, .L763+44
 11918 03e0 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 11919 03e2 FFF7FEFF 		bl	_Z15PrintValueCommah
 11920              	.LVL528:
 11921              	.L746:
 615:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 11922              		.loc 34 615 0
 11923 03e6 4248     		ldr	r0, .L763+16
 11924              	.LBE306:
 11925              	.LBE305:
 766:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 11926              		.loc 34 766 0
 11927 03e8 03B0     		add	sp, sp, #12
 11928 03ea BDE8F040 		pop	{r4, r5, r6, r7, lr}
 11929              	.LBB325:
 11930              	.LBB320:
 615:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 11931              		.loc 34 615 0
 11932 03ee FFF7FEBF 		b	_ZN5Print7printlnEv
 11933              	.L755:
 11934              	.LBE320:
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 11935              		.loc 34 371 0
 11936 03f2 0024     		movs	r4, #0
 11937              	.L695:
 11938              	.LBB321:
 11939              	.LBB317:
 619:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 11940              		.loc 34 619 0 discriminator 2
 11941 03f4 444B     		ldr	r3, .L763+40
 11942 03f6 E058     		ldr	r0, [r4, r3]
 11943 03f8 0434     		adds	r4, r4, #4
 11944 03fa FFF7FEFF 		bl	_Z15PrintValueCommai
 618:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 	for (byte motor = 0; motor < LASTMOTOR; motor++) {
 11945              		.loc 34 618 0 discriminator 2
 11946 03fe 102C     		cmp	r4, #16
 11947 0400 F8D1     		bne	.L695
 11948              	.LBE317:
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** 	PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 11949              		.loc 34 621 0
 11950 0402 0420     		movs	r0, #4
 11951 0404 43E0     		b	.L748
 11952              	.LVL529:
 11953              	.L759:
 11954              	.LBE321:
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 11955              		.loc 34 371 0
 11956 0406 0024     		movs	r4, #0
 11957              	.L714:
 11958              	.LBB322:
 11959              	.LBB318:
 626:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 11960              		.loc 34 626 0 discriminator 2
 11961 0408 3E48     		ldr	r0, .L763+36
 11962 040a 2058     		ldr	r0, [r4, r0]
 11963 040c 0434     		adds	r4, r4, #4
 11964 040e FFF7FEFF 		bl	_Z15PrintValueCommai
 625:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 11965              		.loc 34 625 0 discriminator 2
 11966 0412 202C     		cmp	r4, #32
 11967 0414 F8D1     		bne	.L714
 11968 0416 E6E7     		b	.L746
 11969              	.LVL530:
 11970              	.L715:
 11971              	.LBE318:
 650:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(HokuyoHoldState);
 11972              		.loc 34 650 0
 11973 0418 3D49     		ldr	r1, .L763+48
 651:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyo_YRaw);  //pitch
 11974              		.loc 34 651 0
 11975 041a 3E4C     		ldr	r4, .L763+52
 650:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(HokuyoHoldState);
 11976              		.loc 34 650 0
 11977 041c 0878     		ldrb	r0, [r1, #0]	@ zero_extendqisi2
 11978 041e FFF7FEFF 		bl	_Z15PrintValueCommah
 651:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyo_YRaw);  //pitch
 11979              		.loc 34 651 0
 11980 0422 2068     		ldr	r0, [r4, #0]
 652:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(distance2D[plus_Y]);  //pitch
 11981              		.loc 34 652 0
 11982 0424 3C4C     		ldr	r4, .L763+56
 651:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyo_YRaw);  //pitch
 11983              		.loc 34 651 0
 11984 0426 FFF7FEFF 		bl	_Z15PrintValueCommai
 652:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(distance2D[plus_Y]);  //pitch
 11985              		.loc 34 652 0
 11986 042a 6068     		ldr	r0, [r4, #4]
 11987 042c FFF7FEFF 		bl	_Z15PrintValueCommai
 653:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyo_XRaw);  //roll
 11988              		.loc 34 653 0
 11989 0430 3A4A     		ldr	r2, .L763+60
 11990 0432 1068     		ldr	r0, [r2, #0]
 11991 0434 FFF7FEFF 		bl	_Z15PrintValueCommai
 654:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(distance2D[plus_X]);  //roll
 11992              		.loc 34 654 0
 11993 0438 2068     		ldr	r0, [r4, #0]
 11994 043a FFF7FEFF 		bl	_Z15PrintValueCommai
 655:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(HokuyoPositionToHoldTarget_X); 
 11995              		.loc 34 655 0
 11996 043e 3848     		ldr	r0, .L763+64
 11997 0440 0068     		ldr	r0, [r0, #0]	@ float
 11998 0442 FFF7FEFF 		bl	_Z15PrintValueCommaf
 656:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(hokuyoHoldThrottleCorrection_X);
 11999              		.loc 34 656 0
 12000 0446 374B     		ldr	r3, .L763+68
 12001 0448 1868     		ldr	r0, [r3, #0]
 12002 044a FFF7FEFF 		bl	_Z15PrintValueCommai
 657:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorAxisCommandRoll);
 12003              		.loc 34 657 0
 12004 044e 3649     		ldr	r1, .L763+72
 12005 0450 0868     		ldr	r0, [r1, #0]
 12006 0452 FFF7FEFF 		bl	_Z15PrintValueCommai
 658:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(temphokuyoHoldThrottleCorrection_XGLOBAL);
 12007              		.loc 34 658 0
 12008 0456 354A     		ldr	r2, .L763+76
 12009 0458 2548     		ldr	r0, .L763+16
 12010 045a 1168     		ldr	r1, [r2, #0]
 12011 045c 1CE0     		b	.L747
 12012              	.L760:
 669:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSROLL_PID_IDX);
 12013              		.loc 34 669 0
 12014 045e 0C20     		movs	r0, #12
 12015 0460 FFF7FEFF 		bl	_Z8PrintPIDh
 670:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSPITCH_PID_IDX);
 12016              		.loc 34 670 0
 12017 0464 0B20     		movs	r0, #11
 12018 0466 FFF7FEFF 		bl	_Z8PrintPIDh
 672:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       queryType = 'X';
 12019              		.loc 34 672 0
 12020 046a 5825     		movs	r5, #88
 671:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintPID(GPSYAW_PID_IDX);
 12021              		.loc 34 671 0
 12022 046c 0D20     		movs	r0, #13
 12023 046e FFF7FEFF 		bl	_Z8PrintPIDh
 672:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       queryType = 'X';
 12024              		.loc 34 672 0
 12025 0472 2570     		strb	r5, [r4, #0]
 676:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 12026              		.loc 34 676 0
 12027 0474 1E48     		ldr	r0, .L763+16
 12028 0476 FFF7FEFF 		bl	_ZN5Print7printlnEv
 677:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 12029              		.loc 34 677 0
 12030 047a 2570     		strb	r5, [r4, #0]
 678:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 12031              		.loc 34 678 0
 12032 047c 2DE0     		b	.L688
 12033              	.L717:
 693:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(11);
 12034              		.loc 34 693 0
 12035 047e 0B20     		movs	r0, #11
 12036 0480 05E0     		b	.L748
 12037              	.L718:
 700:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(getBaroAltitude()); 
 12038              		.loc 34 700 0
 12039 0482 FFF7FEFF 		bl	_Z15getBaroAltitudev
 12040 0486 FFF7FEFF 		bl	_Z15PrintValueCommaf
 12041 048a 03E0     		b	.L693
 12042              	.L692:
 721:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintDummyValues(3);
 12043              		.loc 34 721 0
 12044 048c 0320     		movs	r0, #3
 12045              	.L748:
 12046 048e FFF7FEFF 		bl	_Z16PrintDummyValuesh
 12047 0492 A8E7     		b	.L746
 12048              	.L693:
 730:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 12049              		.loc 34 730 0
 12050 0494 1648     		ldr	r0, .L763+16
 12051 0496 0021     		movs	r1, #0
 12052              	.L747:
 12053 0498 0A22     		movs	r2, #10
 12054              	.LBE322:
 12055              	.LBE325:
 766:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 12056              		.loc 34 766 0
 12057 049a 03B0     		add	sp, sp, #12
 12058 049c BDE8F040 		pop	{r4, r5, r6, r7, lr}
 12059              	.LBB326:
 12060              	.LBB323:
 730:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       SERIAL_PRINTLN(0);
 12061              		.loc 34 730 0
 12062 04a0 FFF7FEBF 		b	_ZN5Print7printlnEii
 12063              	.L754:
 738:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 12064              		.loc 34 738 0
 12065 04a4 0123     		movs	r3, #1
 12066 04a6 0093     		str	r3, [sp, #0]
 12067 04a8 0DA3     		adr	r3, .L763
 12068 04aa D3E90023 		ldrd	r2, [r3]
 12069 04ae 1048     		ldr	r0, .L763+16
 12070              	.L750:
 12071 04b0 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 12072 04b4 01E0     		b	.L744
 12073              	.L691:
 743:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     reportVehicleState();
 12074              		.loc 34 743 0
 12075 04b6 FFF7FEFF 		bl	_Z18reportVehicleStatev
 12076              	.L744:
 744:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 12077              		.loc 34 744 0
 12078 04ba 5820     		movs	r0, #88
 12079 04bc 2070     		strb	r0, [r4, #0]
 745:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     break;
 12080              		.loc 34 745 0
 12081 04be 0CE0     		b	.L688
 12082              	.L732:
 12083              	.LBE323:
 371:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****   switch (queryType) {
 12084              		.loc 34 371 0
 12085 04c0 0024     		movs	r4, #0
 12086              	.L694:
 12087              	.LBB324:
 12088              	.LBB319:
 749:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 12089              		.loc 34 749 0 discriminator 2
 12090 04c2 114A     		ldr	r2, .L763+40
 12091 04c4 A058     		ldr	r0, [r4, r2]
 12092 04c6 0434     		adds	r4, r4, #4
 12093 04c8 FFF7FEFF 		bl	_Z15PrintValueCommai
 748:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 12094              		.loc 34 748 0 discriminator 2
 12095 04cc 102C     		cmp	r4, #16
 12096 04ce F8D1     		bne	.L694
 12097              	.LVL531:
 12098              	.L745:
 12099              	.LBE319:
 751:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     SERIAL_PRINTLN();
 12100              		.loc 34 751 0
 12101 04d0 0748     		ldr	r0, .L763+16
 12102 04d2 FFF7FEFF 		bl	_ZN5Print7printlnEv
 752:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h ****     queryType = 'X';
 12103              		.loc 34 752 0
 12104 04d6 5821     		movs	r1, #88
 12105 04d8 3170     		strb	r1, [r6, #0]
 12106              	.L688:
 12107              	.LBE324:
 12108              	.LBE326:
 766:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/SerialCom.h **** }
 12109              		.loc 34 766 0
 12110 04da 03B0     		add	sp, sp, #12
 12111 04dc F0BD     		pop	{r4, r5, r6, r7, pc}
 12112              	.L764:
 12113 04de 00BF     		.align	3
 12114              	.L763:
 12115 04e0 000000A0 		.word	-1610612736
 12116 04e4 99990940 		.word	1074370969
 12117 04e8 00000000 		.word	.LANCHOR29
 12118 04ec 00000000 		.word	.LANCHOR30
 12119 04f0 00000000 		.word	Serial1
 12120 04f4 00000000 		.word	.LANCHOR13
 12121 04f8 00000000 		.word	.LANCHOR33
 12122 04fc 00000000 		.word	.LANCHOR138
 12123 0500 00000000 		.word	.LANCHOR98
 12124 0504 00000000 		.word	.LANCHOR1
 12125 0508 00000000 		.word	.LANCHOR56
 12126 050c 00000000 		.word	.LANCHOR119
 12127 0510 00000000 		.word	.LANCHOR108
 12128 0514 00000000 		.word	.LANCHOR146
 12129 0518 00000000 		.word	.LANCHOR84
 12130 051c 00000000 		.word	.LANCHOR147
 12131 0520 00000000 		.word	.LANCHOR109
 12132 0524 00000000 		.word	.LANCHOR111
 12133 0528 00000000 		.word	.LANCHOR94
 12134 052c 00000000 		.word	.LANCHOR110
 12135              		.cfi_endproc
 12136              	.LFE267:
 12138              		.section	.text._Z5setupv,"ax",%progbits
 12139              		.align	1
 12140              		.global	_Z5setupv
 12141              		.thumb
 12142              		.thumb_func
 12144              	_Z5setupv:
 12145              	.LFB274:
 334:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void setup() {
 12146              		.loc 18 334 0
 12147              		.cfi_startproc
 12148              		@ args = 0, pretend = 0, frame = 0
 12149              		@ frame_needed = 0, uses_anonymous_args = 0
 12150 0000 10B5     		push	{r4, lr}
 12151              	.LCFI111:
 12152              		.cfi_def_cfa_offset 8
 12153              		.cfi_offset 14, -4
 12154              		.cfi_offset 4, -8
 12155              	.LBB327:
 335:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
 12156              		.loc 18 335 0
 12157 0002 3348     		ldr	r0, .L771
 12158 0004 4FF46141 		mov	r1, #57600
 12159 0008 FFF7FEFF 		bl	_ZN14HardwareSerial5beginEj
 336:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
 12160              		.loc 18 336 0
 12161 000c 4620     		movs	r0, #70
 12162 000e 0021     		movs	r1, #0
 12163 0010 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 337:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
 12164              		.loc 18 337 0
 12165 0014 4620     		movs	r0, #70
 12166 0016 0021     		movs	r1, #0
 12167 0018 FFF7FEFF 		bl	_Z12digitalWritehh
 341:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
 12168              		.loc 18 341 0
 12169 001c FFF7FEFF 		bl	_Z10readEEPROMv
 12170              	.LVL532:
 343:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
 12171              		.loc 18 343 0
 12172 0020 4FF48A70 		mov	r0, #276
 12173 0024 FFF7FEFF 		bl	_Z12nvrReadFloati
 12174 0028 DFED2A7A 		flds	s15, .L771+4
 12175 002c 07EE100A 		fmsr	s14, r0
 12176 0030 B4EE677A 		fcmps	s14, s15
 12177 0034 F1EE10FA 		fmstat
 12178 0038 05D0     		beq	.L769
 344:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeEEPROM();
 12179              		.loc 18 344 0
 12180 003a FFF7FEFF 		bl	_Z16initializeEEPROMv
 346:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     firstTimeBoot = true;
 12181              		.loc 18 346 0
 12182 003e 0124     		movs	r4, #1
 345:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
 12183              		.loc 18 345 0
 12184 0040 FFF7FEFF 		bl	_Z11writeEEPROMv
 12185              	.LVL533:
 12186 0044 00E0     		b	.L766
 12187              	.LVL534:
 12188              	.L769:
 342:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   boolean firstTimeBoot = false;
 12189              		.loc 18 342 0
 12190 0046 0024     		movs	r4, #0
 12191              	.LVL535:
 12192              	.L766:
 349:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initPlatform();
 12193              		.loc 18 349 0
 12194 0048 FFF7FEFF 		bl	_Z12initPlatformv
 352:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****      initializeMotors(FOUR_Motors);
 12195              		.loc 18 352 0
 12196 004c 0420     		movs	r0, #4
 12197 004e FFF7FEFF 		bl	_Z16initializeMotors9NB_Motors
 355:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
 12198              		.loc 18 355 0
 12199 0052 0820     		movs	r0, #8
 12200 0054 FFF7FEFF 		bl	_Z18initializeReceiveri
 356:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initReceiverFromEEPROM();
 12201              		.loc 18 356 0
 12202 0058 FFF7FEFF 		bl	_Z22initReceiverFromEEPROMv
 361:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
 12203              		.loc 18 361 0
 12204 005c FFF7FEFF 		bl	_Z14initializeGyrov
 12205              	.L767:
 362:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   while (!calibrateGyro()); // this make sure the craft is still befor to continue init process
 12206              		.loc 18 362 0 discriminator 1
 12207 0060 FFF7FEFF 		bl	_Z13calibrateGyrov
 12208 0064 0028     		cmp	r0, #0
 12209 0066 FBD0     		beq	.L767
 363:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
 12210              		.loc 18 363 0
 12211 0068 FFF7FEFF 		bl	_Z15initializeAccelv
 364:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (firstTimeBoot) {
 12212              		.loc 18 364 0
 12213 006c 1CB1     		cbz	r4, .L768
 365:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     computeAccelBias();
 12214              		.loc 18 365 0
 12215 006e FFF7FEFF 		bl	_Z16computeAccelBiasv
 366:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     writeEEPROM();
 12216              		.loc 18 366 0
 12217 0072 FFF7FEFF 		bl	_Z11writeEEPROMv
 12218              	.L768:
 368:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   setupFourthOrder();
 12219              		.loc 18 368 0
 12220 0076 FFF7FEFF 		bl	_Z16setupFourthOrderv
 369:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initSensorsZeroFromEEPROM();
 12221              		.loc 18 369 0
 12222 007a FFF7FEFF 		bl	_Z25initSensorsZeroFromEEPROMv
 375:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_XAXIS_PID_IDX].windupGuard = 0.375;
 12223              		.loc 18 375 0
 12224 007e 164B     		ldr	r3, .L771+8
 12225 0080 4FF07B51 		mov	r1, #1052770304
 12226 0084 D966     		str	r1, [r3, #108]	@ float
 376:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   PID[ATTITUDE_YAXIS_PID_IDX].windupGuard = 0.375;
 12227              		.loc 18 376 0
 12228 0086 C3F88810 		str	r1, [r3, #136]	@ float
 379:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   initializeKinematics();
 12229              		.loc 18 379 0
 12230 008a FFF7FEFF 		bl	_Z20initializeKinematicsv
 389:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     initializeBaro();
 12231              		.loc 18 389 0
 12232 008e FFF7FEFF 		bl	_Z14initializeBarov
 390:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 12233              		.loc 18 390 0
 12234 0092 1248     		ldr	r0, .L771+12
 12235 0094 0468     		ldr	r4, [r0, #0]
 12236              	.LVL536:
 12237 0096 44F02002 		orr	r2, r4, #32
 12238 009a 0260     		str	r2, [r0, #0]
 434:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     Init_Hokuyo();
 12239              		.loc 18 434 0
 12240 009c FFF7FEFF 		bl	_Z11Init_Hokuyov
 440:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   previousTime = micros();
 12241              		.loc 18 440 0
 12242 00a0 FFF7FEFF 		bl	_ZL6microsv
 12243 00a4 0E49     		ldr	r1, .L771+16
 12244 00a6 0860     		str	r0, [r1, #0]
 441:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
 12245              		.loc 18 441 0
 12246 00a8 4620     		movs	r0, #70
 12247 00aa 0121     		movs	r1, #1
 12248 00ac FFF7FEFF 		bl	_Z12digitalWritehh
 442:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   safetyCheck = 0;
 12249              		.loc 18 442 0
 12250 00b0 0C4B     		ldr	r3, .L771+20
 458:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   myLidarLite.begin(0, false); // Set configuration to default and I2C to 100 kHz
 12251              		.loc 18 458 0
 12252 00b2 0D48     		ldr	r0, .L771+24
 442:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   safetyCheck = 0;
 12253              		.loc 18 442 0
 12254 00b4 0024     		movs	r4, #0
 12255 00b6 1C70     		strb	r4, [r3, #0]
 458:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   myLidarLite.begin(0, false); // Set configuration to default and I2C to 100 kHz
 12256              		.loc 18 458 0
 12257 00b8 2146     		mov	r1, r4
 12258 00ba 2246     		mov	r2, r4
 12259 00bc 6223     		movs	r3, #98
 12260 00be FFF7FEFF 		bl	_ZN9LIDARLite5beginEibc
 479:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** myLidarLite.configure(0); // Change this number to try out alternate configurations
 12261              		.loc 18 479 0
 12262 00c2 0948     		ldr	r0, .L771+24
 12263 00c4 2146     		mov	r1, r4
 12264 00c6 6222     		movs	r2, #98
 12265              	.LBE327:
 480:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12266              		.loc 18 480 0
 12267 00c8 BDE81040 		pop	{r4, lr}
 12268              	.LBB328:
 479:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** myLidarLite.configure(0); // Change this number to try out alternate configurations
 12269              		.loc 18 479 0
 12270 00cc FFF7FEBF 		b	_ZN9LIDARLite9configureEic
 12271              	.L772:
 12272              		.align	2
 12273              	.L771:
 12274 00d0 00000000 		.word	Serial1
 12275 00d4 CDCC4C40 		.word	1078774989
 12276 00d8 00000000 		.word	.LANCHOR9
 12277 00dc 00000000 		.word	.LANCHOR13
 12278 00e0 00000000 		.word	.LANCHOR148
 12279 00e4 00000000 		.word	.LANCHOR124
 12280 00e8 00000000 		.word	.LANCHOR80
 12281              	.LBE328:
 12282              		.cfi_endproc
 12283              	.LFE274:
 12285              		.section	.text._Z16process100HzTaskv,"ax",%progbits
 12286              		.align	1
 12287              		.global	_Z16process100HzTaskv
 12288              		.thumb
 12289              		.thumb_func
 12291              	_Z16process100HzTaskv:
 12292              	.LFB275:
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
 12293              		.loc 18 485 0
 12294              		.cfi_startproc
 12295              		@ args = 0, pretend = 0, frame = 0
 12296              		@ frame_needed = 0, uses_anonymous_args = 0
 12297 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 12298              	.LCFI112:
 12299              		.cfi_def_cfa_offset 28
 12300              		.cfi_offset 14, -4
 12301              		.cfi_offset 9, -8
 12302              		.cfi_offset 8, -12
 12303              		.cfi_offset 7, -16
 12304              		.cfi_offset 6, -20
 12305              		.cfi_offset 5, -24
 12306              		.cfi_offset 4, -28
 12307              	.LBB329:
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12308              		.loc 18 487 0
 12309 0004 6E4B     		ldr	r3, .L785
 12310 0006 6F4C     		ldr	r4, .L785+4
 12311 0008 1868     		ldr	r0, [r3, #0]
 12312 000a 2268     		ldr	r2, [r4, #0]
 12313 000c 6E4F     		ldr	r7, .L785+8
 491:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateMetersPerSec();
 12314              		.loc 18 491 0
 12315 000e 6F4E     		ldr	r6, .L785+12
 12316 0010 6F4D     		ldr	r5, .L785+16
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12317              		.loc 18 487 0
 12318 0012 111A     		subs	r1, r2, r0
 12319 0014 00EE101A 		fmsr	s0, r1	@ int
 12320 0018 DFED6E7A 		flds	s15, .L785+20
 12321 001c B8EE407A 		fuitos	s14, s0
 12322              	.LBE329:
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
 12323              		.loc 18 485 0
 12324 0020 2DED048B 		fstmfdd	sp!, {d8, d9}
 12325              	.LCFI113:
 12326              		.cfi_def_cfa_offset 44
 12327              		.cfi_offset 82, -36
 12328              		.cfi_offset 80, -44
 12329              	.LBB331:
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12330              		.loc 18 487 0
 12331 0024 C7EE277A 		fdivs	s15, s14, s15
 12332              	.LBE331:
 485:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process100HzTask() {
 12333              		.loc 18 485 0
 12334 0028 85B0     		sub	sp, sp, #20
 12335              	.LCFI114:
 12336              		.cfi_def_cfa_offset 64
 12337              	.LBB332:
 488:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hundredHZpreviousTime = currentTime;
 12338              		.loc 18 488 0
 12339 002a 1A60     		str	r2, [r3, #0]
 493:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12340              		.loc 18 493 0
 12341 002c 0024     		movs	r4, #0
 487:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 12342              		.loc 18 487 0
 12343 002e C7ED007A 		fsts	s15, [r7, #0]
 490:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateGyroRate();
 12344              		.loc 18 490 0
 12345 0032 FFF7FEFF 		bl	_Z16evaluateGyroRatev
 491:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   evaluateMetersPerSec();
 12346              		.loc 18 491 0
 12347 0036 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 12348              	.LVL537:
 12349              	.L774:
 12350              	.LBB330:
 494:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 12351              		.loc 18 494 0 discriminator 2
 12352 003a 674A     		ldr	r2, .L785+24
 12353 003c 56F8040F 		ldr	r0, [r6, #4]!	@ float
 12354 0040 6301     		lsls	r3, r4, #5
 12355 0042 D118     		adds	r1, r2, r3
 12356 0044 FFF7FEFF 		bl	_Z18computeFourthOrderfP15fourthOrderData
 493:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12357              		.loc 18 493 0 discriminator 2
 12358 0048 0134     		adds	r4, r4, #1
 12359              	.LVL538:
 12360 004a 032C     		cmp	r4, #3
 494:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 12361              		.loc 18 494 0 discriminator 2
 12362 004c 45F8040F 		str	r0, [r5, #4]!	@ float
 493:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 12363              		.loc 18 493 0 discriminator 2
 12364 0050 F3D1     		bne	.L774
 12365              	.LBE330:
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   calculateKinematics(gyroRate[XAXIS], gyroRate[YAXIS], gyroRate[ZAXIS], filteredAccel[XAXIS], filt
 12366              		.loc 18 497 0
 12367 0052 624C     		ldr	r4, .L785+28
 12368              	.LVL539:
 12369 0054 624B     		ldr	r3, .L785+32
 12370 0056 D4F80480 		ldr	r8, [r4, #4]	@ float
 12371 005a CDF80080 		str	r8, [sp, #0]	@ float
 12372 005e A168     		ldr	r1, [r4, #8]	@ float
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     zVelocity = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + isq(fi
 12373              		.loc 18 500 0
 12374 0060 DFF8A881 		ldr	r8, .L785+76
 497:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   calculateKinematics(gyroRate[XAXIS], gyroRate[YAXIS], gyroRate[ZAXIS], filteredAccel[XAXIS], filt
 12375              		.loc 18 497 0
 12376 0064 0191     		str	r1, [sp, #4]	@ float
 12377 0066 3868     		ldr	r0, [r7, #0]	@ float
 12378 0068 0290     		str	r0, [sp, #8]	@ float
 12379 006a 5968     		ldr	r1, [r3, #4]	@ float
 12380 006c 9A68     		ldr	r2, [r3, #8]	@ float
 12381 006e 1868     		ldr	r0, [r3, #0]	@ float
 12382 0070 2368     		ldr	r3, [r4, #0]	@ float
 12383 0072 FFF7FEFF 		bl	_Z19calculateKinematicsfffffff
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     zVelocity = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + isq(fi
 12384              		.loc 18 500 0
 12385 0076 94ED006A 		flds	s12, [r4, #0]
 12386 007a FDEEC65A 		ftosizs	s11, s12
 12387 007e 98ED009A 		flds	s18, [r8, #0]
 12388 0082 15EE900A 		fmrs	r0, s11	@ int
 12389 0086 FFF7FEFF 		bl	_Z3isql
 12390 008a 94ED015A 		flds	s10, [r4, #4]
 12391 008e FDEEC54A 		ftosizs	s9, s10
 12392 0092 0746     		mov	r7, r0
 12393 0094 14EE900A 		fmrs	r0, s9	@ int
 12394 0098 FFF7FEFF 		bl	_Z3isql
 12395 009c 94ED028A 		flds	s16, [r4, #8]
 12396 00a0 BDEEC84A 		ftosizs	s8, s16
 12397 00a4 3E18     		adds	r6, r7, r0
 12398 00a6 14EE100A 		fmrs	r0, s8	@ int
 12399 00aa FFF7FEFF 		bl	_Z3isql
 12400 00ae 3518     		adds	r5, r6, r0
 12401 00b0 03EE905A 		fmsr	s7, r5	@ int
 12402 00b4 B8EEE33A 		fsitos	s6, s7
 12403 00b8 F7EE008A 		fconsts	s17, #112
 12404 00bc 13EE100A 		fmrs	r0, s6
 12405 00c0 FFF7FEFF 		bl	_Z7invSqrtf
 12406 00c4 02EE900A 		fmsr	s5, r0
 12407 00c8 B0EE682A 		fcpys	s4, s17
 12408 00cc 09EE622A 		fnmacs	s4, s18, s5
 12409 00d0 444F     		ldr	r7, .L785+36
 12410 00d2 454E     		ldr	r6, .L785+40
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (!runtimaZBiasInitialized) {
 12411              		.loc 18 501 0
 12412 00d4 454D     		ldr	r5, .L785+44
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     zVelocity = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + isq(fi
 12413              		.loc 18 500 0
 12414 00d6 464A     		ldr	r2, .L785+48
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (!runtimaZBiasInitialized) {
 12415              		.loc 18 501 0
 12416 00d8 2978     		ldrb	r1, [r5, #0]	@ zero_extendqisi2
 500:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     zVelocity = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + isq(fi
 12417              		.loc 18 500 0
 12418 00da 97ED021A 		flds	s2, [r7, #8]
 12419 00de 18EE021A 		fmscs	s2, s16, s4
 12420 00e2 D6ED001A 		flds	s3, [r6, #0]
 12421 00e6 71EE610A 		fsubs	s1, s2, s3
 12422 00ea 9146     		mov	r9, r2
 12423 00ec C2ED000A 		fsts	s1, [r2, #0]
 501:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (!runtimaZBiasInitialized) {
 12424              		.loc 18 501 0
 12425 00f0 89BB     		cbnz	r1, .L775
 502:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimeZBias = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + i
 12426              		.loc 18 502 0
 12427 00f2 94ED002A 		flds	s4, [r4, #0]
 12428 00f6 FDEEC21A 		ftosizs	s3, s4
 12429 00fa 98ED009A 		flds	s18, [r8, #0]
 12430 00fe 11EE900A 		fmrs	r0, s3	@ int
 12431 0102 FFF7FEFF 		bl	_Z3isql
 12432 0106 94ED011A 		flds	s2, [r4, #4]
 12433 010a BDEEC18A 		ftosizs	s16, s2
 12434 010e 8046     		mov	r8, r0
 12435 0110 18EE100A 		fmrs	r0, s16	@ int
 12436 0114 FFF7FEFF 		bl	_Z3isql
 12437 0118 94ED028A 		flds	s16, [r4, #8]
 12438 011c FDEEC80A 		ftosizs	s1, s16
 12439 0120 8044     		add	r8, r8, r0
 12440 0122 10EE900A 		fmrs	r0, s1	@ int
 12441 0126 FFF7FEFF 		bl	_Z3isql
 12442 012a 08EB0003 		add	r3, r8, r0
 12443 012e 00EE103A 		fmsr	s0, r3	@ int
 12444 0132 B8EEC07A 		fsitos	s14, s0
 12445 0136 17EE100A 		fmrs	r0, s14
 12446 013a FFF7FEFF 		bl	_Z7invSqrtf
 12447 013e 07EE900A 		fmsr	s15, r0
 12448 0142 49EE678A 		fnmacs	s17, s18, s15
 12449 0146 D7ED026A 		flds	s13, [r7, #8]
 12450 014a 58EE286A 		fmscs	s13, s16, s17
 503:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimaZBiasInitialized = true;
 12451              		.loc 18 503 0
 12452 014e 0122     		movs	r2, #1
 502:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimeZBias = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS]) + i
 12453              		.loc 18 502 0
 12454 0150 C6ED006A 		fsts	s13, [r6, #0]
 503:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       runtimaZBiasInitialized = true;
 12455              		.loc 18 503 0
 12456 0154 2A70     		strb	r2, [r5, #0]
 12457              	.L775:
 506:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity = (velocityCompFilter1 * zVelocity) + (velocityCompFilter2 * estimatedZVeloc
 12458              		.loc 18 506 0
 12459 0156 2749     		ldr	r1, .L785+52
 12460 0158 274A     		ldr	r2, .L785+56
 12461 015a 284B     		ldr	r3, .L785+60
 505:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity += zVelocity;
 12462              		.loc 18 505 0
 12463 015c 99ED005A 		flds	s10, [r9, #0]
 12464 0160 91ED006A 		flds	s12, [r1, #0]
 506:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity = (velocityCompFilter1 * zVelocity) + (velocityCompFilter2 * estimatedZVeloc
 12465              		.loc 18 506 0
 12466 0164 92ED004A 		flds	s8, [r2, #0]
 505:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity += zVelocity;
 12467              		.loc 18 505 0
 12468 0168 75EE065A 		fadds	s11, s10, s12
 506:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     estimatedZVelocity = (velocityCompFilter1 * zVelocity) + (velocityCompFilter2 * estimatedZVeloc
 12469              		.loc 18 506 0
 12470 016c D3ED004A 		flds	s9, [r3, #0]
 12471 0170 25EE844A 		fmuls	s8, s11, s8
 12472 0174 05EE244A 		fmacs	s8, s10, s9
 12473 0178 81ED004A 		fsts	s8, [r1, #0]
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         estimatedAltitude = alt_read();
 12474              		.loc 18 510 0
 12475 017c FFF7FEFF 		bl	_Z8alt_readv
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         if((estimatedAltitude-prevAltitude)>0){  //up motion
 12476              		.loc 18 512 0
 12477 0180 1F4B     		ldr	r3, .L785+64
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         estimatedAltitude = alt_read();
 12478              		.loc 18 510 0
 12479 0182 03EE900A 		fmsr	s7, r0	@ int
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         if((estimatedAltitude-prevAltitude)>0){  //up motion
 12480              		.loc 18 512 0
 12481 0186 93ED003A 		flds	s6, [r3, #0]
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         estimatedAltitude = alt_read();
 12482              		.loc 18 510 0
 12483 018a F8EEE37A 		fsitos	s15, s7
 12484 018e 1D48     		ldr	r0, .L785+68
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         if((estimatedAltitude-prevAltitude)>0){  //up motion
 12485              		.loc 18 512 0
 12486 0190 77EEC32A 		fsubs	s5, s15, s6
 510:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         estimatedAltitude = alt_read();
 12487              		.loc 18 510 0
 12488 0194 C0ED007A 		fsts	s15, [r0, #0]
 512:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         if((estimatedAltitude-prevAltitude)>0){  //up motion
 12489              		.loc 18 512 0
 12490 0198 F5EEC02A 		fcmpezs	s5
 12491 019c F1EE10FA 		fmstat
 12492 01a0 01DD     		ble	.L783
 513:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           zDirection = 1;
 12493              		.loc 18 513 0
 12494 01a2 0121     		movs	r1, #1
 12495 01a4 01E0     		b	.L784
 12496              	.L783:
 515:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         else if ((estimatedAltitude-prevAltitude)<0){  //down motion
 12497              		.loc 18 515 0
 12498 01a6 02D5     		bpl	.L778
 516:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****           zDirection =0;
 12499              		.loc 18 516 0
 12500 01a8 0021     		movs	r1, #0
 12501              	.L784:
 12502 01aa 1748     		ldr	r0, .L785+72
 12503 01ac 0170     		strb	r1, [r0, #0]
 12504              	.L778:
 518:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****         prevAltitude=estimatedAltitude;
 12505              		.loc 18 518 0
 12506 01ae C3ED007A 		fsts	s15, [r3, #0]
 12507              	.LBE332:
 551:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12508              		.loc 18 551 0
 12509 01b2 05B0     		add	sp, sp, #20
 12510 01b4 BDEC048B 		fldmfdd	sp!, {d8, d9}
 12511 01b8 BDE8F043 		pop	{r4, r5, r6, r7, r8, r9, lr}
 12512              	.LBB333:
 526:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   processFlightControl();
 12513              		.loc 18 526 0
 12514 01bc FFF7FEBF 		b	_Z20processFlightControlv
 12515              	.L786:
 12516              		.align	2
 12517              	.L785:
 12518 01c0 00000000 		.word	.LANCHOR149
 12519 01c4 00000000 		.word	.LANCHOR7
 12520 01c8 00000000 		.word	.LANCHOR48
 12521 01cc FCFFFFFF 		.word	.LANCHOR26-4
 12522 01d0 FCFFFFFF 		.word	.LANCHOR145-4
 12523 01d4 00247449 		.word	1232348160
 12524 01d8 00000000 		.word	.LANCHOR10
 12525 01dc 00000000 		.word	.LANCHOR145
 12526 01e0 00000000 		.word	.LANCHOR19
 12527 01e4 00000000 		.word	.LANCHOR28
 12528 01e8 00000000 		.word	.LANCHOR151
 12529 01ec 00000000 		.word	.LANCHOR152
 12530 01f0 00000000 		.word	.LANCHOR150
 12531 01f4 00000000 		.word	.LANCHOR105
 12532 01f8 00000000 		.word	.LANCHOR154
 12533 01fc 00000000 		.word	.LANCHOR153
 12534 0200 00000000 		.word	.LANCHOR155
 12535 0204 00000000 		.word	.LANCHOR100
 12536 0208 00000000 		.word	.LANCHOR101
 12537 020c 00000000 		.word	.LANCHOR31
 12538              	.LBE333:
 12539              		.cfi_endproc
 12540              	.LFE275:
 12542              		.section	.text._Z15process50HzTaskv,"ax",%progbits
 12543              		.align	1
 12544              		.global	_Z15process50HzTaskv
 12545              		.thumb
 12546              		.thumb_func
 12548              	_Z15process50HzTaskv:
 12549              	.LFB276:
 556:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process50HzTask() {
 12550              		.loc 18 556 0
 12551              		.cfi_startproc
 12552              		@ args = 0, pretend = 0, frame = 0
 12553              		@ frame_needed = 0, uses_anonymous_args = 0
 12554              		@ link register save eliminated.
 557:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 12555              		.loc 18 557 0
 12556 0000 094B     		ldr	r3, .L788
 12557 0002 0A4A     		ldr	r2, .L788+4
 12558 0004 1968     		ldr	r1, [r3, #0]
 12559 0006 1268     		ldr	r2, [r2, #0]
 12560 0008 501A     		subs	r0, r2, r1
 12561 000a 00EE100A 		fmsr	s0, r0	@ int
 12562 000e DFED087A 		flds	s15, .L788+8
 12563 0012 B8EE407A 		fuitos	s14, s0
 12564 0016 0749     		ldr	r1, .L788+12
 558:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   fiftyHZpreviousTime = currentTime;
 12565              		.loc 18 558 0
 12566 0018 1A60     		str	r2, [r3, #0]
 557:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 12567              		.loc 18 557 0
 12568 001a C7EE277A 		fdivs	s15, s14, s15
 12569 001e C1ED007A 		fsts	s15, [r1, #0]
 576:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12570              		.loc 18 576 0
 561:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readPilotCommands(); 
 12571              		.loc 18 561 0
 12572 0022 FFF7FEBF 		b	_Z17readPilotCommandsv
 12573              	.L789:
 12574 0026 00BF     		.align	2
 12575              	.L788:
 12576 0028 00000000 		.word	.LANCHOR156
 12577 002c 00000000 		.word	.LANCHOR7
 12578 0030 00247449 		.word	1232348160
 12579 0034 00000000 		.word	.LANCHOR48
 12580              		.cfi_endproc
 12581              	.LFE276:
 12583              		.section	.text._Z16process10HzTask1v,"ax",%progbits
 12584              		.align	1
 12585              		.global	_Z16process10HzTask1v
 12586              		.thumb
 12587              		.thumb_func
 12589              	_Z16process10HzTask1v:
 12590              	.LFB277:
 581:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask1() {
 12591              		.loc 18 581 0
 12592              		.cfi_startproc
 12593              		@ args = 0, pretend = 0, frame = 0
 12594              		@ frame_needed = 0, uses_anonymous_args = 0
 12595 0000 10B5     		push	{r4, lr}
 12596              	.LCFI115:
 12597              		.cfi_def_cfa_offset 8
 12598              		.cfi_offset 14, -4
 12599              		.cfi_offset 4, -8
 605:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_XRaw = distance2D[plus_X];
 12600              		.loc 18 605 0
 12601 0002 274C     		ldr	r4, .L795
 596:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   Hokuyo_Read();
 12602              		.loc 18 596 0
 12603 0004 FFF7FEFF 		bl	_Z11Hokuyo_Readv
 605:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_XRaw = distance2D[plus_X];
 12604              		.loc 18 605 0
 12605 0008 264B     		ldr	r3, .L795+4
 12606 000a 2268     		ldr	r2, [r4, #0]
 606:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_YRaw = distance2D[plus_Y];
 12607              		.loc 18 606 0
 12608 000c 2649     		ldr	r1, .L795+8
 605:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_XRaw = distance2D[plus_X];
 12609              		.loc 18 605 0
 12610 000e 1A60     		str	r2, [r3, #0]
 606:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   hokuyo_YRaw = distance2D[plus_Y];
 12611              		.loc 18 606 0
 12612 0010 6368     		ldr	r3, [r4, #4]
 12613 0012 0B60     		str	r3, [r1, #0]
 12614 0014 2549     		ldr	r1, .L795+12
 607:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if(distance2D[plus_X] !=0){
 12615              		.loc 18 607 0
 12616 0016 0AB1     		cbz	r2, .L791
 608:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     LastNonZeroRoll = distance2D[plus_X];
 12617              		.loc 18 608 0
 12618 0018 0A60     		str	r2, [r1, #0]
 12619 001a 01E0     		b	.L792
 12620              	.L791:
 611:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     distance2D[plus_X] =LastNonZeroRoll;
 12621              		.loc 18 611 0
 12622 001c 0A68     		ldr	r2, [r1, #0]
 12623 001e 2260     		str	r2, [r4, #0]
 12624              	.L792:
 12625 0020 234A     		ldr	r2, .L795+16
 614:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if(distance2D[plus_Y] !=0){
 12626              		.loc 18 614 0
 12627 0022 0BB1     		cbz	r3, .L793
 615:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     LastNonZeroPitch = distance2D[plus_Y];
 12628              		.loc 18 615 0
 12629 0024 1360     		str	r3, [r2, #0]
 12630 0026 01E0     		b	.L794
 12631              	.L793:
 618:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     distance2D[plus_Y] =LastNonZeroPitch;
 12632              		.loc 18 618 0
 12633 0028 1068     		ldr	r0, [r2, #0]
 12634 002a 6060     		str	r0, [r4, #4]
 12635              	.L794:
 620:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_X] =kal_hokuyoX(distance2D[plus_X]);  //roll
 12636              		.loc 18 620 0
 12637 002c 2068     		ldr	r0, [r4, #0]
 12638 002e FFF7FEFF 		bl	_Z11kal_hokuyoXl
 12639 0032 03EE900A 		fmsr	s7, r0
 12640 0036 BDEEE33A 		ftosizs	s6, s7
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_Y] =kal_hokuyoY(distance2D[plus_Y]);  //pitch
 12641              		.loc 18 621 0
 12642 003a 6068     		ldr	r0, [r4, #4]
 620:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_X] =kal_hokuyoX(distance2D[plus_X]);  //roll
 12643              		.loc 18 620 0
 12644 003c 84ED003A 		fsts	s6, [r4, #0]	@ int
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_Y] =kal_hokuyoY(distance2D[plus_Y]);  //pitch
 12645              		.loc 18 621 0
 12646 0040 FFF7FEFF 		bl	_Z11kal_hokuyoYl
 622:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_X] - prevRoll)>0){
 12647              		.loc 18 622 0
 12648 0044 2268     		ldr	r2, [r4, #0]
 623:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     RollVelocityDirection = 0;    //in -ve X(roll)
 12649              		.loc 18 623 0
 12650 0046 1B49     		ldr	r1, .L795+20
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_Y] =kal_hokuyoY(distance2D[plus_Y]);  //pitch
 12651              		.loc 18 621 0
 12652 0048 02EE900A 		fmsr	s5, r0
 622:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_X] - prevRoll)>0){
 12653              		.loc 18 622 0
 12654 004c 02EE102A 		fmsr	s4, r2	@ int
 12655 0050 1948     		ldr	r0, .L795+24
 631:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PitchVelocityDirection = 0;  //in  -ve Y(pitch)
 12656              		.loc 18 631 0
 12657 0052 1A4A     		ldr	r2, .L795+28
 622:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_X] - prevRoll)>0){
 12658              		.loc 18 622 0
 12659 0054 B8EEC21A 		fsitos	s2, s4
 12660 0058 D0ED001A 		flds	s3, [r0, #0]
 12661 005c 71EE616A 		fsubs	s13, s2, s3
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_Y] =kal_hokuyoY(distance2D[plus_Y]);  //pitch
 12662              		.loc 18 621 0
 12663 0060 FDEEE20A 		ftosizs	s1, s5
 622:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_X] - prevRoll)>0){
 12664              		.loc 18 622 0
 12665 0064 F5EEC06A 		fcmpezs	s13
 12666 0068 F1EE10FA 		fmstat
 623:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     RollVelocityDirection = 0;    //in -ve X(roll)
 12667              		.loc 18 623 0
 12668 006c CCBF     		ite	gt
 12669 006e 0023     		movgt	r3, #0
 12670 0070 0123     		movle	r3, #1
 12671 0072 0B60     		str	r3, [r1, #0]
 630:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_Y]-prevPitch)>0){
 12672              		.loc 18 630 0
 12673 0074 124B     		ldr	r3, .L795+32
 12674 0076 F8EEE07A 		fsitos	s15, s1
 12675 007a 93ED000A 		flds	s0, [r3, #0]
 12676 007e 37EEC07A 		fsubs	s14, s15, s0
 621:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   distance2D[plus_Y] =kal_hokuyoY(distance2D[plus_Y]);  //pitch
 12677              		.loc 18 621 0
 12678 0082 C4ED010A 		fsts	s1, [r4, #4]	@ int
 630:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if((distance2D[plus_Y]-prevPitch)>0){
 12679              		.loc 18 630 0
 12680 0086 B5EEC07A 		fcmpezs	s14
 12681 008a F1EE10FA 		fmstat
 631:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PitchVelocityDirection = 0;  //in  -ve Y(pitch)
 12682              		.loc 18 631 0
 12683 008e CCBF     		ite	gt
 12684 0090 0021     		movgt	r1, #0
 12685 0092 0121     		movle	r1, #1
 628:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   prevRoll = distance2D[plus_X];
 12686              		.loc 18 628 0
 12687 0094 80ED001A 		fsts	s2, [r0, #0]
 631:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     PitchVelocityDirection = 0;  //in  -ve Y(pitch)
 12688              		.loc 18 631 0
 12689 0098 1160     		str	r1, [r2, #0]
 636:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   prevPitch = distance2D[plus_Y];
 12690              		.loc 18 636 0
 12691 009a C3ED007A 		fsts	s15, [r3, #0]
 647:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12692              		.loc 18 647 0
 12693 009e 10BD     		pop	{r4, pc}
 12694              	.L796:
 12695              		.align	2
 12696              	.L795:
 12697 00a0 00000000 		.word	.LANCHOR84
 12698 00a4 00000000 		.word	.LANCHOR147
 12699 00a8 00000000 		.word	.LANCHOR146
 12700 00ac 00000000 		.word	.LANCHOR157
 12701 00b0 00000000 		.word	.LANCHOR158
 12702 00b4 00000000 		.word	.LANCHOR112
 12703 00b8 00000000 		.word	.LANCHOR159
 12704 00bc 00000000 		.word	.LANCHOR118
 12705 00c0 00000000 		.word	.LANCHOR160
 12706              		.cfi_endproc
 12707              	.LFE277:
 12709              		.section	.text._Z16process10HzTask2v,"ax",%progbits
 12710              		.align	1
 12711              		.global	_Z16process10HzTask2v
 12712              		.thumb
 12713              		.thumb_func
 12715              	_Z16process10HzTask2v:
 12716              	.LFB278:
 652:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask2() {
 12717              		.loc 18 652 0
 12718              		.cfi_startproc
 12719              		@ args = 0, pretend = 0, frame = 0
 12720              		@ frame_needed = 0, uses_anonymous_args = 0
 12721 0000 08B5     		push	{r3, lr}
 12722              	.LCFI116:
 12723              		.cfi_def_cfa_offset 8
 12724              		.cfi_offset 14, -4
 12725              		.cfi_offset 3, -8
 653:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12726              		.loc 18 653 0
 12727 0002 0B4A     		ldr	r2, .L798
 12728 0004 0B4B     		ldr	r3, .L798+4
 12729 0006 1268     		ldr	r2, [r2, #0]
 12730 0008 1968     		ldr	r1, [r3, #0]
 654:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   lowPriorityTenHZpreviousTime = currentTime;
 12731              		.loc 18 654 0
 12732 000a 1A60     		str	r2, [r3, #0]
 653:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 12733              		.loc 18 653 0
 12734 000c 501A     		subs	r0, r2, r1
 12735 000e 00EE100A 		fmsr	s0, r0	@ int
 12736 0012 DFED097A 		flds	s15, .L798+8
 12737 0016 B8EE407A 		fuitos	s14, s0
 12738 001a 0849     		ldr	r1, .L798+12
 12739 001c C7EE277A 		fdivs	s15, s14, s15
 12740 0020 C1ED007A 		fsts	s15, [r1, #0]
 661:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   readSerialCommand();
 12741              		.loc 18 661 0
 12742 0024 FFF7FEFF 		bl	_Z17readSerialCommandv
 663:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12743              		.loc 18 663 0
 12744 0028 BDE80840 		pop	{r3, lr}
 662:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   sendSerialTelemetry();
 12745              		.loc 18 662 0
 12746 002c FFF7FEBF 		b	_Z19sendSerialTelemetryv
 12747              	.L799:
 12748              		.align	2
 12749              	.L798:
 12750 0030 00000000 		.word	.LANCHOR7
 12751 0034 00000000 		.word	.LANCHOR161
 12752 0038 00247449 		.word	1232348160
 12753 003c 00000000 		.word	.LANCHOR48
 12754              		.cfi_endproc
 12755              	.LFE278:
 12757              		.section	.text._Z16process10HzTask3v,"ax",%progbits
 12758              		.align	1
 12759              		.global	_Z16process10HzTask3v
 12760              		.thumb
 12761              		.thumb_func
 12763              	_Z16process10HzTask3v:
 12764              	.LFB279:
 668:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process10HzTask3() {
 12765              		.loc 18 668 0
 12766              		.cfi_startproc
 12767              		@ args = 0, pretend = 0, frame = 0
 12768              		@ frame_needed = 0, uses_anonymous_args = 0
 12769              		@ link register save eliminated.
 669:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 12770              		.loc 18 669 0
 12771 0000 084B     		ldr	r3, .L801
 12772 0002 094A     		ldr	r2, .L801+4
 12773 0004 1968     		ldr	r1, [r3, #0]
 12774 0006 1268     		ldr	r2, [r2, #0]
 12775 0008 501A     		subs	r0, r2, r1
 12776 000a 00EE100A 		fmsr	s0, r0	@ int
 12777 000e DFED077A 		flds	s15, .L801+8
 12778 0012 B8EE407A 		fuitos	s14, s0
 12779 0016 0649     		ldr	r1, .L801+12
 670:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     lowPriorityTenHZpreviousTime2 = currentTime;
 12780              		.loc 18 670 0
 12781 0018 1A60     		str	r2, [r3, #0]
 669:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 12782              		.loc 18 669 0
 12783 001a C7EE277A 		fdivs	s15, s14, s15
 12784 001e C1ED007A 		fsts	s15, [r1, #0]
 687:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12785              		.loc 18 687 0
 12786 0022 7047     		bx	lr
 12787              	.L802:
 12788              		.align	2
 12789              	.L801:
 12790 0024 00000000 		.word	.LANCHOR162
 12791 0028 00000000 		.word	.LANCHOR7
 12792 002c 00247449 		.word	1232348160
 12793 0030 00000000 		.word	.LANCHOR48
 12794              		.cfi_endproc
 12795              	.LFE279:
 12797              		.section	.text._Z14process1HzTaskv,"ax",%progbits
 12798              		.align	1
 12799              		.global	_Z14process1HzTaskv
 12800              		.thumb
 12801              		.thumb_func
 12803              	_Z14process1HzTaskv:
 12804              	.LFB280:
 692:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void process1HzTask() {
 12805              		.loc 18 692 0
 12806              		.cfi_startproc
 12807              		@ args = 0, pretend = 0, frame = 0
 12808              		@ frame_needed = 0, uses_anonymous_args = 0
 12809              		@ link register save eliminated.
 699:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** }
 12810              		.loc 18 699 0
 12811 0000 7047     		bx	lr
 12812              		.cfi_endproc
 12813              	.LFE280:
 12815              		.section	.text._Z4loopv,"ax",%progbits
 12816              		.align	1
 12817              		.global	_Z4loopv
 12818              		.thumb
 12819              		.thumb_func
 12821              	_Z4loopv:
 12822              	.LFB281:
 704:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino **** void loop () {
 12823              		.loc 18 704 0
 12824              		.cfi_startproc
 12825              		@ args = 0, pretend = 0, frame = 0
 12826              		@ frame_needed = 0, uses_anonymous_args = 0
 12827 0000 70B5     		push	{r4, r5, r6, lr}
 12828              	.LCFI117:
 12829              		.cfi_def_cfa_offset 16
 12830              		.cfi_offset 14, -4
 12831              		.cfi_offset 6, -8
 12832              		.cfi_offset 5, -12
 12833              		.cfi_offset 4, -16
 706:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 12834              		.loc 18 706 0
 12835 0002 204C     		ldr	r4, .L811
 705:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 12836              		.loc 18 705 0
 12837 0004 204D     		ldr	r5, .L811+4
 706:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 12838              		.loc 18 706 0
 12839 0006 214E     		ldr	r6, .L811+8
 705:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 12840              		.loc 18 705 0
 12841 0008 FFF7FEFF 		bl	_ZL6microsv
 706:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 12842              		.loc 18 706 0
 12843 000c 2168     		ldr	r1, [r4, #0]
 705:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   currentTime = micros();
 12844              		.loc 18 705 0
 12845 000e 2860     		str	r0, [r5, #0]
 706:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 12846              		.loc 18 706 0
 12847 0010 401A     		subs	r0, r0, r1
 12848 0012 3060     		str	r0, [r6, #0]
 708:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   measureCriticalSensors();
 12849              		.loc 18 708 0
 12850 0014 FFF7FEFF 		bl	_Z22measureCriticalSensorsv
 713:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (deltaTime >= 10000) {
 12851              		.loc 18 713 0
 12852 0018 3268     		ldr	r2, [r6, #0]
 12853 001a 42F20F73 		movw	r3, #9999
 12854 001e 9A42     		cmp	r2, r3
 12855 0020 2646     		mov	r6, r4
 12856 0022 1B4C     		ldr	r4, .L811+12
 12857 0024 27D9     		bls	.L805
 715:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     frameCounter++;
 12858              		.loc 18 715 0
 12859 0026 2068     		ldr	r0, [r4, #0]
 12860 0028 431C     		adds	r3, r0, #1
 12861 002a 2360     		str	r3, [r4, #0]
 717:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     process100HzTask();
 12862              		.loc 18 717 0
 12863 002c FFF7FEFF 		bl	_Z16process100HzTaskv
 722:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
 12864              		.loc 18 722 0
 12865 0030 2268     		ldr	r2, [r4, #0]
 12866 0032 D007     		lsls	r0, r2, #31
 12867 0034 01D4     		bmi	.L806
 723:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process50HzTask();
 12868              		.loc 18 723 0
 12869 0036 FFF7FEFF 		bl	_Z15process50HzTaskv
 12870              	.L806:
 729:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
 12871              		.loc 18 729 0
 12872 003a 2268     		ldr	r2, [r4, #0]
 12873 003c 0A23     		movs	r3, #10
 12874 003e B2FBF3F0 		udiv	r0, r2, r3
 12875 0042 03FB1021 		mls	r1, r3, r0, r2
 12876 0046 11B9     		cbnz	r1, .L807
 730:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask1();
 12877              		.loc 18 730 0
 12878 0048 FFF7FEFF 		bl	_Z16process10HzTask1v
 12879 004c 11E0     		b	.L808
 12880              	.L807:
 732:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
 12881              		.loc 18 732 0
 12882 004e 114B     		ldr	r3, .L811+16
 12883 0050 2A68     		ldr	r2, [r5, #0]
 12884 0052 1968     		ldr	r1, [r3, #0]
 12885 0054 104B     		ldr	r3, .L811+20
 12886 0056 C1EB020C 		rsb	ip, r1, r2
 12887 005a 9C45     		cmp	ip, r3
 12888 005c 02D9     		bls	.L809
 733:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask2();
 12889              		.loc 18 733 0
 12890 005e FFF7FEFF 		bl	_Z16process10HzTask2v
 12891 0062 06E0     		b	.L808
 12892              	.L809:
 735:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
 12893              		.loc 18 735 0
 12894 0064 0D48     		ldr	r0, .L811+24
 12895 0066 0168     		ldr	r1, [r0, #0]
 12896 0068 501A     		subs	r0, r2, r1
 12897 006a 9842     		cmp	r0, r3
 12898 006c 01D9     		bls	.L808
 736:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       process10HzTask3();
 12899              		.loc 18 736 0
 12900 006e FFF7FEFF 		bl	_Z16process10HzTask3v
 12901              	.L808:
 746:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****     previousTime = currentTime;
 12902              		.loc 18 746 0
 12903 0072 2A68     		ldr	r2, [r5, #0]
 12904 0074 3260     		str	r2, [r6, #0]
 12905              	.L805:
 749:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****   if (frameCounter >= 100) {
 12906              		.loc 18 749 0
 12907 0076 2368     		ldr	r3, [r4, #0]
 12908 0078 632B     		cmp	r3, #99
 12909 007a 02D9     		bls	.L804
 750:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.ino ****       frameCounter = 0;
 12910              		.loc 18 750 0
 12911 007c 0448     		ldr	r0, .L811+12
 12912 007e 0021     		movs	r1, #0
 12913 0080 0160     		str	r1, [r0, #0]
 12914              	.L804:
 12915 0082 70BD     		pop	{r4, r5, r6, pc}
 12916              	.L812:
 12917              		.align	2
 12918              	.L811:
 12919 0084 00000000 		.word	.LANCHOR148
 12920 0088 00000000 		.word	.LANCHOR7
 12921 008c 00000000 		.word	.LANCHOR163
 12922 0090 00000000 		.word	.LANCHOR137
 12923 0094 00000000 		.word	.LANCHOR161
 12924 0098 A0860100 		.word	100000
 12925 009c 00000000 		.word	.LANCHOR162
 12926              		.cfi_endproc
 12927              	.LFE281:
 12929              		.section	.text.startup.main,"ax",%progbits
 12930              		.align	1
 12931              		.global	main
 12932              		.thumb
 12933              		.thumb_func
 12935              	main:
 12936              	.LFB116:
  11:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** }
  12:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
  13:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** // Uncomment this if compiling on OS X
  14:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** /*extern "C"{
  15:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 	void _init(){}; // dummy _init function for support of GNU toolchain from https://launchpad.net/gc
  16:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** }*/
  17:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
  18:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** int main(void)
  19:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** {
 12937              		.loc 4 19 0
 12938              		.cfi_startproc
 12939              		@ args = 0, pretend = 0, frame = 0
 12940              		@ frame_needed = 0, uses_anonymous_args = 0
 12941 0000 08B5     		push	{r3, lr}
 12942              	.LCFI118:
 12943              		.cfi_def_cfa_offset 8
 12944              		.cfi_offset 14, -4
 12945              		.cfi_offset 3, -8
  20:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 	//init();
  21:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp ****   	setup();
 12946              		.loc 4 21 0
 12947 0002 FFF7FEFF 		bl	_Z5setupv
 12948              	.L814:
  22:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 
  23:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 	for (;;)
  24:/home/asim/AeroQuad/AeroQuad32/AeroQuadMain.cpp **** 		loop();
 12949              		.loc 4 24 0 discriminator 1
 12950 0006 FFF7FEFF 		bl	_Z4loopv
 12951 000a FCE7     		b	.L814
 12952              		.cfi_endproc
 12953              	.LFE116:
 12955              		.section	.text.startup._GLOBAL__sub_I__Z7premainv,"ax",%progbits
 12956              		.align	1
 12957              		.thumb
 12958              		.thumb_func
 12960              	_GLOBAL__sub_I__Z7premainv:
 12961              	.LFB283:
 12962              		.loc 18 752 0
 12963              		.cfi_startproc
 12964              		@ args = 0, pretend = 0, frame = 0
 12965              		@ frame_needed = 0, uses_anonymous_args = 0
 12966              	.LVL540:
 12967              	.LBB336:
 12968              	.LBB337:
 12969              		.file 35 "/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h"
   1:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /*
   2:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   AeroQuad v3.0.1 - February 2012
   3:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   www.AeroQuad.com
   4:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   An Open Source Arduino based multicopter.
   6:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  
   7:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   This program is free software: you can redistribute it and/or modify 
   8:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   it under the terms of the GNU General Public License as published by 
   9:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   (at your option) any later version. 
  11:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  12:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   This program is distributed in the hope that it will be useful, 
  13:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   GNU General Public License for more details. 
  16:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  17:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   You should have received a copy of the GNU General Public License 
  18:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** */
  20:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  21:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #ifndef _AQ_GLOBAL_HEADER_DEFINITION_H_
  22:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define _AQ_GLOBAL_HEADER_DEFINITION_H_
  23:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  24:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  25:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include <stdlib.h>
  26:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include <math.h>
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include "Arduino.h"
  28:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include "pins_arduino.h"
  29:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include "GpsDataType.h"
  30:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include "AQMath.h"
  31:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #include "Receiver.h"
  32:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  33:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // Flight Software Version
  34:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SOFTWARE_VERSION 3.2
  35:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  36:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #if defined CONFIG_BAUDRATE
  37:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #define BAUD CONFIG_BAUDRATE
  38:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #else
  39:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #if defined WirelessTelemetry && !defined MavLink
  40:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****     #define BAUD 111111 // use this to be compatible with USB and XBee connections
  41:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #else
  42:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****     #define BAUD 115200
  43:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #endif
  44:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #endif  
  45:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  46:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /**
  47:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  * ESC calibration process global declaration
  48:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  */
  49:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte calibrateESC = 0;
  50:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int testCommand = 1000;
  51:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////////////////////////////////
  52:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////HOKUYO TESTING///////////////
  53:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int hokuyo_XRaw =0;   //roll
  54:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int hokuyo_YRaw =0;  //pitch
  55:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int count =0;
  56:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /**
  57:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  * Flight control global declaration
  58:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  */
  59:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define RATE_FLIGHT_MODE 0
  60:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define ATTITUDE_FLIGHT_MODE 1
  61:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //byte previousFlightMode = ATTITUDE_FLIGHT_MODE;
  62:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte previousFlightMode = RATE_FLIGHT_MODE;
  63:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define TASK_100HZ 1
  64:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define TASK_50HZ 2
  65:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define TASK_10HZ 10
  66:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define TASK_1HZ 100
  67:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define THROTTLE_ADJUST_TASK_SPEED TASK_50HZ
  68:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define HOKUYO_TASK_SPEED TASK_10HZ
  69:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  70:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //byte flightMode = RATE_FLIGHT_MODE;
  71:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte flightMode = ATTITUDE_FLIGHT_MODE;
  72:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long frameCounter = 0; // main loop executive frame counter
  73:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int minArmedThrottle; // initial value configured by user
  74:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  75:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float G_Dt = 0.002; 
  76:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int throttle = 1000;
  77:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte motorArmed = OFF;
  78:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte safetyCheck = OFF;
  79:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte maxLimit = OFF;
  80:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte minLimit = OFF;
  81:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float filteredAccel[3] = {0.0,0.0,0.0};
  82:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** boolean inFlight = false; // true when motor are armed and that the user pass one time the min thro
  83:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float rotationSpeedFactor = 1.0;
  84:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  85:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // main loop time variable
  86:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long previousTime = 0;
  87:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long currentTime = 0;
  88:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long deltaTime = 0;
  89:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // sub loop time variable
  90:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long oneHZpreviousTime = 0;
  91:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long tenHZpreviousTime = 0;
  92:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long lowPriorityTenHZpreviousTime = 0;
  93:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long lowPriorityTenHZpreviousTime2 = 0;
  94:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long fiftyHZpreviousTime = 0;
  95:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** unsigned long hundredHZpreviousTime = 0;
  96:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  97:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
  98:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //******************test Variables*****************
  99:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int altitudeHoldThrottleCorrectionGLOBAL =0;
 100:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //*************************************************
 101:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////////////////////////////////
 102:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 103:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 104:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // Analog Reference Value
 105:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // This value provided from Configurator
 106:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // Use a DMM to measure the voltage between AREF and GND
 107:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // Enter the measured voltage below to define your value for aref
 108:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // If you don't have a DMM use the following:
 109:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // AeroQuad Shield v1.7, aref = 3.0
 110:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** // AeroQuad Shield v1.6 or below, aref = 2.8
 111:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float aref; // Read in from EEPROM
 112:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////////////////////////////////
 113:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 114:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /**
 115:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  * Heading and heading hold global declaration section
 116:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  */
 117:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  
 118:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte  headingHoldConfig   = 0;
 119:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float headingHold         = 0; // calculated adjustment for quad to go to heading (PID output)
 120:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float heading             = 0; // measured heading from yaw gyro (process variable)
 121:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float relativeHeading     = 0; // current heading the quad is set to (set point)
 122:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////// Lidar-1D
 123:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define alt_buffer_size 50
 124:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float alt_buffer[alt_buffer_size];
 125:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int alt_buffer_pointer =0;
 126:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** uint8 meanFreqCount = 0;
 127:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float alt_Sum =0;
 128:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** int meanAltitude;
 129:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /////////////////////////////
 130:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 131:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** ////////////////Lidar-2D
 132:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #if defined (Lidar2D)
 133:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #define plus_X 0
 134:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #define plus_Y 1
 135:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #define minus_X 2
 136:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int distance2D[3];    //0 = +X; 1 = +Y; 2 = -X
 137:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int Hokuyo_str[9];
 138:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   bool bit_array[18];
 139:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   boolean isHokuyoHoldInitialized = false;
 140:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float HokuyoPositionToHoldTarget_X = 0;  //roll
 141:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float HokuyoPositionToHoldTarget_Y = 0;  //pitch
 142:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   byte HokuyoHoldState = OFF;
 143:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int LastNonZeroRoll =0;
 144:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int LastNonZeroPitch =0;
 145:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int hokuyoHoldThrottleCorrection_Y =0, hokuyoHoldThrottleCorrection_X =0;
 146:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int temphokuyoHoldThrottleCorrection_XGLOBAL =0, temphokuyoHoldThrottleCorrection_YGLOBAL=0;
 147:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int RollVelocityDirection =0, PitchVelocityDirection =0;
 148:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float prevRoll =0, prevPitch=0;
 149:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #endif
 150:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** ////////////////////////////
 151:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 152:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** ////////////////////////////
 153:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** byte  headingHoldState    = OFF;
 154:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void  processHeading();
 155:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////////////////////////////////
 156:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 157:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 158:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /**
 159:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  * Serial communication global declaration
 160:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  */
 161:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_PRINT      SERIAL_PORT.print
 162:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_PRINTLN    SERIAL_PORT.println
 163:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_AVAILABLE  SERIAL_PORT.available
 164:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_READ       SERIAL_PORT.read
 165:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_FLUSH      SERIAL_PORT.flush
 166:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_BEGIN      SERIAL_PORT.begin
 167:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #define SERIAL_READUNTIL SERIAL_PORT.readStringUntil
 168:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  
 169:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //HardwareSerial *binaryPort;
 170:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 171:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void readSerialCommand();
 172:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void sendSerialTelemetry();
 173:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void printInt(int data);
 174:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** float readFloatSerial();
 175:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** long readIntegerSerial();
 176:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void sendBinaryFloat(float);
 177:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void sendBinaryuslong(unsigned long);
 178:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void fastTelemetry();
 179:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void comma();
 180:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** void reportVehicleState();
 181:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////////////////////////////////
 182:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 183:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /**
 184:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  * battery monitor and battery monitor throttle correction global declaration section
 185:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  */
 186:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #if defined (BattMonitor)
 187:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #define BattMonitorAlarmVoltage 10.0  // required by battery monitor macro, this is overriden by 
 188:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float batteryMonitorAlarmVoltage = 10.0;
 189:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int batteryMonitorStartThrottle = 0;
 190:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int batteryMonitorThrottleTarget = 1450;
 191:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   unsigned long batteryMonitorStartTime = 0;
 192:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   unsigned long batteryMonitorGoingDownTime = 60000; 
 193:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 194:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   
 195:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #if defined BattMonitorAutoDescent
 196:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****     #define BATTERY_MONITOR_MAX_ALARM_COUNT 50
 197:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****     
 198:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****     int batteryMonitorAlarmCounter = 0;
 199:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****     int batteyMonitorThrottleCorrection = 0;
 200:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   #endif
 201:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #endif
 202:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** //////////////////////////////////////////////////////
 203:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 204:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 205:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 206:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 207:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** /**
 208:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  * Altitude control global declaration
 209:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  */
 210:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 211:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****  // special state that allows immediate turn off of Altitude hold if large throttle changesa are ma
 212:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   byte altitudeHoldState = OFF;  // ON, OFF or ALTPANIC
 213:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int altitudeHoldBump = 90;
 214:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int altitudeHoldPanicStickMovement = 250;
 215:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int minThrottleAdjust = -50;
 216:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int maxThrottleAdjust = 50;
 217:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int altitudeHoldThrottle = 1000;
 218:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   boolean isAltitudeHoldInitialized = false;
 219:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float estimatedAltitude = 0.0;
 220:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float prevAltitude = 0.0;
 221:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   bool zDirection = 0;  //  1 = up & 0= Down
 222:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h **** 
 223:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   
 224:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   int LidarHoldThrottle = 0;
 225:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   
 226:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float velocityCompFilter1 = 1.0 / (1.0 + 0.3);
 227:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/AeroQuad.h ****   float velocityCompFilter2 = 1 - velocityCompFilter1;
 12970              		.loc 35 227 0
 12971 0000 0949     		ldr	r1, .L816
 12972 0002 0A48     		ldr	r0, .L816+4
 12973 0004 91ED000A 		flds	s0, [r1, #0]
 12974 0008 B7EE007A 		fconsts	s14, #112
 12975 000c 77EE407A 		fsubs	s15, s14, s0
 12976              	.LBE337:
 12977              	.LBE336:
 12978              		.loc 18 752 0
 12979 0010 08B5     		push	{r3, lr}
 12980              	.LCFI119:
 12981              		.cfi_def_cfa_offset 8
 12982              		.cfi_offset 14, -4
 12983              		.cfi_offset 3, -8
 12984              	.LBB339:
 12985              	.LBB338:
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   HardwareSPIExt spiMPU6000(4);
 12986              		.loc 10 116 0
 12987 0012 0421     		movs	r1, #4
 12988              		.loc 35 227 0
 12989 0014 C0ED007A 		fsts	s15, [r0, #0]
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   HardwareSPIExt spiMPU6000(4);
 12990              		.loc 10 116 0
 12991 0018 0548     		ldr	r0, .L816+8
 12992 001a FFF7FEFF 		bl	_ZN14HardwareSPIExtC1Ej
  27:/home/asim/AeroQuad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h **** unsigned long headingTime = micros();
 12993              		.loc 31 27 0
 12994 001e FFF7FEFF 		bl	_ZL6microsv
 12995 0022 044B     		ldr	r3, .L816+12
 12996 0024 1860     		str	r0, [r3, #0]
 12997              	.LBE338:
 12998              	.LBE339:
 12999              		.loc 18 752 0
 13000 0026 08BD     		pop	{r3, pc}
 13001              	.L817:
 13002              		.align	2
 13003              	.L816:
 13004 0028 00000000 		.word	.LANCHOR153
 13005 002c 00000000 		.word	.LANCHOR154
 13006 0030 00000000 		.word	.LANCHOR11
 13007 0034 00000000 		.word	.LANCHOR136
 13008              		.cfi_endproc
 13009              	.LFE283:
 13011              		.section	.init_array,"aw",%init_array
 13012              		.align	2
 13013 0004 00000000 		.word	_GLOBAL__sub_I__Z7premainv(target1)
 13014              		.global	queryType
 13015              		.global	headingTime
 13016              		.global	setHeading
 13017              		.global	motorConfiguratorCommand
 13018              		.global	motorMinCommand
 13019              		.global	motorMaxCommand
 13020              		.global	motorAxisCommandYaw
 13021              		.global	motorAxisCommandPitch
 13022              		.global	motorAxisCommandRoll
 13023              		.global	pinsArray
 13024              		.global	i2caddress
 13025              		.global	prev_val
 13026              		.global	myLidarLite
 13027              		.global	MS5611_first_read
 13028              		.global	baroStartTime
 13029              		.global	baroGroundUpdateDone
 13030              		.global	rawPressureSumCount
 13031              		.global	rawPressureSum
 13032              		.global	isReadPressure
 13033              		.global	pressureFactor
 13034              		.global	pressureCount
 13035              		.global	rawTemperature
 13036              		.global	rawPressure
 13037              		.global	pressure
 13038              		.global	MS5611_offset
 13039              		.global	MS5611_sens
 13040              		.global	MS5611lastRawPressure
 13041              		.global	MS5611lastRawTemperature
 13042              		.global	MS5611Prom
 13043              		.global	baroSmoothFactor
 13044              		.global	baroGroundAltitude
 13045              		.global	baroRawAltitude
 13046              		.global	baroAltitude
 13047              		.global	motorCommand
 13048              		.global	numberOfMotors
 13049              		.global	PWM_in_handler
 13050              		.global	FrqData
 13051              		.global	previousEz
 13052              		.global	previousEy
 13053              		.global	previousEx
 13054              		.global	ezInt
 13055              		.global	eyInt
 13056              		.global	exInt
 13057              		.global	q3
 13058              		.global	q2
 13059              		.global	q1
 13060              		.global	q0
 13061              		.global	halfT
 13062              		.global	Ki
 13063              		.global	Kp
 13064              		.global	accelCutoff
 13065              		.global	earthAccel
 13066              		.global	correctedRateVector
 13067              		.global	gyroAngle
 13068              		.global	kinematicsAngle
 13069              		.global	kinematicsType
 13070              		.global	previousMeasureCriticalSensorsTime
 13071              		.global	accelSampleCount
 13072              		.global	accelSample
 13073              		.global	meterPerSecSec
 13074              		.global	accelOneG
 13075              		.global	runTimeAccelBias
 13076              		.global	accelScaleFactor
 13077              		.global	gyroSampleCount
 13078              		.global	gyroLastMesuredTime
 13079              		.global	gyroHeading
 13080              		.global	gyroScaleFactor
 13081              		.global	gyroSample
 13082              		.global	gyroZero
 13083              		.global	gyroRate
 13084              		.global	readMPU6000GyroCount
 13085              		.global	readMPU6000AccelCount
 13086              		.global	readMPU6000Count
 13087              		.global	initializeMPU6000SensorsDone
 13088              		.global	spiMPU6000
 13089              		.global	MPU6000
 13090              		.global	vehicleState
 13091              		.global	gyroRaw
 13092              		.global	Serial
 13093              		.global	fourthOrder
 13094              		.global	windupGuard
 13095              		.global	PID
 13096              		.global	fastTransfer
 13097              		.global	baroAltitudeToHoldTarget
 13098              		.global	zDampeningThrottleCorrection
 13099              		.global	runtimeZBias
 13100              		.global	estimatedZVelocity
 13101              		.global	zVelocity
 13102              		.global	runtimaZBiasInitialized
 13103              		.global	velocityCompFilter2
 13104              		.global	velocityCompFilter1
 13105              		.global	LidarHoldThrottle
 13106              		.global	zDirection
 13107              		.global	prevAltitude
 13108              		.global	estimatedAltitude
 13109              		.global	isAltitudeHoldInitialized
 13110              		.global	altitudeHoldThrottle
 13111              		.global	maxThrottleAdjust
 13112              		.global	minThrottleAdjust
 13113              		.global	altitudeHoldPanicStickMovement
 13114              		.global	altitudeHoldBump
 13115              		.global	altitudeHoldState
 13116              		.global	headingHoldState
 13117              		.global	prevPitch
 13118              		.global	prevRoll
 13119              		.global	PitchVelocityDirection
 13120              		.global	RollVelocityDirection
 13121              		.global	temphokuyoHoldThrottleCorrection_YGLOBAL
 13122              		.global	temphokuyoHoldThrottleCorrection_XGLOBAL
 13123              		.global	hokuyoHoldThrottleCorrection_X
 13124              		.global	hokuyoHoldThrottleCorrection_Y
 13125              		.global	LastNonZeroPitch
 13126              		.global	LastNonZeroRoll
 13127              		.global	HokuyoHoldState
 13128              		.global	HokuyoPositionToHoldTarget_Y
 13129              		.global	HokuyoPositionToHoldTarget_X
 13130              		.global	isHokuyoHoldInitialized
 13131              		.global	bit_array
 13132              		.global	Hokuyo_str
 13133              		.global	distance2D
 13134              		.global	meanAltitude
 13135              		.global	alt_Sum
 13136              		.global	meanFreqCount
 13137              		.global	alt_buffer_pointer
 13138              		.global	alt_buffer
 13139              		.global	relativeHeading
 13140              		.global	heading
 13141              		.global	headingHold
 13142              		.global	headingHoldConfig
 13143              		.global	aref
 13144              		.global	altitudeHoldThrottleCorrectionGLOBAL
 13145              		.global	hundredHZpreviousTime
 13146              		.global	fiftyHZpreviousTime
 13147              		.global	lowPriorityTenHZpreviousTime2
 13148              		.global	lowPriorityTenHZpreviousTime
 13149              		.global	tenHZpreviousTime
 13150              		.global	oneHZpreviousTime
 13151              		.global	deltaTime
 13152              		.global	currentTime
 13153              		.global	previousTime
 13154              		.global	rotationSpeedFactor
 13155              		.global	inFlight
 13156              		.global	filteredAccel
 13157              		.global	minLimit
 13158              		.global	maxLimit
 13159              		.global	safetyCheck
 13160              		.global	motorArmed
 13161              		.global	throttle
 13162              		.global	G_Dt
 13163              		.global	minArmedThrottle
 13164              		.global	frameCounter
 13165              		.global	flightMode
 13166              		.global	previousFlightMode
 13167              		.global	count
 13168              		.global	hokuyo_YRaw
 13169              		.global	hokuyo_XRaw
 13170              		.global	testCommand
 13171              		.global	calibrateESC
 13172              		.global	channelCal
 13173              		.global	receiverSmoothFactor
 13174              		.global	receiverOffset
 13175              		.global	receiverSlope
 13176              		.global	receiverCommandSmooth
 13177              		.global	receiverCommand
 13178              		.global	receiverZero
 13179              		.global	receiverData
 13180              		.global	receiverXmitFactor
 13181              		.global	lastReceiverChannel
 13182              		.global	pre_value
 13183              		.global	est_errY
 13184              		.global	est_valY
 13185              		.global	est_errX
 13186              		.global	est_valX
 13187              		.global	est_err
 13188              		.global	est_val
 13189              		.global	kY
 13190              		.global	kX
 13191              		.global	out
 13192              		.global	k
 13193              		.global	kal_filt
 13194              		.global	pulseWidth
 13195              		.weak	_ZN14HardwareSPIExtC1Ej
 13196              		.thumb_set _ZN14HardwareSPIExtC1Ej,_ZN14HardwareSPIExtC2Ej
 13197              		.global	_ZN9LIDARLiteC1Ev
 13198              		.thumb_set _ZN9LIDARLiteC1Ev,_ZN9LIDARLiteC2Ev
 13199              		.section	.bss.runtimaZBiasInitialized,"aw",%nobits
 13200              		.set	.LANCHOR152,. + 0
 13203              	runtimaZBiasInitialized:
 13204 0000 00       		.space	1
 13205              		.section	.bss.kX,"aw",%nobits
 13206              		.align	2
 13207              		.set	.LANCHOR86,. + 0
 13210              	kX:
 13211 0000 00000000 		.space	4
 13212              		.section	.bss.MPU6000,"aw",%nobits
 13213              		.align	1
 13214              		.set	.LANCHOR14,. + 0
 13217              	MPU6000:
 13218 0000 00000000 		.space	14
 13218      00000000 
 13218      00000000 
 13218      0000
 13219              		.section	.bss.receiverData,"aw",%nobits
 13220              		.align	2
 13221              		.set	.LANCHOR54,. + 0
 13224              	receiverData:
 13225 0000 00000000 		.space	40
 13225      00000000 
 13225      00000000 
 13225      00000000 
 13225      00000000 
 13226              		.section	.bss.LastNonZeroRoll,"aw",%nobits
 13227              		.align	2
 13228              		.set	.LANCHOR157,. + 0
 13231              	LastNonZeroRoll:
 13232 0000 00000000 		.space	4
 13233              		.section	.bss.motorArmed,"aw",%nobits
 13234              		.set	.LANCHOR138,. + 0
 13237              	motorArmed:
 13238 0000 00       		.space	1
 13239              		.section	.bss.MS5611lastRawTemperature,"aw",%nobits
 13240              		.align	2
 13241              		.set	.LANCHOR62,. + 0
 13244              	MS5611lastRawTemperature:
 13245 0000 00000000 		.space	4
 13246              		.section	.data.baroSmoothFactor,"aw",%progbits
 13247              		.align	2
 13248              		.set	.LANCHOR74,. + 0
 13251              	baroSmoothFactor:
 13252 0000 0AD7A33C 		.word	1017370378
 13253              		.section	.bss.rawPressure,"aw",%nobits
 13254              		.align	2
 13257              	rawPressure:
 13258 0000 00000000 		.space	4
 13259              		.section	.bss.pressureCount,"aw",%nobits
 13260              		.set	.LANCHOR69,. + 0
 13263              	pressureCount:
 13264 0000 00       		.space	1
 13265              		.section	.bss.k,"aw",%nobits
 13266              		.align	2
 13267              		.set	.LANCHOR78,. + 0
 13270              	k:
 13271 0000 00000000 		.space	4
 13272              		.section	.bss.gyroHeading,"aw",%nobits
 13273              		.align	2
 13274              		.set	.LANCHOR20,. + 0
 13277              	gyroHeading:
 13278 0000 00000000 		.space	4
 13279              		.section	.bss.kal_filt,"aw",%nobits
 13280              		.align	2
 13281              		.set	.LANCHOR81,. + 0
 13284              	kal_filt:
 13285 0000 00000000 		.space	4
 13286              		.section	.bss.HokuyoHoldState,"aw",%nobits
 13287              		.set	.LANCHOR108,. + 0
 13290              	HokuyoHoldState:
 13291 0000 00       		.space	1
 13292              		.section	.data.pinsArray,"aw",%progbits
 13293              		.align	2
 13296              	pinsArray:
 13297 0000 32000000 		.word	50
 13298 0004 34000000 		.word	52
 13299              		.section	.data.PWM_in_handler,"aw",%progbits
 13300              		.align	2
 13301              		.set	.LANCHOR52,. + 0
 13304              	PWM_in_handler:
 13305 0000 00000000 		.word	_Z8PWM_in_0v
 13306 0004 00000000 		.word	_Z8PWM_in_1v
 13307 0008 00000000 		.word	_Z8PWM_in_2v
 13308 000c 00000000 		.word	_Z8PWM_in_3v
 13309 0010 00000000 		.word	_Z8PWM_in_4v
 13310 0014 00000000 		.word	_Z8PWM_in_5v
 13311 0018 00000000 		.word	_Z8PWM_in_6v
 13312 001c 00000000 		.word	_Z8PWM_in_7v
 13313              		.section	.data.altitudeHoldPanicStickMovement,"aw",%progbits
 13314              		.align	2
 13315              		.set	.LANCHOR106,. + 0
 13318              	altitudeHoldPanicStickMovement:
 13319 0000 FA000000 		.word	250
 13320              		.section	.bss.receiverSmoothFactor,"aw",%nobits
 13321              		.align	2
 13322              		.set	.LANCHOR6,. + 0
 13325              	receiverSmoothFactor:
 13326 0000 00000000 		.space	40
 13326      00000000 
 13326      00000000 
 13326      00000000 
 13326      00000000 
 13327              		.section	.bss.FrqData,"aw",%nobits
 13328              		.align	2
 13329              		.set	.LANCHOR51,. + 0
 13332              	FrqData:
 13333 0000 00000000 		.space	384
 13333      00000000 
 13333      00000000 
 13333      00000000 
 13333      00000000 
 13334              		.section	.data.flightMode,"aw",%progbits
 13335              		.set	.LANCHOR119,. + 0
 13338              	flightMode:
 13339 0000 01       		.byte	1
 13340              		.section	.bss.out,"aw",%nobits
 13341              		.align	2
 13344              	out:
 13345 0000 00000000 		.space	4
 13346              		.section	.bss.q1,"aw",%nobits
 13347              		.align	2
 13348              		.set	.LANCHOR36,. + 0
 13351              	q1:
 13352 0000 00000000 		.space	4
 13353              		.section	.bss.readMPU6000Count,"aw",%nobits
 13354              		.align	2
 13355              		.set	.LANCHOR16,. + 0
 13358              	readMPU6000Count:
 13359 0000 00000000 		.space	4
 13360              		.section	.bss.velocityCompFilter2,"aw",%nobits
 13361              		.align	2
 13362              		.set	.LANCHOR154,. + 0
 13365              	velocityCompFilter2:
 13366 0000 00000000 		.space	4
 13367              		.section	.bss.tenHZpreviousTime,"aw",%nobits
 13368              		.align	2
 13371              	tenHZpreviousTime:
 13372 0000 00000000 		.space	4
 13373              		.section	.bss.heading,"aw",%nobits
 13374              		.align	2
 13375              		.set	.LANCHOR131,. + 0
 13378              	heading:
 13379 0000 00000000 		.space	4
 13380              		.section	.bss.estimatedAltitude,"aw",%nobits
 13381              		.align	2
 13382              		.set	.LANCHOR100,. + 0
 13385              	estimatedAltitude:
 13386 0000 00000000 		.space	4
 13387              		.section	.rodata.Serial,"a",%progbits
 13388              		.align	2
 13391              	Serial:
 13392 0000 00000000 		.word	Serial1
 13393              		.section	.bss.runtimeZBias,"aw",%nobits
 13394              		.align	2
 13395              		.set	.LANCHOR151,. + 0
 13398              	runtimeZBias:
 13399 0000 00000000 		.space	4
 13400              		.section	.rodata._ZL11receiverPin,"a",%progbits
 13401              		.set	.LANCHOR50,. + 0
 13404              	_ZL11receiverPin:
 13405 0000 3C       		.byte	60
 13406 0001 3D       		.byte	61
 13407 0002 3E       		.byte	62
 13408 0003 3F       		.byte	63
 13409 0004 49       		.byte	73
 13410 0005 4B       		.byte	75
 13411 0006 4D       		.byte	77
 13412 0007 4E       		.byte	78
 13413              		.section	.bss.baroAltitude,"aw",%nobits
 13414              		.align	2
 13415              		.set	.LANCHOR59,. + 0
 13418              	baroAltitude:
 13419 0000 00000000 		.space	4
 13420              		.section	.bss.isHokuyoHoldInitialized,"aw",%nobits
 13421              		.set	.LANCHOR128,. + 0
 13424              	isHokuyoHoldInitialized:
 13425 0000 00       		.space	1
 13426              		.section	.data.altitudeHoldBump,"aw",%progbits
 13427              		.align	2
 13428              		.set	.LANCHOR107,. + 0
 13431              	altitudeHoldBump:
 13432 0000 5A000000 		.word	90
 13433              		.section	.bss.baroGroundAltitude,"aw",%nobits
 13434              		.align	2
 13435              		.set	.LANCHOR60,. + 0
 13438              	baroGroundAltitude:
 13439 0000 00000000 		.space	4
 13440              		.section	.bss.altitudeHoldThrottleCorrectionGLOBAL,"aw",%nobits
 13441              		.align	2
 13442              		.set	.LANCHOR102,. + 0
 13445              	altitudeHoldThrottleCorrectionGLOBAL:
 13446 0000 00000000 		.space	4
 13447              		.section	.bss.motorAxisCommandPitch,"aw",%nobits
 13448              		.align	2
 13449              		.set	.LANCHOR92,. + 0
 13452              	motorAxisCommandPitch:
 13453 0000 00000000 		.space	4
 13454              		.section	.bss.motorCommand,"aw",%nobits
 13455              		.align	2
 13456              		.set	.LANCHOR56,. + 0
 13459              	motorCommand:
 13460 0000 00000000 		.space	32
 13460      00000000 
 13460      00000000 
 13460      00000000 
 13460      00000000 
 13461              		.section	.bss.prevPitch,"aw",%nobits
 13462              		.align	2
 13463              		.set	.LANCHOR160,. + 0
 13466              	prevPitch:
 13467 0000 00000000 		.space	4
 13468              		.section	.bss.baroGroundUpdateDone,"aw",%nobits
 13469              		.set	.LANCHOR75,. + 0
 13472              	baroGroundUpdateDone:
 13473 0000 00       		.space	1
 13474              		.section	.bss.prevRoll,"aw",%nobits
 13475              		.align	2
 13476              		.set	.LANCHOR159,. + 0
 13479              	prevRoll:
 13480 0000 00000000 		.space	4
 13481              		.section	.data.MS5611_first_read,"aw",%progbits
 13482              		.set	.LANCHOR73,. + 0
 13485              	MS5611_first_read:
 13486 0000 01       		.byte	1
 13487              		.section	.bss.headingHoldConfig,"aw",%nobits
 13488              		.set	.LANCHOR130,. + 0
 13491              	headingHoldConfig:
 13492 0000 00       		.space	1
 13493              		.section	.bss.ezInt,"aw",%nobits
 13494              		.align	2
 13495              		.set	.LANCHOR45,. + 0
 13498              	ezInt:
 13499 0000 00000000 		.space	4
 13500              		.section	.data.numberOfMotors,"aw",%progbits
 13503              	numberOfMotors:
 13504 0000 04       		.byte	4
 13505              		.section	.bss.hokuyo_XRaw,"aw",%nobits
 13506              		.align	2
 13507              		.set	.LANCHOR147,. + 0
 13510              	hokuyo_XRaw:
 13511 0000 00000000 		.space	4
 13512              		.section	.data.rotationSpeedFactor,"aw",%progbits
 13513              		.align	2
 13514              		.set	.LANCHOR120,. + 0
 13517              	rotationSpeedFactor:
 13518 0000 0000803F 		.word	1065353216
 13519              		.section	.bss.zVelocity,"aw",%nobits
 13520              		.align	2
 13521              		.set	.LANCHOR150,. + 0
 13524              	zVelocity:
 13525 0000 00000000 		.space	4
 13526              		.section	.bss.alt_buffer,"aw",%nobits
 13527              		.align	2
 13528              		.set	.LANCHOR97,. + 0
 13531              	alt_buffer:
 13532 0000 00000000 		.space	200
 13532      00000000 
 13532      00000000 
 13532      00000000 
 13532      00000000 
 13533              		.section	.bss.headingHoldState,"aw",%nobits
 13534              		.set	.LANCHOR135,. + 0
 13537              	headingHoldState:
 13538 0000 00       		.space	1
 13539              		.section	.bss.meanAltitude,"aw",%nobits
 13540              		.align	2
 13543              	meanAltitude:
 13544 0000 00000000 		.space	4
 13545              		.section	.rodata._ZL18ReceiverChannelMap,"a",%progbits
 13546              		.set	.LANCHOR53,. + 0
 13549              	_ZL18ReceiverChannelMap:
 13550 0000 00       		.byte	0
 13551 0001 01       		.byte	1
 13552 0002 02       		.byte	2
 13553 0003 03       		.byte	3
 13554 0004 04       		.byte	4
 13555 0005 05       		.byte	5
 13556 0006 06       		.byte	6
 13557 0007 07       		.byte	7
 13558              		.section	.rodata._ZL19stm32_motor_mapping,"a",%progbits
 13559              		.set	.LANCHOR57,. + 0
 13562              	_ZL19stm32_motor_mapping:
 13563 0000 29       		.byte	41
 13564 0001 28       		.byte	40
 13565 0002 27       		.byte	39
 13566 0003 26       		.byte	38
 13567 0004 0F       		.byte	15
 13568 0005 13       		.byte	19
 13569 0006 14       		.byte	20
 13570 0007 15       		.byte	21
 13571              		.section	.bss.distance2D,"aw",%nobits
 13572              		.align	2
 13573              		.set	.LANCHOR84,. + 0
 13576              	distance2D:
 13577 0000 00000000 		.space	12
 13577      00000000 
 13577      00000000 
 13578              		.section	.bss.q0,"aw",%nobits
 13579              		.align	2
 13580              		.set	.LANCHOR38,. + 0
 13583              	q0:
 13584 0000 00000000 		.space	4
 13585              		.section	.bss.motorAxisCommandRoll,"aw",%nobits
 13586              		.align	2
 13587              		.set	.LANCHOR94,. + 0
 13590              	motorAxisCommandRoll:
 13591 0000 00000000 		.space	4
 13592              		.section	.bss.accelSampleCount,"aw",%nobits
 13593              		.set	.LANCHOR30,. + 0
 13596              	accelSampleCount:
 13597 0000 00       		.space	1
 13598              		.section	.bss.eyInt,"aw",%nobits
 13599              		.align	2
 13600              		.set	.LANCHOR43,. + 0
 13603              	eyInt:
 13604 0000 00000000 		.space	4
 13605              		.section	.bss.previousEx,"aw",%nobits
 13606              		.align	2
 13607              		.set	.LANCHOR42,. + 0
 13610              	previousEx:
 13611 0000 00000000 		.space	4
 13612              		.section	.bss.previousEy,"aw",%nobits
 13613              		.align	2
 13614              		.set	.LANCHOR44,. + 0
 13617              	previousEy:
 13618 0000 00000000 		.space	4
 13619              		.section	.bss.previousEz,"aw",%nobits
 13620              		.align	2
 13621              		.set	.LANCHOR46,. + 0
 13624              	previousEz:
 13625 0000 00000000 		.space	4
 13626              		.section	.data.pressureFactor,"aw",%progbits
 13627              		.align	2
 13628              		.set	.LANCHOR71,. + 0
 13631              	pressureFactor:
 13632 0000 AEDC423E 		.word	1044569262
 13633              		.section	.data.est_val,"aw",%progbits
 13634              		.align	2
 13635              		.set	.LANCHOR79,. + 0
 13638              	est_val:
 13639 0000 00008C42 		.word	1116471296
 13640              		.section	.bss.readMPU6000GyroCount,"aw",%nobits
 13641              		.align	2
 13642              		.set	.LANCHOR17,. + 0
 13645              	readMPU6000GyroCount:
 13646 0000 00000000 		.space	4
 13647              		.section	.bss.isReadPressure,"aw",%nobits
 13648              		.set	.LANCHOR66,. + 0
 13651              	isReadPressure:
 13652 0000 00       		.space	1
 13653              		.section	.bss.fastTransfer,"aw",%nobits
 13654              		.set	.LANCHOR144,. + 0
 13657              	fastTransfer:
 13658 0000 00       		.space	1
 13659              		.section	.bss.filteredAccel,"aw",%nobits
 13660              		.align	2
 13661              		.set	.LANCHOR145,. + 0
 13664              	filteredAccel:
 13665 0000 00000000 		.space	12
 13665      00000000 
 13665      00000000 
 13666              		.section	.bss.minArmedThrottle,"aw",%nobits
 13667              		.align	2
 13668              		.set	.LANCHOR125,. + 0
 13671              	minArmedThrottle:
 13672 0000 00000000 		.space	4
 13673              		.section	.bss.previousTime,"aw",%nobits
 13674              		.align	2
 13675              		.set	.LANCHOR148,. + 0
 13678              	previousTime:
 13679 0000 00000000 		.space	4
 13680              		.section	.bss.deltaTime,"aw",%nobits
 13681              		.align	2
 13682              		.set	.LANCHOR163,. + 0
 13685              	deltaTime:
 13686 0000 00000000 		.space	4
 13687              		.section	.bss.kY,"aw",%nobits
 13688              		.align	2
 13689              		.set	.LANCHOR89,. + 0
 13692              	kY:
 13693 0000 00000000 		.space	4
 13694              		.section	.bss.prev_val,"aw",%nobits
 13695              		.align	2
 13698              	prev_val:
 13699 0000 00000000 		.space	4
 13700              		.section	.bss.temphokuyoHoldThrottleCorrection_YGLOBAL,"aw",%nobits
 13701              		.align	2
 13702              		.set	.LANCHOR116,. + 0
 13705              	temphokuyoHoldThrottleCorrection_YGLOBAL:
 13706 0000 00000000 		.space	4
 13707              		.section	.bss.windupGuard,"aw",%nobits
 13708              		.align	2
 13709              		.set	.LANCHOR139,. + 0
 13712              	windupGuard:
 13713 0000 00000000 		.space	4
 13714              		.section	.bss.pre_value,"aw",%nobits
 13715              		.align	2
 13718              	pre_value:
 13719 0000 00000000 		.space	4
 13720              		.section	.bss.accelCutoff,"aw",%nobits
 13721              		.align	2
 13724              	accelCutoff:
 13725 0000 00000000 		.space	4
 13726              		.section	.bss.hokuyoHoldThrottleCorrection_X,"aw",%nobits
 13727              		.align	2
 13728              		.set	.LANCHOR111,. + 0
 13731              	hokuyoHoldThrottleCorrection_X:
 13732 0000 00000000 		.space	4
 13733              		.section	.data.est_err,"aw",%progbits
 13734              		.align	2
 13735              		.set	.LANCHOR77,. + 0
 13738              	est_err:
 13739 0000 0000B442 		.word	1119092736
 13740              		.section	.bss.myLidarLite,"aw",%nobits
 13741              		.set	.LANCHOR80,. + 0
 13744              	myLidarLite:
 13745 0000 00       		.space	1
 13746              		.section	.bss.relativeHeading,"aw",%nobits
 13747              		.align	2
 13748              		.set	.LANCHOR133,. + 0
 13751              	relativeHeading:
 13752 0000 00000000 		.space	4
 13753              		.section	.data.est_valX,"aw",%progbits
 13754              		.align	2
 13755              		.set	.LANCHOR87,. + 0
 13758              	est_valX:
 13759 0000 00008C42 		.word	1116471296
 13760              		.section	.data.est_valY,"aw",%progbits
 13761              		.align	2
 13762              		.set	.LANCHOR90,. + 0
 13765              	est_valY:
 13766 0000 00008C42 		.word	1116471296
 13767              		.section	.bss.q2,"aw",%nobits
 13768              		.align	2
 13769              		.set	.LANCHOR39,. + 0
 13772              	q2:
 13773 0000 00000000 		.space	4
 13774              		.section	.bss.q3,"aw",%nobits
 13775              		.align	2
 13776              		.set	.LANCHOR37,. + 0
 13779              	q3:
 13780 0000 00000000 		.space	4
 13781              		.section	.bss.MS5611_offset,"aw",%nobits
 13782              		.align	3
 13783              		.set	.LANCHOR63,. + 0
 13786              	MS5611_offset:
 13787 0000 00000000 		.space	8
 13787      00000000 
 13788              		.section	.bss.accelSample,"aw",%nobits
 13789              		.align	2
 13790              		.set	.LANCHOR29,. + 0
 13793              	accelSample:
 13794 0000 00000000 		.space	12
 13794      00000000 
 13794      00000000 
 13795              		.section	.bss.motorConfiguratorCommand,"aw",%nobits
 13796              		.align	2
 13797              		.set	.LANCHOR123,. + 0
 13800              	motorConfiguratorCommand:
 13801 0000 00000000 		.space	16
 13801      00000000 
 13801      00000000 
 13801      00000000 
 13802              		.section	.bss.receiverCommand,"aw",%nobits
 13803              		.align	2
 13804              		.set	.LANCHOR1,. + 0
 13807              	receiverCommand:
 13808 0000 00000000 		.space	40
 13808      00000000 
 13808      00000000 
 13808      00000000 
 13808      00000000 
 13809              		.section	.bss.accelScaleFactor,"aw",%nobits
 13810              		.align	2
 13811              		.set	.LANCHOR27,. + 0
 13814              	accelScaleFactor:
 13815 0000 00000000 		.space	12
 13815      00000000 
 13815      00000000 
 13816              		.section	.data.minThrottleAdjust,"aw",%progbits
 13817              		.align	2
 13818              		.set	.LANCHOR113,. + 0
 13821              	minThrottleAdjust:
 13822 0000 CEFFFFFF 		.word	-50
 13823              		.section	.bss.halfT,"aw",%nobits
 13824              		.align	2
 13825              		.set	.LANCHOR35,. + 0
 13828              	halfT:
 13829 0000 00000000 		.space	4
 13830              		.section	.bss.headingHold,"aw",%nobits
 13831              		.align	2
 13832              		.set	.LANCHOR134,. + 0
 13835              	headingHold:
 13836 0000 00000000 		.space	4
 13837              		.section	.bss.correctedRateVector,"aw",%nobits
 13838              		.align	2
 13839              		.set	.LANCHOR49,. + 0
 13842              	correctedRateVector:
 13843 0000 00000000 		.space	12
 13843      00000000 
 13843      00000000 
 13844              		.section	.bss.RollVelocityDirection,"aw",%nobits
 13845              		.align	2
 13846              		.set	.LANCHOR112,. + 0
 13849              	RollVelocityDirection:
 13850 0000 00000000 		.space	4
 13851              		.section	.bss.fiftyHZpreviousTime,"aw",%nobits
 13852              		.align	2
 13853              		.set	.LANCHOR156,. + 0
 13856              	fiftyHZpreviousTime:
 13857 0000 00000000 		.space	4
 13858              		.section	.bss.altitudeHoldState,"aw",%nobits
 13859              		.set	.LANCHOR98,. + 0
 13862              	altitudeHoldState:
 13863 0000 00       		.space	1
 13864              		.section	.bss.Ki,"aw",%nobits
 13865              		.align	2
 13866              		.set	.LANCHOR41,. + 0
 13869              	Ki:
 13870 0000 00000000 		.space	4
 13871              		.section	.bss.hokuyo_YRaw,"aw",%nobits
 13872              		.align	2
 13873              		.set	.LANCHOR146,. + 0
 13876              	hokuyo_YRaw:
 13877 0000 00000000 		.space	4
 13878              		.section	.bss.receiverCommandSmooth,"aw",%nobits
 13879              		.align	2
 13880              		.set	.LANCHOR2,. + 0
 13883              	receiverCommandSmooth:
 13884 0000 00000000 		.space	40
 13884      00000000 
 13884      00000000 
 13884      00000000 
 13884      00000000 
 13885              		.section	.bss.baroRawAltitude,"aw",%nobits
 13886              		.align	2
 13887              		.set	.LANCHOR72,. + 0
 13890              	baroRawAltitude:
 13891 0000 00000000 		.space	4
 13892              		.section	.bss.gyroSample,"aw",%nobits
 13893              		.align	2
 13894              		.set	.LANCHOR24,. + 0
 13897              	gyroSample:
 13898 0000 00000000 		.space	12
 13898      00000000 
 13898      00000000 
 13899              		.section	.data.velocityCompFilter1,"aw",%progbits
 13900              		.align	2
 13901              		.set	.LANCHOR153,. + 0
 13904              	velocityCompFilter1:
 13905 0000 4FEC443F 		.word	1061481551
 13906              		.section	.bss.Kp,"aw",%nobits
 13907              		.align	2
 13908              		.set	.LANCHOR47,. + 0
 13911              	Kp:
 13912 0000 00000000 		.space	4
 13913              		.section	.bss.prevAltitude,"aw",%nobits
 13914              		.align	2
 13915              		.set	.LANCHOR155,. + 0
 13918              	prevAltitude:
 13919 0000 00000000 		.space	4
 13920              		.section	.bss.readMPU6000AccelCount,"aw",%nobits
 13921              		.align	2
 13922              		.set	.LANCHOR15,. + 0
 13925              	readMPU6000AccelCount:
 13926 0000 00000000 		.space	4
 13927              		.section	.bss.headingTime,"aw",%nobits
 13928              		.align	2
 13929              		.set	.LANCHOR136,. + 0
 13932              	headingTime:
 13933 0000 00000000 		.space	4
 13934              		.section	.rodata.str1.1,"aMS",%progbits,1
 13935              	.LC0:
 13936 0000 3E206E61 		.ascii	"> nack\000"
 13936      636B00
 13937              	.LC1:
 13938 0007 3E207265 		.ascii	"> read failed\000"
 13938      61642066 
 13938      61696C65 
 13938      6400
 13939              	.LC2:
 13940 0015 3A2000   		.ascii	": \000"
 13941              	.LC3:
 13942 0018 4E6F7420 		.ascii	"Not \000"
 13942      00
 13943              	.LC4:
 13944 001d 536F6674 		.ascii	"Software Version: \000"
 13944      77617265 
 13944      20566572 
 13944      73696F6E 
 13944      3A2000
 13945              	.LC5:
 13946 0030 426F6172 		.ascii	"Board Type: \000"
 13946      64205479 
 13946      70653A20 
 13946      00
 13947              	.LC6:
 13948 003d 6165726F 		.ascii	"aeroquad32\000"
 13948      71756164 
 13948      333200
 13949              	.LC7:
 13950 0048 466C6967 		.ascii	"Flight Config: \000"
 13950      68742043 
 13950      6F6E6669 
 13950      673A2000 
 13951              	.LC8:
 13952 0058 51756164 		.ascii	"Quad +\000"
 13952      202B00
 13953              	.LC9:
 13954 005f 52656365 		.ascii	"Receiver Channels: \000"
 13954      69766572 
 13954      20436861 
 13954      6E6E656C 
 13954      733A2000 
 13955              	.LC10:
 13956 0073 4D6F746F 		.ascii	"Motors: \000"
 13956      72733A20 
 13956      00
 13957              	.LC11:
 13958 007c 4779726F 		.ascii	"Gyroscope\000"
 13958      73636F70 
 13958      6500
 13959              	.LC12:
 13960 0086 44657465 		.ascii	"Detected\000"
 13960      63746564 
 13960      00
 13961              	.LC13:
 13962 008f 41636365 		.ascii	"Accelerometer\000"
 13962      6C65726F 
 13962      6D657465 
 13962      7200
 13963              	.LC14:
 13964 009d 4261726F 		.ascii	"Barometer\000"
 13964      6D657465 
 13964      7200
 13965              	.LC15:
 13966 00a7 4D61676E 		.ascii	"Magnetometer\000"
 13966      65746F6D 
 13966      65746572 
 13966      00
 13967              	.LC16:
 13968 00b4 48656164 		.ascii	"Heading Hold\000"
 13968      696E6720 
 13968      486F6C64 
 13968      00
 13969              	.LC17:
 13970 00c1 456E6162 		.ascii	"Enabled\000"
 13970      6C656400 
 13971              	.LC18:
 13972 00c9 416C7469 		.ascii	"Altitude Hold\000"
 13972      74756465 
 13972      20486F6C 
 13972      6400
 13973              	.LC19:
 13974 00d7 42617474 		.ascii	"Battery Monitor\000"
 13974      65727920 
 13974      4D6F6E69 
 13974      746F7200 
 13975              	.LC20:
 13976 00e7 43616D65 		.ascii	"Camera Stability\000"
 13976      72612053 
 13976      74616269 
 13976      6C697479 
 13976      00
 13977              	.LC21:
 13978 00f8 52616E67 		.ascii	"Range Detection\000"
 13978      65204465 
 13978      74656374 
 13978      696F6E00 
 13979              	.LC22:
 13980 0108 4750533A 		.ascii	"GPS: Not Enabled\000"
 13980      204E6F74 
 13980      20456E61 
 13980      626C6564 
 13980      00
 13981              		.section	.bss.initializeMPU6000SensorsDone,"aw",%nobits
 13982              		.set	.LANCHOR12,. + 0
 13985              	initializeMPU6000SensorsDone:
 13986 0000 00       		.space	1
 13987              		.section	.bss.pressure,"aw",%nobits
 13988              		.align	2
 13989              		.set	.LANCHOR70,. + 0
 13992              	pressure:
 13993 0000 00000000 		.space	4
 13994              		.section	.bss.gyroRaw,"aw",%nobits
 13995              		.align	2
 13996              		.set	.LANCHOR22,. + 0
 13999              	gyroRaw:
 14000 0000 00000000 		.space	12
 14000      00000000 
 14000      00000000 
 14001              		.section	.bss.HokuyoPositionToHoldTarget_X,"aw",%nobits
 14002              		.align	2
 14003              		.set	.LANCHOR109,. + 0
 14006              	HokuyoPositionToHoldTarget_X:
 14007 0000 00000000 		.space	4
 14008              		.section	.data.throttle,"aw",%progbits
 14009              		.align	2
 14010              		.set	.LANCHOR91,. + 0
 14013              	throttle:
 14014 0000 E8030000 		.word	1000
 14015              		.section	.bss.gyroRate,"aw",%nobits
 14016              		.align	2
 14017              		.set	.LANCHOR19,. + 0
 14020              	gyroRate:
 14021 0000 00000000 		.space	12
 14021      00000000 
 14021      00000000 
 14022              		.section	.bss.MS5611_sens,"aw",%nobits
 14023              		.align	3
 14024              		.set	.LANCHOR64,. + 0
 14027              	MS5611_sens:
 14028 0000 00000000 		.space	8
 14028      00000000 
 14029              		.section	.data.i2caddress,"aw",%progbits
 14032              	i2caddress:
 14033 0000 64       		.byte	100
 14034 0001 66       		.byte	102
 14035              		.section	.bss.LastNonZeroPitch,"aw",%nobits
 14036              		.align	2
 14037              		.set	.LANCHOR158,. + 0
 14040              	LastNonZeroPitch:
 14041 0000 00000000 		.space	4
 14042              		.section	.bss.kinematicsAngle,"aw",%nobits
 14043              		.align	2
 14044              		.set	.LANCHOR33,. + 0
 14047              	kinematicsAngle:
 14048 0000 00000000 		.space	12
 14048      00000000 
 14048      00000000 
 14049              		.section	.bss.oneHZpreviousTime,"aw",%nobits
 14050              		.align	2
 14053              	oneHZpreviousTime:
 14054 0000 00000000 		.space	4
 14055              		.section	.bss.lowPriorityTenHZpreviousTime2,"aw",%nobits
 14056              		.align	2
 14057              		.set	.LANCHOR162,. + 0
 14060              	lowPriorityTenHZpreviousTime2:
 14061 0000 00000000 		.space	4
 14062              		.section	.bss.frameCounter,"aw",%nobits
 14063              		.align	2
 14064              		.set	.LANCHOR137,. + 0
 14067              	frameCounter:
 14068 0000 00000000 		.space	4
 14069              		.section	.bss.temphokuyoHoldThrottleCorrection_XGLOBAL,"aw",%nobits
 14070              		.align	2
 14071              		.set	.LANCHOR110,. + 0
 14074              	temphokuyoHoldThrottleCorrection_XGLOBAL:
 14075 0000 00000000 		.space	4
 14076              		.section	.bss.calibrateESC,"aw",%nobits
 14077              		.set	.LANCHOR121,. + 0
 14080              	calibrateESC:
 14081 0000 00       		.space	1
 14082              		.section	.bss.minLimit,"aw",%nobits
 14085              	minLimit:
 14086 0000 00       		.space	1
 14087              		.section	.bss.zDampeningThrottleCorrection,"aw",%nobits
 14088              		.align	2
 14091              	zDampeningThrottleCorrection:
 14092 0000 00000000 		.space	4
 14093              		.section	.bss.spiMPU6000,"aw",%nobits
 14094              		.align	2
 14095              		.set	.LANCHOR11,. + 0
 14098              	spiMPU6000:
 14099 0000 00000000 		.space	12
 14099      00000000 
 14099      00000000 
 14100              		.section	.bss.fourthOrder,"aw",%nobits
 14101              		.align	2
 14102              		.set	.LANCHOR10,. + 0
 14105              	fourthOrder:
 14106 0000 00000000 		.space	128
 14106      00000000 
 14106      00000000 
 14106      00000000 
 14106      00000000 
 14107              		.section	.bss.estimatedZVelocity,"aw",%nobits
 14108              		.align	2
 14109              		.set	.LANCHOR105,. + 0
 14112              	estimatedZVelocity:
 14113 0000 00000000 		.space	4
 14114              		.section	.data.est_errX,"aw",%progbits
 14115              		.align	2
 14116              		.set	.LANCHOR85,. + 0
 14119              	est_errX:
 14120 0000 0000B442 		.word	1119092736
 14121              		.section	.data.est_errY,"aw",%progbits
 14122              		.align	2
 14123              		.set	.LANCHOR88,. + 0
 14126              	est_errY:
 14127 0000 0000B442 		.word	1119092736
 14128              		.section	.bss.inFlight,"aw",%nobits
 14129              		.set	.LANCHOR8,. + 0
 14132              	inFlight:
 14133 0000 00       		.space	1
 14134              		.section	.bss.rawTemperature,"aw",%nobits
 14135              		.align	2
 14138              	rawTemperature:
 14139 0000 00000000 		.space	4
 14140              		.section	.bss.alt_buffer_pointer,"aw",%nobits
 14141              		.align	2
 14142              		.set	.LANCHOR95,. + 0
 14145              	alt_buffer_pointer:
 14146 0000 00000000 		.space	4
 14147              		.section	.bss.meanFreqCount,"aw",%nobits
 14150              	meanFreqCount:
 14151 0000 00       		.space	1
 14152              		.section	.bss.exInt,"aw",%nobits
 14153              		.align	2
 14154              		.set	.LANCHOR40,. + 0
 14157              	exInt:
 14158 0000 00000000 		.space	4
 14159              		.section	.bss.receiverXmitFactor,"aw",%nobits
 14160              		.align	2
 14161              		.set	.LANCHOR55,. + 0
 14164              	receiverXmitFactor:
 14165 0000 00000000 		.space	4
 14166              		.section	.bss.rawPressureSum,"aw",%nobits
 14167              		.align	2
 14168              		.set	.LANCHOR67,. + 0
 14171              	rawPressureSum:
 14172 0000 00000000 		.space	4
 14173              		.section	.bss.accelOneG,"aw",%nobits
 14174              		.align	2
 14175              		.set	.LANCHOR31,. + 0
 14178              	accelOneG:
 14179 0000 00000000 		.space	4
 14180              		.section	.bss.hokuyoHoldThrottleCorrection_Y,"aw",%nobits
 14181              		.align	2
 14182              		.set	.LANCHOR117,. + 0
 14185              	hokuyoHoldThrottleCorrection_Y:
 14186 0000 00000000 		.space	4
 14187              		.section	.data.maxThrottleAdjust,"aw",%progbits
 14188              		.align	2
 14189              		.set	.LANCHOR114,. + 0
 14192              	maxThrottleAdjust:
 14193 0000 32000000 		.word	50
 14194              		.section	.bss.LidarHoldThrottle,"aw",%nobits
 14195              		.align	2
 14196              		.set	.LANCHOR103,. + 0
 14199              	LidarHoldThrottle:
 14200 0000 00000000 		.space	4
 14201              		.section	.bss.gyroLastMesuredTime,"aw",%nobits
 14202              		.align	2
 14203              		.set	.LANCHOR21,. + 0
 14206              	gyroLastMesuredTime:
 14207 0000 00000000 		.space	4
 14208              		.section	.bss.gyroSampleCount,"aw",%nobits
 14209              		.set	.LANCHOR25,. + 0
 14212              	gyroSampleCount:
 14213 0000 00       		.space	1
 14214              		.section	.bss.lastReceiverChannel,"aw",%nobits
 14215              		.align	2
 14216              		.set	.LANCHOR0,. + 0
 14219              	lastReceiverChannel:
 14220 0000 00000000 		.space	4
 14221              		.section	.bss.MS5611Prom,"aw",%nobits
 14222              		.align	1
 14223              		.set	.LANCHOR61,. + 0
 14226              	MS5611Prom:
 14227 0000 00000000 		.space	16
 14227      00000000 
 14227      00000000 
 14227      00000000 
 14228              		.section	.bss.zDirection,"aw",%nobits
 14229              		.set	.LANCHOR101,. + 0
 14232              	zDirection:
 14233 0000 00       		.space	1
 14234              		.section	.bss.baroAltitudeToHoldTarget,"aw",%nobits
 14235              		.align	2
 14236              		.set	.LANCHOR99,. + 0
 14239              	baroAltitudeToHoldTarget:
 14240 0000 00000000 		.space	4
 14241              		.section	.bss.alt_Sum,"aw",%nobits
 14242              		.align	2
 14243              		.set	.LANCHOR96,. + 0
 14246              	alt_Sum:
 14247 0000 00000000 		.space	4
 14248              		.section	.bss.receiverZero,"aw",%nobits
 14249              		.align	2
 14250              		.set	.LANCHOR3,. + 0
 14253              	receiverZero:
 14254 0000 00000000 		.space	12
 14254      00000000 
 14254      00000000 
 14255              		.section	.bss.motorAxisCommandYaw,"aw",%nobits
 14256              		.align	2
 14257              		.set	.LANCHOR93,. + 0
 14260              	motorAxisCommandYaw:
 14261 0000 00000000 		.space	4
 14262              		.section	.bss.previousFlightMode,"aw",%nobits
 14263              		.set	.LANCHOR141,. + 0
 14266              	previousFlightMode:
 14267 0000 00       		.space	1
 14268              		.section	.bss.lowPriorityTenHZpreviousTime,"aw",%nobits
 14269              		.align	2
 14270              		.set	.LANCHOR161,. + 0
 14273              	lowPriorityTenHZpreviousTime:
 14274 0000 00000000 		.space	4
 14275              		.section	.bss.channelCal,"aw",%nobits
 14276              		.align	2
 14277              		.set	.LANCHOR143,. + 0
 14280              	channelCal:
 14281 0000 00000000 		.space	4
 14282              		.section	.bss.motorMinCommand,"aw",%nobits
 14283              		.align	2
 14284              		.set	.LANCHOR126,. + 0
 14287              	motorMinCommand:
 14288 0000 00000000 		.space	16
 14288      00000000 
 14288      00000000 
 14288      00000000 
 14289              		.section	.bss.HokuyoPositionToHoldTarget_Y,"aw",%nobits
 14290              		.align	2
 14291              		.set	.LANCHOR115,. + 0
 14294              	HokuyoPositionToHoldTarget_Y:
 14295 0000 00000000 		.space	4
 14296              		.section	.bss.gyroAngle,"aw",%nobits
 14297              		.align	2
 14298              		.set	.LANCHOR34,. + 0
 14301              	gyroAngle:
 14302 0000 00000000 		.space	8
 14302      00000000 
 14303              		.section	.data.queryType,"aw",%progbits
 14304              		.set	.LANCHOR142,. + 0
 14307              	queryType:
 14308 0000 58       		.byte	88
 14309              		.section	.bss.earthAccel,"aw",%nobits
 14310              		.align	2
 14313              	earthAccel:
 14314 0000 00000000 		.space	12
 14314      00000000 
 14314      00000000 
 14315              		.section	.bss.receiverOffset,"aw",%nobits
 14316              		.align	2
 14317              		.set	.LANCHOR5,. + 0
 14320              	receiverOffset:
 14321 0000 00000000 		.space	40
 14321      00000000 
 14321      00000000 
 14321      00000000 
 14321      00000000 
 14322              		.section	.bss.baroStartTime,"aw",%nobits
 14323              		.align	2
 14324              		.set	.LANCHOR76,. + 0
 14327              	baroStartTime:
 14328 0000 00000000 		.space	4
 14329              		.section	.bss.setHeading,"aw",%nobits
 14330              		.align	2
 14331              		.set	.LANCHOR132,. + 0
 14334              	setHeading:
 14335 0000 00000000 		.space	4
 14336              		.section	.bss.rawPressureSumCount,"aw",%nobits
 14337              		.set	.LANCHOR68,. + 0
 14340              	rawPressureSumCount:
 14341 0000 00       		.space	1
 14342              		.section	.bss.kinematicsType,"aw",%nobits
 14345              	kinematicsType:
 14346 0000 00       		.space	1
 14347              		.section	.bss.PID,"aw",%nobits
 14348              		.align	2
 14349              		.set	.LANCHOR9,. + 0
 14352              	PID:
 14353 0000 00000000 		.space	392
 14353      00000000 
 14353      00000000 
 14353      00000000 
 14353      00000000 
 14354              		.section	.bss.meterPerSecSec,"aw",%nobits
 14355              		.align	2
 14356              		.set	.LANCHOR26,. + 0
 14359              	meterPerSecSec:
 14360 0000 00000000 		.space	12
 14360      00000000 
 14360      00000000 
 14361              		.section	.bss.isAltitudeHoldInitialized,"aw",%nobits
 14362              		.set	.LANCHOR129,. + 0
 14365              	isAltitudeHoldInitialized:
 14366 0000 00       		.space	1
 14367              		.section	.bss.Hokuyo_str,"aw",%nobits
 14368              		.align	2
 14369              		.set	.LANCHOR82,. + 0
 14372              	Hokuyo_str:
 14373 0000 00000000 		.space	36
 14373      00000000 
 14373      00000000 
 14373      00000000 
 14373      00000000 
 14374              		.section	.bss.receiverSlope,"aw",%nobits
 14375              		.align	2
 14376              		.set	.LANCHOR4,. + 0
 14379              	receiverSlope:
 14380 0000 00000000 		.space	40
 14380      00000000 
 14380      00000000 
 14380      00000000 
 14380      00000000 
 14381              		.section	.bss.pulseWidth,"aw",%nobits
 14382              		.align	2
 14385              	pulseWidth:
 14386 0000 00000000 		.space	4
 14387              		.section	.bss.vehicleState,"aw",%nobits
 14388              		.align	2
 14389              		.set	.LANCHOR13,. + 0
 14392              	vehicleState:
 14393 0000 00000000 		.space	4
 14394              		.section	.data.testCommand,"aw",%progbits
 14395              		.align	2
 14396              		.set	.LANCHOR122,. + 0
 14399              	testCommand:
 14400 0000 E8030000 		.word	1000
 14401              		.section	.data.altitudeHoldThrottle,"aw",%progbits
 14402              		.align	2
 14403              		.set	.LANCHOR104,. + 0
 14406              	altitudeHoldThrottle:
 14407 0000 E8030000 		.word	1000
 14408              		.section	.bss.safetyCheck,"aw",%nobits
 14409              		.set	.LANCHOR124,. + 0
 14412              	safetyCheck:
 14413 0000 00       		.space	1
 14414              		.section	.bss.PitchVelocityDirection,"aw",%nobits
 14415              		.align	2
 14416              		.set	.LANCHOR118,. + 0
 14419              	PitchVelocityDirection:
 14420 0000 00000000 		.space	4
 14421              		.section	.bss.MS5611lastRawPressure,"aw",%nobits
 14422              		.align	2
 14423              		.set	.LANCHOR65,. + 0
 14426              	MS5611lastRawPressure:
 14427 0000 00000000 		.space	4
 14428              		.section	.data.G_Dt,"aw",%progbits
 14429              		.align	2
 14430              		.set	.LANCHOR48,. + 0
 14433              	G_Dt:
 14434 0000 6F12033B 		.word	990057071
 14435              		.section	.bss.hundredHZpreviousTime,"aw",%nobits
 14436              		.align	2
 14437              		.set	.LANCHOR149,. + 0
 14440              	hundredHZpreviousTime:
 14441 0000 00000000 		.space	4
 14442              		.section	.bss.maxLimit,"aw",%nobits
 14445              	maxLimit:
 14446 0000 00       		.space	1
 14447              		.section	.bss.currentTime,"aw",%nobits
 14448              		.align	2
 14449              		.set	.LANCHOR7,. + 0
 14452              	currentTime:
 14453 0000 00000000 		.space	4
 14454              		.section	.bss.count,"aw",%nobits
 14455              		.align	2
 14458              	count:
 14459 0000 00000000 		.space	4
 14460              		.section	.bss.gyroScaleFactor,"aw",%nobits
 14461              		.align	2
 14462              		.set	.LANCHOR18,. + 0
 14465              	gyroScaleFactor:
 14466 0000 00000000 		.space	4
 14467              		.section	.bss.aref,"aw",%nobits
 14468              		.align	2
 14469              		.set	.LANCHOR140,. + 0
 14472              	aref:
 14473 0000 00000000 		.space	4
 14474              		.section	.bss.bit_array,"aw",%nobits
 14475              		.set	.LANCHOR83,. + 0
 14478              	bit_array:
 14479 0000 00000000 		.space	18
 14479      00000000 
 14479      00000000 
 14479      00000000 
 14479      0000
 14480              		.section	.bss.motorMaxCommand,"aw",%nobits
 14481              		.align	2
 14482              		.set	.LANCHOR127,. + 0
 14485              	motorMaxCommand:
 14486 0000 00000000 		.space	16
 14486      00000000 
 14486      00000000 
 14486      00000000 
 14487              		.section	.bss.previousMeasureCriticalSensorsTime,"aw",%nobits
 14488              		.align	2
 14489              		.set	.LANCHOR32,. + 0
 14492              	previousMeasureCriticalSensorsTime:
 14493 0000 00000000 		.space	4
 14494              		.section	.bss._ZL19_stm32_motor_number,"aw",%nobits
 14495              		.align	2
 14496              		.set	.LANCHOR58,. + 0
 14499              	_ZL19_stm32_motor_number:
 14500 0000 00000000 		.space	4
 14501              		.section	.bss.gyroZero,"aw",%nobits
 14502              		.align	2
 14503              		.set	.LANCHOR23,. + 0
 14506              	gyroZero:
 14507 0000 00000000 		.space	12
 14507      00000000 
 14507      00000000 
 14508              		.section	.bss.runTimeAccelBias,"aw",%nobits
 14509              		.align	2
 14510              		.set	.LANCHOR28,. + 0
 14513              	runTimeAccelBias:
 14514 0000 00000000 		.space	12
 14514      00000000 
 14514      00000000 
 14515              		.text
 14516              	.Letext0:
 14517              		.file 36 "/home/asim/opt/arm-2011.09/bin/../lib/gcc/arm-none-eabi/4.6.1/../../../../arm-none-eabi/
 14518              		.file 37 "../Libmaple/libmaple/libmaple/libmaple_types.h"
 14519              		.file 38 "../Libmaple/libmaple/libmaple/rccF2.h"
 14520              		.file 39 "../Libmaple/libmaple/libmaple/gpioF2.h"
 14521              		.file 40 "../Libmaple/libmaple/libmaple/adc.h"
 14522              		.file 41 "../Libmaple/libmaple/wirish/wirish_types.h"
 14523              		.file 42 "../Libmaple/libmaple/wirish/io.h"
 14524              		.file 43 "../Libmaple/libmaple/libmaple/spi.h"
 14525              		.file 44 "../Libmaple/libmaple/wirish/comm/HardwareSPI.h"
 14526              		.file 45 "../Libmaple/libmaple/wirish/wirish.h"
 14527              		.file 46 "../AeroQuad32/MapleCompatibility/WProgram.h"
 14528              		.file 47 "../AeroQuad32/MapleCompatibility/flash_stm32.h"
 14529              		.file 48 "../AeroQuad32/MapleCompatibility/EEPROM.h"
 14530              		.file 49 "../Libraries/AQ_Gps/GpsDataType.h"
 14531              		.file 50 "../Libmaple/libmaple/wirish/Print.h"
 14532              		.file 51 "../Libmaple/libmaple/wirish/boards.h"
 14533              		.file 52 "../Libmaple/libmaple/wirish/comm/HardwareSerial.h"
 14534              		.file 53 "../AeroQuad32/AeroQuad_STM32.h"
 14535              		.file 54 "../Libraries/AQ_Defines/SensorsStatus.h"
 14536              		.file 55 "../Libraries/AQ_Gyroscope/Gyroscope.h"
 14537              		.file 56 "../Libraries/AQ_Accelerometer/Accelerometer.h"
 14538              		.file 57 "../Libraries/AQ_FlightControlProcessor/FlightControlVariable.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AeroQuadMain.cpp
     /tmp/cclmCDqy.s:20     .text.systick_get_count:00000000 $t
     /tmp/cclmCDqy.s:24     .text.systick_get_count:00000000 systick_get_count
     /tmp/cclmCDqy.s:40     .text.systick_get_count:00000008 $d
     /tmp/cclmCDqy.s:45     .text._ZL6millisv:00000000 $t
     /tmp/cclmCDqy.s:49     .text._ZL6millisv:00000000 _ZL6millisv
     /tmp/cclmCDqy.s:69     .text._ZL6millisv:00000008 $d
     /tmp/cclmCDqy.s:74     .text._ZL6microsv:00000000 $t
     /tmp/cclmCDqy.s:78     .text._ZL6microsv:00000000 _ZL6microsv
     /tmp/cclmCDqy.s:148    .text._ZL6microsv:00000040 $d
     /tmp/cclmCDqy.s:153    .text.timer_set_compare.isra.2:00000000 $t
     /tmp/cclmCDqy.s:157    .text.timer_set_compare.isra.2:00000000 timer_set_compare.isra.2
     /tmp/cclmCDqy.s:180    .text.startup._Z7premainv:00000000 $t
     /tmp/cclmCDqy.s:185    .text.startup._Z7premainv:00000000 _Z7premainv
     /tmp/cclmCDqy.s:200    .init_array:00000000 $d
     /tmp/cclmCDqy.s:203    .text._init:00000000 $t
     /tmp/cclmCDqy.s:208    .text._init:00000000 _init
     /tmp/cclmCDqy.s:221    .text._ZN7TwoWire4readEv:00000000 $t
     /tmp/cclmCDqy.s:226    .text._ZN7TwoWire4readEv:00000000 _ZN7TwoWire4readEv
     /tmp/cclmCDqy.s:242    .text._ZN7TwoWire5writeEi:00000000 $t
     /tmp/cclmCDqy.s:247    .text._ZN7TwoWire5writeEi:00000000 _ZN7TwoWire5writeEi
     /tmp/cclmCDqy.s:263    .text._Z23initializeReceiverParami:00000000 $t
     /tmp/cclmCDqy.s:268    .text._Z23initializeReceiverParami:00000000 _Z23initializeReceiverParami
     /tmp/cclmCDqy.s:418    .text._Z23initializeReceiverParami:00000098 $d
     /tmp/cclmCDqy.s:429    .text._Z17getReceiverSIDatah:00000000 $t
     /tmp/cclmCDqy.s:434    .text._Z17getReceiverSIDatah:00000000 _Z17getReceiverSIDatah
     /tmp/cclmCDqy.s:461    .text._Z17getReceiverSIDatah:00000024 $d
     /tmp/cclmCDqy.s:468    .text._Z9updatePIDffP7PIDdata:00000000 $t
     /tmp/cclmCDqy.s:473    .text._Z9updatePIDffP7PIDdata:00000000 _Z9updatePIDffP7PIDdata
     /tmp/cclmCDqy.s:570    .text._Z9updatePIDffP7PIDdata:000000ac $d
     /tmp/cclmCDqy.s:578    .text._Z17zeroIntegralErrorv:00000000 $t
     /tmp/cclmCDqy.s:583    .text._Z17zeroIntegralErrorv:00000000 _Z17zeroIntegralErrorv
     /tmp/cclmCDqy.s:632    .text._Z17zeroIntegralErrorv:00000034 $d
     /tmp/cclmCDqy.s:638    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 $t
     /tmp/cclmCDqy.s:643    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 _Z18computeFourthOrderfP15fourthOrderData
     /tmp/cclmCDqy.s:708    .text._Z18computeFourthOrderfP15fourthOrderData:00000088 $d
     /tmp/cclmCDqy.s:719    .text._Z16setupFourthOrderv:00000000 $t
     /tmp/cclmCDqy.s:724    .text._Z16setupFourthOrderv:00000000 _Z16setupFourthOrderv
     /tmp/cclmCDqy.s:789    .text._Z16setupFourthOrderv:00000038 $d
     /tmp/cclmCDqy.s:795    .text._ZN14HardwareSPIExt5SetCSEi:00000000 $t
     /tmp/cclmCDqy.s:800    .text._ZN14HardwareSPIExt5SetCSEi:00000000 _ZN14HardwareSPIExt5SetCSEi
     /tmp/cclmCDqy.s:817    .text._ZN14HardwareSPIExtC2Ej:00000000 $t
     /tmp/cclmCDqy.s:822    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC2Ej
     /tmp/cclmCDqy.s:856    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 $t
     /tmp/cclmCDqy.s:861    .text._ZN14HardwareSPIExt5beginE12SPIFrequencyjj:00000000 _ZN14HardwareSPIExt5beginE12SPIFrequencyjj
     /tmp/cclmCDqy.s:908    .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 $t
     /tmp/cclmCDqy.s:913    .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 _ZN14HardwareSPIExt4ReadEiPhi
     /tmp/cclmCDqy.s:978    .text._ZN14HardwareSPIExt4ReadEi:00000000 $t
     /tmp/cclmCDqy.s:983    .text._ZN14HardwareSPIExt4ReadEi:00000000 _ZN14HardwareSPIExt4ReadEi
     /tmp/cclmCDqy.s:1011   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 $t
     /tmp/cclmCDqy.s:1016   .text._ZN14HardwareSPIExt5WriteEiPhi:00000000 _ZN14HardwareSPIExt5WriteEiPhi
     /tmp/cclmCDqy.s:1080   .text._ZN14HardwareSPIExt5WriteEih:00000000 $t
     /tmp/cclmCDqy.s:1085   .text._ZN14HardwareSPIExt5WriteEih:00000000 _ZN14HardwareSPIExt5WriteEih
     /tmp/cclmCDqy.s:1116   .text._Z19MPU6000_SpiLowSpeedv:00000000 $t
     /tmp/cclmCDqy.s:1121   .text._Z19MPU6000_SpiLowSpeedv:00000000 _Z19MPU6000_SpiLowSpeedv
     /tmp/cclmCDqy.s:1140   .text._Z19MPU6000_SpiLowSpeedv:0000000c $d
     /tmp/cclmCDqy.s:1145   .text._Z20MPU6000_SpiHighSpeedv:00000000 $t
     /tmp/cclmCDqy.s:1150   .text._Z20MPU6000_SpiHighSpeedv:00000000 _Z20MPU6000_SpiHighSpeedv
     /tmp/cclmCDqy.s:1177   .text._Z20MPU6000_SpiHighSpeedv:0000001c $d
     /tmp/cclmCDqy.s:1182   .text._Z16MPU6000_WriteRegih:00000000 $t
     /tmp/cclmCDqy.s:1187   .text._Z16MPU6000_WriteRegih:00000000 _Z16MPU6000_WriteRegih
     /tmp/cclmCDqy.s:1218   .text._Z16MPU6000_WriteRegih:00000018 $d
     /tmp/cclmCDqy.s:1223   .text._Z15MPU6000_ReadRegi:00000000 $t
     /tmp/cclmCDqy.s:1228   .text._Z15MPU6000_ReadRegi:00000000 _Z15MPU6000_ReadRegi
     /tmp/cclmCDqy.s:1261   .text._Z15MPU6000_ReadRegi:00000018 $d
     /tmp/cclmCDqy.s:1266   .text._Z24initializeMPU6000Sensorsv:00000000 $t
     /tmp/cclmCDqy.s:1271   .text._Z24initializeMPU6000Sensorsv:00000000 _Z24initializeMPU6000Sensorsv
     /tmp/cclmCDqy.s:1357   .text._Z24initializeMPU6000Sensorsv:0000007c $d
     /tmp/cclmCDqy.s:1364   .text._Z15MPU6000SwapDataPhi:00000000 $t
     /tmp/cclmCDqy.s:1369   .text._Z15MPU6000SwapDataPhi:00000000 _Z15MPU6000SwapDataPhi
     /tmp/cclmCDqy.s:1413   .text._Z18readMPU6000Sensorsv:00000000 $t
     /tmp/cclmCDqy.s:1418   .text._Z18readMPU6000Sensorsv:00000000 _Z18readMPU6000Sensorsv
     /tmp/cclmCDqy.s:1446   .text._Z18readMPU6000Sensorsv:0000001c $d
     /tmp/cclmCDqy.s:1452   .text._Z16readMPU6000Accelv:00000000 $t
     /tmp/cclmCDqy.s:1457   .text._Z16readMPU6000Accelv:00000000 _Z16readMPU6000Accelv
     /tmp/cclmCDqy.s:1496   .text._Z16readMPU6000Accelv:00000020 $d
     /tmp/cclmCDqy.s:1502   .text._Z15readMPU6000Gyrov:00000000 $t
     /tmp/cclmCDqy.s:1507   .text._Z15readMPU6000Gyrov:00000000 _Z15readMPU6000Gyrov
     /tmp/cclmCDqy.s:1545   .text._Z15readMPU6000Gyrov:00000020 $d
     /tmp/cclmCDqy.s:1551   .text._Z14initializeGyrov:00000000 $t
     /tmp/cclmCDqy.s:1556   .text._Z14initializeGyrov:00000000 _Z14initializeGyrov
     /tmp/cclmCDqy.s:1578   .text._Z14initializeGyrov:0000000c $d
     /tmp/cclmCDqy.s:1585   .text._Z17gyroUpdateHeadingv:00000000 $t
     /tmp/cclmCDqy.s:1590   .text._Z17gyroUpdateHeadingv:00000000 _Z17gyroUpdateHeadingv
     /tmp/cclmCDqy.s:1639   .text._Z17gyroUpdateHeadingv:00000050 $d
     /tmp/cclmCDqy.s:1649   .text._Z11measureGyrov:00000000 $t
     /tmp/cclmCDqy.s:1654   .text._Z11measureGyrov:00000000 _Z11measureGyrov
     /tmp/cclmCDqy.s:1738   .text._Z11measureGyrov:00000074 $d
     /tmp/cclmCDqy.s:1748   .text._Z14measureGyroSumv:00000000 $t
     /tmp/cclmCDqy.s:1753   .text._Z14measureGyroSumv:00000000 _Z14measureGyroSumv
     /tmp/cclmCDqy.s:1799   .text._Z14measureGyroSumv:0000003c $d
     /tmp/cclmCDqy.s:1807   .text._Z16evaluateGyroRatev:00000000 $t
     /tmp/cclmCDqy.s:1812   .text._Z16evaluateGyroRatev:00000000 _Z16evaluateGyroRatev
     /tmp/cclmCDqy.s:1909   .text._Z16evaluateGyroRatev:00000080 $d
     /tmp/cclmCDqy.s:1919   .text._Z13calibrateGyrov:00000000 $t
     /tmp/cclmCDqy.s:1924   .text._Z13calibrateGyrov:00000000 _Z13calibrateGyrov
     /tmp/cclmCDqy.s:2031   .text._Z13calibrateGyrov:00000060 $d
     /tmp/cclmCDqy.s:2037   .text._Z15initializeAccelv:00000000 $t
     /tmp/cclmCDqy.s:2042   .text._Z15initializeAccelv:00000000 _Z15initializeAccelv
     /tmp/cclmCDqy.s:2057   .text._Z12measureAccelv:00000000 $t
     /tmp/cclmCDqy.s:2062   .text._Z12measureAccelv:00000000 _Z12measureAccelv
     /tmp/cclmCDqy.s:2119   .text._Z12measureAccelv:00000064 $d
     /tmp/cclmCDqy.s:2127   .text._Z15measureAccelSumv:00000000 $t
     /tmp/cclmCDqy.s:2132   .text._Z15measureAccelSumv:00000000 _Z15measureAccelSumv
     /tmp/cclmCDqy.s:2176   .text._Z15measureAccelSumv:00000038 $d
     /tmp/cclmCDqy.s:2183   .text._Z20evaluateMetersPerSecv:00000000 $t
     /tmp/cclmCDqy.s:2188   .text._Z20evaluateMetersPerSecv:00000000 _Z20evaluateMetersPerSecv
     /tmp/cclmCDqy.s:2248   .text._Z20evaluateMetersPerSecv:00000048 $d
     /tmp/cclmCDqy.s:2257   .text._Z16computeAccelBiasv:00000000 $t
     /tmp/cclmCDqy.s:2262   .text._Z16computeAccelBiasv:00000000 _Z16computeAccelBiasv
     /tmp/cclmCDqy.s:2366   .text._Z16computeAccelBiasv:000000a0 $d
     /tmp/cclmCDqy.s:2379   .text._Z12initPlatformv:00000000 $t
     /tmp/cclmCDqy.s:2384   .text._Z12initPlatformv:00000000 _Z12initPlatformv
     /tmp/cclmCDqy.s:2500   .text._Z12initPlatformv:000000b0 $d
     /tmp/cclmCDqy.s:2507   .text._Z42initializePlatformSpecificAccelCalibrationv:00000000 $t
     /tmp/cclmCDqy.s:2512   .text._Z42initializePlatformSpecificAccelCalibrationv:00000000 _Z42initializePlatformSpecificAccelCalibrationv
     /tmp/cclmCDqy.s:2537   .text._Z42initializePlatformSpecificAccelCalibrationv:00000010 $d
     /tmp/cclmCDqy.s:2545   .text._Z22measureCriticalSensorsv:00000000 $t
     /tmp/cclmCDqy.s:2550   .text._Z22measureCriticalSensorsv:00000000 _Z22measureCriticalSensorsv
     /tmp/cclmCDqy.s:2583   .text._Z22measureCriticalSensorsv:00000020 $d
     /tmp/cclmCDqy.s:2589   .text._Z29initializeBaseKinematicsParamv:00000000 $t
     /tmp/cclmCDqy.s:2594   .text._Z29initializeBaseKinematicsParamv:00000000 _Z29initializeBaseKinematicsParamv
     /tmp/cclmCDqy.s:2630   .text._Z29initializeBaseKinematicsParamv:00000014 $d
     /tmp/cclmCDqy.s:2636   .text._Z27kinematicsGetDegreesHeadingh:00000000 $t
     /tmp/cclmCDqy.s:2641   .text._Z27kinematicsGetDegreesHeadingh:00000000 _Z27kinematicsGetDegreesHeadingh
     /tmp/cclmCDqy.s:2673   .text._Z27kinematicsGetDegreesHeadingh:0000002c $d
     /tmp/cclmCDqy.s:2682   .text._Z9argUpdatefffffff:00000000 $t
     /tmp/cclmCDqy.s:2687   .text._Z9argUpdatefffffff:00000000 _Z9argUpdatefffffff
     /tmp/cclmCDqy.s:3003   .text._Z9argUpdatefffffff:0000024c $d
     /tmp/cclmCDqy.s:3020   .text._Z11eulerAnglesv:00000000 $t
     /tmp/cclmCDqy.s:3025   .text._Z11eulerAnglesv:00000000 _Z11eulerAnglesv
     /tmp/cclmCDqy.s:3130   .text._Z11eulerAnglesv:000000f8 $d
     /tmp/cclmCDqy.s:3139   .text._Z20initializeKinematicsv:00000000 $t
     /tmp/cclmCDqy.s:3144   .text._Z20initializeKinematicsv:00000000 _Z20initializeKinematicsv
     /tmp/cclmCDqy.s:3214   .text._Z20initializeKinematicsv:00000044 $d
     /tmp/cclmCDqy.s:3232   .text._Z19calculateKinematicsfffffff:00000000 $t
     /tmp/cclmCDqy.s:3237   .text._Z19calculateKinematicsfffffff:00000000 _Z19calculateKinematicsfffffff
     /tmp/cclmCDqy.s:3271   .text._Z19calculateKinematicsfffffff:00000028 $d
     /tmp/cclmCDqy.s:3276   .text._Z13getGyroUnbiash:00000000 $t
     /tmp/cclmCDqy.s:3281   .text._Z13getGyroUnbiash:00000000 _Z13getGyroUnbiash
     /tmp/cclmCDqy.s:3299   .text._Z13getGyroUnbiash:0000000c $d
     /tmp/cclmCDqy.s:3304   .text._Z19calibrateKinematicsv:00000000 $t
     /tmp/cclmCDqy.s:3309   .text._Z19calibrateKinematicsv:00000000 _Z19calibrateKinematicsv
     /tmp/cclmCDqy.s:3322   .text._Z7FrqInitiiPV8tFrqDataP9timer_devi:00000000 $t
     /tmp/cclmCDqy.s:3327   .text._Z7FrqInitiiPV8tFrqDataP9timer_devi:00000000 _Z7FrqInitiiPV8tFrqDataP9timer_devi
     /tmp/cclmCDqy.s:3461   .text._Z7FrqInitiiPV8tFrqDataP9timer_devi:000000a8 $d
     /tmp/cclmCDqy.s:3466   .text._Z18InitFrqMeasurementv:00000000 $t
     /tmp/cclmCDqy.s:3471   .text._Z18InitFrqMeasurementv:00000000 _Z18InitFrqMeasurementv
     /tmp/cclmCDqy.s:3543   .text._Z18InitFrqMeasurementv:0000004c $d
     /tmp/cclmCDqy.s:3551   .text._Z17PWMInvertPolarityPV8tFrqData:00000000 $t
     /tmp/cclmCDqy.s:3556   .text._Z17PWMInvertPolarityPV8tFrqData:00000000 _Z17PWMInvertPolarityPV8tFrqData
     /tmp/cclmCDqy.s:3576   .text._Z9FrqChangePV8tFrqData:00000000 $t
     /tmp/cclmCDqy.s:3581   .text._Z9FrqChangePV8tFrqData:00000000 _Z9FrqChangePV8tFrqData
     /tmp/cclmCDqy.s:3675   .text._Z14IrqChangeValuei:00000000 $t
     /tmp/cclmCDqy.s:3680   .text._Z14IrqChangeValuei:00000000 _Z14IrqChangeValuei
     /tmp/cclmCDqy.s:3699   .text._Z14IrqChangeValuei:0000000c $d
     /tmp/cclmCDqy.s:3704   .text._Z8PWM_in_7v:00000000 $t
     /tmp/cclmCDqy.s:3709   .text._Z8PWM_in_7v:00000000 _Z8PWM_in_7v
     /tmp/cclmCDqy.s:3723   .text._Z8PWM_in_6v:00000000 $t
     /tmp/cclmCDqy.s:3728   .text._Z8PWM_in_6v:00000000 _Z8PWM_in_6v
     /tmp/cclmCDqy.s:3742   .text._Z8PWM_in_5v:00000000 $t
     /tmp/cclmCDqy.s:3747   .text._Z8PWM_in_5v:00000000 _Z8PWM_in_5v
     /tmp/cclmCDqy.s:3761   .text._Z8PWM_in_4v:00000000 $t
     /tmp/cclmCDqy.s:3766   .text._Z8PWM_in_4v:00000000 _Z8PWM_in_4v
     /tmp/cclmCDqy.s:3780   .text._Z8PWM_in_3v:00000000 $t
     /tmp/cclmCDqy.s:3785   .text._Z8PWM_in_3v:00000000 _Z8PWM_in_3v
     /tmp/cclmCDqy.s:3799   .text._Z8PWM_in_2v:00000000 $t
     /tmp/cclmCDqy.s:3804   .text._Z8PWM_in_2v:00000000 _Z8PWM_in_2v
     /tmp/cclmCDqy.s:3818   .text._Z8PWM_in_1v:00000000 $t
     /tmp/cclmCDqy.s:3823   .text._Z8PWM_in_1v:00000000 _Z8PWM_in_1v
     /tmp/cclmCDqy.s:3837   .text._Z8PWM_in_0v:00000000 $t
     /tmp/cclmCDqy.s:3842   .text._Z8PWM_in_0v:00000000 _Z8PWM_in_0v
     /tmp/cclmCDqy.s:3856   .text._Z18initializeReceiveri:00000000 $t
     /tmp/cclmCDqy.s:3861   .text._Z18initializeReceiveri:00000000 _Z18initializeReceiveri
     /tmp/cclmCDqy.s:3884   .text._Z18getRawChannelValueh:00000000 $t
     /tmp/cclmCDqy.s:3889   .text._Z18getRawChannelValueh:00000000 _Z18getRawChannelValueh
     /tmp/cclmCDqy.s:3931   .text._Z18getRawChannelValueh:0000001c $d
     /tmp/cclmCDqy.s:3937   .text._Z12readReceiverv:00000000 $t
     /tmp/cclmCDqy.s:3942   .text._Z12readReceiverv:00000000 _Z12readReceiverv
     /tmp/cclmCDqy.s:4076   .text._Z12readReceiverv:000000cc $d
     /tmp/cclmCDqy.s:4089   .text._Z15setChannelValuehi:00000000 $t
     /tmp/cclmCDqy.s:4094   .text._Z15setChannelValuehi:00000000 _Z15setChannelValuehi
     /tmp/cclmCDqy.s:4108   .text._Z11writeMotorsv:00000000 $t
     /tmp/cclmCDqy.s:4113   .text._Z11writeMotorsv:00000000 _Z11writeMotorsv
     /tmp/cclmCDqy.s:4164   .text._Z11writeMotorsv:00000030 $d
     /tmp/cclmCDqy.s:4172   .text._Z16commandAllMotorsi:00000000 $t
     /tmp/cclmCDqy.s:4177   .text._Z16commandAllMotorsi:00000000 _Z16commandAllMotorsi
     /tmp/cclmCDqy.s:4227   .text._Z16commandAllMotorsi:0000002c $d
     /tmp/cclmCDqy.s:4234   .text._Z16initializeMotors9NB_Motors:00000000 $t
     /tmp/cclmCDqy.s:4239   .text._Z16initializeMotors9NB_Motors:00000000 _Z16initializeMotors9NB_Motors
     /tmp/cclmCDqy.s:4391   .text._Z16initializeMotors9NB_Motors:0000007c $d
     /tmp/cclmCDqy.s:4400   .text._Z11pulseMotorsh:00000000 $t
     /tmp/cclmCDqy.s:4405   .text._Z11pulseMotorsh:00000000 _Z11pulseMotorsh
     /tmp/cclmCDqy.s:4456   .text._Z15getBaroAltitudev:00000000 $t
     /tmp/cclmCDqy.s:4461   .text._Z15getBaroAltitudev:00000000 _Z15getBaroAltitudev
     /tmp/cclmCDqy.s:4481   .text._Z15getBaroAltitudev:00000018 $d
     /tmp/cclmCDqy.s:4487   .text._Z10MS5611crc4Pt:00000000 $t
     /tmp/cclmCDqy.s:4492   .text._Z10MS5611crc4Pt:00000000 _Z10MS5611crc4Pt
     /tmp/cclmCDqy.s:4580   .text._Z14MS5611readPROMi:00000000 $t
     /tmp/cclmCDqy.s:4585   .text._Z14MS5611readPROMi:00000000 _Z14MS5611readPROMi
     /tmp/cclmCDqy.s:4659   .text._Z14MS5611readPROMi:0000004c $d
     /tmp/cclmCDqy.s:4666   .text._Z11MS5611reseti:00000000 $t
     /tmp/cclmCDqy.s:4671   .text._Z11MS5611reseti:00000000 _Z11MS5611reseti
     /tmp/cclmCDqy.s:4689   .text._Z20MS5611readConversioni:00000000 $t
     /tmp/cclmCDqy.s:4694   .text._Z20MS5611readConversioni:00000000 _Z20MS5611readConversioni
     /tmp/cclmCDqy.s:4748   .text._Z20MS5611readConversioni:0000003c $d
     /tmp/cclmCDqy.s:4753   .text._Z21requestRawTemperaturev:00000000 $t
     /tmp/cclmCDqy.s:4758   .text._Z21requestRawTemperaturev:00000000 _Z21requestRawTemperaturev
     /tmp/cclmCDqy.s:4775   .text._Z18readRawTemperaturev:00000000 $t
     /tmp/cclmCDqy.s:4780   .text._Z18readRawTemperaturev:00000000 _Z18readRawTemperaturev
     /tmp/cclmCDqy.s:4855   .text._Z18readRawTemperaturev:0000006c $d
     /tmp/cclmCDqy.s:4864   .text._Z15readTemperaturev:00000000 $t
     /tmp/cclmCDqy.s:4869   .text._Z15readTemperaturev:00000000 _Z15readTemperaturev
     /tmp/cclmCDqy.s:4913   .text._Z15readTemperaturev:0000004c $d
     /tmp/cclmCDqy.s:4920   .text._Z18requestRawPressurev:00000000 $t
     /tmp/cclmCDqy.s:4925   .text._Z18requestRawPressurev:00000000 _Z18requestRawPressurev
     /tmp/cclmCDqy.s:4942   .text._Z15readRawPressurev:00000000 $t
     /tmp/cclmCDqy.s:4947   .text._Z15readRawPressurev:00000000 _Z15readRawPressurev
     /tmp/cclmCDqy.s:4996   .text._Z15readRawPressurev:00000054 $d
     /tmp/cclmCDqy.s:5004   .text._Z14measureBaroSumv:00000000 $t
     /tmp/cclmCDqy.s:5009   .text._Z14measureBaroSumv:00000000 _Z14measureBaroSumv
     /tmp/cclmCDqy.s:5085   .text._Z14measureBaroSumv:0000005c $d
     /tmp/cclmCDqy.s:5095   .text._Z20evaluateBaroAltitudev:00000000 $t
     /tmp/cclmCDqy.s:5100   .text._Z20evaluateBaroAltitudev:00000000 _Z20evaluateBaroAltitudev
     /tmp/cclmCDqy.s:5212   .text._Z20evaluateBaroAltitudev:000000b0 $d
     /tmp/cclmCDqy.s:5233   .text._Z11measureBarov:00000000 $t
     /tmp/cclmCDqy.s:5238   .text._Z11measureBarov:00000000 _Z11measureBarov
     /tmp/cclmCDqy.s:5259   .text._Z17measureGroundBarov:00000000 $t
     /tmp/cclmCDqy.s:5264   .text._Z17measureGroundBarov:00000000 _Z17measureGroundBarov
     /tmp/cclmCDqy.s:5316   .text._Z17measureGroundBarov:00000038 $d
     /tmp/cclmCDqy.s:5323   .text._Z14initializeBarov:00000000 $t
     /tmp/cclmCDqy.s:5328   .text._Z14initializeBarov:00000000 _Z14initializeBarov
     /tmp/cclmCDqy.s:5411   .text._Z14initializeBarov:00000070 $d
     /tmp/cclmCDqy.s:5424   .text._ZN9LIDARLiteC2Ev:00000000 $t
     /tmp/cclmCDqy.s:5429   .text._ZN9LIDARLiteC2Ev:00000000 _ZN9LIDARLiteC2Ev
     /tmp/cclmCDqy.s:5444   .text._ZN9LIDARLite5writeEccc:00000000 $t
     /tmp/cclmCDqy.s:5449   .text._ZN9LIDARLite5writeEccc:00000000 _ZN9LIDARLite5writeEccc
     /tmp/cclmCDqy.s:5496   .text._ZN9LIDARLite5writeEccc:00000030 $d
     /tmp/cclmCDqy.s:5501   .text._ZN9LIDARLite5resetEc:00000000 $t
     /tmp/cclmCDqy.s:5506   .text._ZN9LIDARLite5resetEc:00000000 _ZN9LIDARLite5resetEc
     /tmp/cclmCDqy.s:5528   .text._ZN9LIDARLite9configureEic:00000000 $t
     /tmp/cclmCDqy.s:5533   .text._ZN9LIDARLite9configureEic:00000000 _ZN9LIDARLite9configureEic
     /tmp/cclmCDqy.s:5555   .text._ZN9LIDARLite9configureEic:0000000e $d
     /tmp/cclmCDqy.s:5561   .text._ZN9LIDARLite9configureEic:00000014 $t
     /tmp/cclmCDqy.s:5666   .text._ZN9LIDARLite5beginEibc:00000000 $t
     /tmp/cclmCDqy.s:5671   .text._ZN9LIDARLite5beginEibc:00000000 _ZN9LIDARLite5beginEibc
     /tmp/cclmCDqy.s:5712   .text._ZN9LIDARLite5beginEibc:00000020 $d
     /tmp/cclmCDqy.s:5717   .text._ZN9LIDARLite4readEciPhbc:00000000 $t
     /tmp/cclmCDqy.s:5722   .text._ZN9LIDARLite4readEciPhbc:00000000 _ZN9LIDARLite4readEciPhbc
     /tmp/cclmCDqy.s:5868   .text._ZN9LIDARLite4readEciPhbc:000000b0 $d
     /tmp/cclmCDqy.s:5877   .text._ZN9LIDARLite8distanceEbc:00000000 $t
     /tmp/cclmCDqy.s:5882   .text._ZN9LIDARLite8distanceEbc:00000000 _ZN9LIDARLite8distanceEbc
     /tmp/cclmCDqy.s:5941   .text._ZN9LIDARLite25correlationRecordToSerialEcic:00000000 $t
     /tmp/cclmCDqy.s:5946   .text._ZN9LIDARLite25correlationRecordToSerialEcic:00000000 _ZN9LIDARLite25correlationRecordToSerialEcic
     /tmp/cclmCDqy.s:6041   .text._ZN9LIDARLite25correlationRecordToSerialEcic:0000006c $d
     /tmp/cclmCDqy.s:6046   .text._Z3kall:00000000 $t
     /tmp/cclmCDqy.s:6051   .text._Z3kall:00000000 _Z3kall
     /tmp/cclmCDqy.s:6099   .text._Z3kall:00000054 $d
     /tmp/cclmCDqy.s:6106   .text._Z8alt_readv:00000000 $t
     /tmp/cclmCDqy.s:6111   .text._Z8alt_readv:00000000 _Z8alt_readv
     /tmp/cclmCDqy.s:6141   .text._Z8alt_readv:00000024 $d
     /tmp/cclmCDqy.s:6147   .text._Z18boolean_to_decimalPb:00000000 $t
     /tmp/cclmCDqy.s:6152   .text._Z18boolean_to_decimalPb:00000000 _Z18boolean_to_decimalPb
     /tmp/cclmCDqy.s:6198   .text._Z11Init_Hokuyov:00000000 $t
     /tmp/cclmCDqy.s:6203   .text._Z11Init_Hokuyov:00000000 _Z11Init_Hokuyov
     /tmp/cclmCDqy.s:6219   .text._Z11Init_Hokuyov:0000000c $d
     /tmp/cclmCDqy.s:6224   .text._Z11Hokuyo_Readv:00000000 $t
     /tmp/cclmCDqy.s:6229   .text._Z11Hokuyo_Readv:00000000 _Z11Hokuyo_Readv
     /tmp/cclmCDqy.s:6359   .text._Z11Hokuyo_Readv:0000007c $d
     /tmp/cclmCDqy.s:6367   .text._Z11kal_hokuyoXl:00000000 $t
     /tmp/cclmCDqy.s:6372   .text._Z11kal_hokuyoXl:00000000 _Z11kal_hokuyoXl
     /tmp/cclmCDqy.s:6419   .text._Z11kal_hokuyoXl:00000054 $d
     /tmp/cclmCDqy.s:6426   .text._Z11kal_hokuyoYl:00000000 $t
     /tmp/cclmCDqy.s:6431   .text._Z11kal_hokuyoYl:00000000 _Z11kal_hokuyoYl
     /tmp/cclmCDqy.s:6478   .text._Z11kal_hokuyoYl:00000054 $d
     /tmp/cclmCDqy.s:6485   .text._Z17applyMotorCommandv:00000000 $t
     /tmp/cclmCDqy.s:6490   .text._Z17applyMotorCommandv:00000000 _Z17applyMotorCommandv
     /tmp/cclmCDqy.s:6542   .text._Z17applyMotorCommandv:00000038 $d
     /tmp/cclmCDqy.s:6551   .text._Z9movingAvgi:00000000 $t
     /tmp/cclmCDqy.s:6556   .text._Z9movingAvgi:00000000 _Z9movingAvgi
     /tmp/cclmCDqy.s:6614   .text._Z9movingAvgi:0000004c $d
     /tmp/cclmCDqy.s:6622   .text._Z19processAltitudeHoldv:00000000 $t
     /tmp/cclmCDqy.s:6627   .text._Z19processAltitudeHoldv:00000000 _Z19processAltitudeHoldv
     /tmp/cclmCDqy.s:6822   .text._Z19processAltitudeHoldv:0000012c $d
     /tmp/cclmCDqy.s:6843   .text._Z17processHokuyoHoldv:00000000 $t
     /tmp/cclmCDqy.s:6848   .text._Z17processHokuyoHoldv:00000000 _Z17processHokuyoHoldv
     /tmp/cclmCDqy.s:7068   .text._Z17processHokuyoHoldv:00000134 $d
     /tmp/cclmCDqy.s:7087   .text._Z20calculateFlightErrorv:00000000 $t
     /tmp/cclmCDqy.s:7092   .text._Z20calculateFlightErrorv:00000000 _Z20calculateFlightErrorv
     /tmp/cclmCDqy.s:7297   .text._Z20calculateFlightErrorv:000001a0 $d
     /tmp/cclmCDqy.s:7319   .text._Z19processCalibrateESCv:00000000 $t
     /tmp/cclmCDqy.s:7324   .text._Z19processCalibrateESCv:00000000 _Z19processCalibrateESCv
     /tmp/cclmCDqy.s:7426   .text._Z19processCalibrateESCv:00000070 $d
     /tmp/cclmCDqy.s:7436   .text._Z25processThrottleCorrectionv:00000000 $t
     /tmp/cclmCDqy.s:7441   .text._Z25processThrottleCorrectionv:00000000 _Z25processThrottleCorrectionv
     /tmp/cclmCDqy.s:7473   .text._Z25processThrottleCorrectionv:00000020 $d
     /tmp/cclmCDqy.s:7478   .text._Z20processHardManueversv:00000000 $t
     /tmp/cclmCDqy.s:7483   .text._Z20processHardManueversv:00000000 _Z20processHardManueversv
     /tmp/cclmCDqy.s:7537   .text._Z20processHardManueversv:00000040 $d
     /tmp/cclmCDqy.s:7547   .text._Z20processMinMaxCommandv:00000000 $t
     /tmp/cclmCDqy.s:7552   .text._Z20processMinMaxCommandv:00000000 _Z20processMinMaxCommandv
     /tmp/cclmCDqy.s:7640   .text._Z20processMinMaxCommandv:00000058 $d
     /tmp/cclmCDqy.s:7648   .text._Z25isHokuyoHoldEnabledByUserv:00000000 $t
     /tmp/cclmCDqy.s:7653   .text._Z25isHokuyoHoldEnabledByUserv:00000000 _Z25isHokuyoHoldEnabledByUserv
     /tmp/cclmCDqy.s:7684   .text._Z25isHokuyoHoldEnabledByUserv:00000020 $d
     /tmp/cclmCDqy.s:7689   .text._Z41processHokuyoHoldStateFromReceiverCommandv:00000000 $t
     /tmp/cclmCDqy.s:7694   .text._Z41processHokuyoHoldStateFromReceiverCommandv:00000000 _Z41processHokuyoHoldStateFromReceiverCommandv
     /tmp/cclmCDqy.s:7769   .text._Z41processHokuyoHoldStateFromReceiverCommandv:00000060 $d
     /tmp/cclmCDqy.s:7780   .text._Z27isPositionHoldEnabledByUserv:00000000 $t
     /tmp/cclmCDqy.s:7785   .text._Z27isPositionHoldEnabledByUserv:00000000 _Z27isPositionHoldEnabledByUserv
     /tmp/cclmCDqy.s:7806   .text._Z27isPositionHoldEnabledByUserv:00000014 $d
     /tmp/cclmCDqy.s:7811   .text._Z43processAltitudeHoldStateFromReceiverCommandv:00000000 $t
     /tmp/cclmCDqy.s:7816   .text._Z43processAltitudeHoldStateFromReceiverCommandv:00000000 _Z43processAltitudeHoldStateFromReceiverCommandv
     /tmp/cclmCDqy.s:7919   .text._Z43processAltitudeHoldStateFromReceiverCommandv:00000074 $d
     /tmp/cclmCDqy.s:7934   .text._Z14processHeadingv:00000000 $t
     /tmp/cclmCDqy.s:7939   .text._Z14processHeadingv:00000000 _Z14processHeadingv
     /tmp/cclmCDqy.s:8154   .text._Z14processHeadingv:00000174 $d
     /tmp/cclmCDqy.s:8182   .text._Z20processFlightControlv:00000000 $t
     /tmp/cclmCDqy.s:8187   .text._Z20processFlightControlv:00000000 _Z20processFlightControlv
     /tmp/cclmCDqy.s:8345   .text._Z20processFlightControlv:000000c0 $d
     /tmp/cclmCDqy.s:8360   .text._Z12nvrReadFloati:00000000 $t
     /tmp/cclmCDqy.s:8365   .text._Z12nvrReadFloati:00000000 _Z12nvrReadFloati
     /tmp/cclmCDqy.s:8407   .text._Z12nvrReadFloati:00000024 $d
     /tmp/cclmCDqy.s:8412   .text._Z13nvrWriteFloatfi:00000000 $t
     /tmp/cclmCDqy.s:8417   .text._Z13nvrWriteFloatfi:00000000 _Z13nvrWriteFloatfi
     /tmp/cclmCDqy.s:8460   .text._Z13nvrWriteFloatfi:00000020 $d
     /tmp/cclmCDqy.s:8467   .text._Z11nvrReadLongi:00000000 $t
     /tmp/cclmCDqy.s:8472   .text._Z11nvrReadLongi:00000000 _Z11nvrReadLongi
     /tmp/cclmCDqy.s:8512   .text._Z11nvrReadLongi:00000024 $d
     /tmp/cclmCDqy.s:8517   .text._Z12nvrWriteLongli:00000000 $t
     /tmp/cclmCDqy.s:8522   .text._Z12nvrWriteLongli:00000000 _Z12nvrWriteLongli
     /tmp/cclmCDqy.s:8564   .text._Z12nvrWriteLongli:00000020 $d
     /tmp/cclmCDqy.s:8571   .text._Z10nvrReadPIDhj:00000000 $t
     /tmp/cclmCDqy.s:8576   .text._Z10nvrReadPIDhj:00000000 _Z10nvrReadPIDhj
     /tmp/cclmCDqy.s:8632   .text._Z10nvrReadPIDhj:00000030 $d
     /tmp/cclmCDqy.s:8637   .text._Z11nvrWritePIDhj:00000000 $t
     /tmp/cclmCDqy.s:8642   .text._Z11nvrWritePIDhj:00000000 _Z11nvrWritePIDhj
     /tmp/cclmCDqy.s:8687   .text._Z11nvrWritePIDhj:00000028 $d
     /tmp/cclmCDqy.s:8693   .text._Z16initializeEEPROMv:00000000 $t
     /tmp/cclmCDqy.s:8698   .text._Z16initializeEEPROMv:00000000 _Z16initializeEEPROMv
     /tmp/cclmCDqy.s:8944   .text._Z16initializeEEPROMv:00000138 $d
     /tmp/cclmCDqy.s:8980   .text._Z10readEEPROMv:00000000 $t
     /tmp/cclmCDqy.s:8985   .text._Z10readEEPROMv:00000000 _Z10readEEPROMv
     /tmp/cclmCDqy.s:9175   .text._Z10readEEPROMv:0000016c $d
     /tmp/cclmCDqy.s:9193   .text._Z11writeEEPROMv:00000000 $t
     /tmp/cclmCDqy.s:9198   .text._Z11writeEEPROMv:00000000 _Z11writeEEPROMv
     /tmp/cclmCDqy.s:9426   .text._Z11writeEEPROMv:000001c0 $d
     /tmp/cclmCDqy.s:9448   .text._Z25initSensorsZeroFromEEPROMv:00000000 $t
     /tmp/cclmCDqy.s:9453   .text._Z25initSensorsZeroFromEEPROMv:00000000 _Z25initSensorsZeroFromEEPROMv
     /tmp/cclmCDqy.s:9504   .text._Z25initSensorsZeroFromEEPROMv:00000050 $d
     /tmp/cclmCDqy.s:9511   .text._Z24storeSensorsZeroToEEPROMv:00000000 $t
     /tmp/cclmCDqy.s:9516   .text._Z24storeSensorsZeroToEEPROMv:00000000 _Z24storeSensorsZeroToEEPROMv
     /tmp/cclmCDqy.s:9570   .text._Z24storeSensorsZeroToEEPROMv:00000054 $d
     /tmp/cclmCDqy.s:9577   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000000 $t
     /tmp/cclmCDqy.s:9582   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000000 _Z46processZeroThrottleFunctionFromReceiverCommandv
     /tmp/cclmCDqy.s:9700   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000098 $d
     /tmp/cclmCDqy.s:9710   .text._Z17readPilotCommandsv:00000000 $t
     /tmp/cclmCDqy.s:9715   .text._Z17readPilotCommandsv:00000000 _Z17readPilotCommandsv
     /tmp/cclmCDqy.s:9787   .text._Z17readPilotCommandsv:00000054 $d
     /tmp/cclmCDqy.s:9797   .text._Z22initReceiverFromEEPROMv:00000000 $t
     /tmp/cclmCDqy.s:9802   .text._Z22initReceiverFromEEPROMv:00000000 _Z22initReceiverFromEEPROMv
     /tmp/cclmCDqy.s:9856   .text._Z22initReceiverFromEEPROMv:00000044 $d
     /tmp/cclmCDqy.s:9864   .text._Z17initCommunicationv:00000000 $t
     /tmp/cclmCDqy.s:9869   .text._Z17initCommunicationv:00000000 _Z17initCommunicationv
     /tmp/cclmCDqy.s:9883   .text._Z10getHeadingv:00000000 $t
     /tmp/cclmCDqy.s:9888   .text._Z10getHeadingv:00000000 _Z10getHeadingv
     /tmp/cclmCDqy.s:9902   .text._Z10getHeadingv:00000008 $d
     /tmp/cclmCDqy.s:9907   .text._Z15readValueSerialPch:00000000 $t
     /tmp/cclmCDqy.s:9912   .text._Z15readValueSerialPch:00000000 _Z15readValueSerialPch
     /tmp/cclmCDqy.s:9997   .text._Z15readValueSerialPch:0000004c $d
     /tmp/cclmCDqy.s:10002  .text._Z15readFloatSerialv:00000000 $t
     /tmp/cclmCDqy.s:10007  .text._Z15readFloatSerialv:00000000 _Z15readFloatSerialv
     /tmp/cclmCDqy.s:10045  .text._Z16skipSerialValuesh:00000000 $t
     /tmp/cclmCDqy.s:10050  .text._Z16skipSerialValuesh:00000000 _Z16skipSerialValuesh
     /tmp/cclmCDqy.s:10090  .text._Z13readSerialPIDh:00000000 $t
     /tmp/cclmCDqy.s:10095  .text._Z13readSerialPIDh:00000000 _Z13readSerialPIDh
     /tmp/cclmCDqy.s:10140  .text._Z13readSerialPIDh:00000024 $d
     /tmp/cclmCDqy.s:10145  .text._Z24validateCalibrateCommandh:00000000 $t
     /tmp/cclmCDqy.s:10150  .text._Z24validateCalibrateCommandh:00000000 _Z24validateCalibrateCommandh
     /tmp/cclmCDqy.s:10195  .text._Z24validateCalibrateCommandh:00000038 $d
     /tmp/cclmCDqy.s:10203  .text._Z17readSerialCommandv:00000000 $t
     /tmp/cclmCDqy.s:10208  .text._Z17readSerialCommandv:00000000 _Z17readSerialCommandv
     /tmp/cclmCDqy.s:10241  .text._Z17readSerialCommandv:00000026 $d
     /tmp/cclmCDqy.s:10288  .text._Z17readSerialCommandv:0000007a $t
     /tmp/cclmCDqy.s:10543  .text._Z17readSerialCommandv:00000220 $d
     /tmp/cclmCDqy.s:10564  .text._Z17readSerialCommandv:0000026c $t
     /tmp/cclmCDqy.s:10717  .text._Z17readSerialCommandv:00000330 $d
     /tmp/cclmCDqy.s:10729  .text._Z17readIntegerSerialv:00000000 $t
     /tmp/cclmCDqy.s:10734  .text._Z17readIntegerSerialv:00000000 _Z17readIntegerSerialv
     /tmp/cclmCDqy.s:10771  .text._Z5commav:00000000 $t
     /tmp/cclmCDqy.s:10776  .text._Z5commav:00000000 _Z5commav
     /tmp/cclmCDqy.s:10792  .text._Z5commav:00000008 $d
     /tmp/cclmCDqy.s:10797  .text._Z15PrintValueCommal:00000000 $t
     /tmp/cclmCDqy.s:10802  .text._Z15PrintValueCommal:00000000 _Z15PrintValueCommal
     /tmp/cclmCDqy.s:10829  .text._Z15PrintValueCommal:00000014 $d
     /tmp/cclmCDqy.s:10834  .text._Z15PrintValueCommah:00000000 $t
     /tmp/cclmCDqy.s:10839  .text._Z15PrintValueCommah:00000000 _Z15PrintValueCommah
     /tmp/cclmCDqy.s:10865  .text._Z15PrintValueCommah:00000014 $d
     /tmp/cclmCDqy.s:10870  .text._Z15PrintValueCommam:00000000 $t
     /tmp/cclmCDqy.s:10875  .text._Z15PrintValueCommam:00000000 _Z15PrintValueCommam
     /tmp/cclmCDqy.s:10902  .text._Z15PrintValueCommam:00000014 $d
     /tmp/cclmCDqy.s:10907  .text._Z15PrintValueCommai:00000000 $t
     /tmp/cclmCDqy.s:10912  .text._Z15PrintValueCommai:00000000 _Z15PrintValueCommai
     /tmp/cclmCDqy.s:10939  .text._Z15PrintValueCommai:00000014 $d
     /tmp/cclmCDqy.s:10944  .text._Z16PrintDummyValuesh:00000000 $t
     /tmp/cclmCDqy.s:10949  .text._Z16PrintDummyValuesh:00000000 _Z16PrintDummyValuesh
     /tmp/cclmCDqy.s:10990  .text._Z15PrintValueCommac:00000000 $t
     /tmp/cclmCDqy.s:10995  .text._Z15PrintValueCommac:00000000 _Z15PrintValueCommac
     /tmp/cclmCDqy.s:11020  .text._Z15PrintValueCommac:00000014 $d
     /tmp/cclmCDqy.s:11025  .text._Z15PrintValueCommad:00000000 $t
     /tmp/cclmCDqy.s:11030  .text._Z15PrintValueCommad:00000000 _Z15PrintValueCommad
     /tmp/cclmCDqy.s:11061  .text._Z15PrintValueCommad:0000001c $d
     /tmp/cclmCDqy.s:11066  .text._Z15PrintValueCommaf:00000000 $t
     /tmp/cclmCDqy.s:11071  .text._Z15PrintValueCommaf:00000000 _Z15PrintValueCommaf
     /tmp/cclmCDqy.s:11102  .text._Z15PrintValueCommaf:00000020 $d
     /tmp/cclmCDqy.s:11107  .text._Z8PrintPIDh:00000000 $t
     /tmp/cclmCDqy.s:11112  .text._Z8PrintPIDh:00000000 _Z8PrintPIDh
     /tmp/cclmCDqy.s:11145  .text._Z8PrintPIDh:00000020 $d
     /tmp/cclmCDqy.s:11150  .text._Z17printVehicleStatePKcmS0_:00000000 $t
     /tmp/cclmCDqy.s:11155  .text._Z17printVehicleStatePKcmS0_:00000000 _Z17printVehicleStatePKcmS0_
     /tmp/cclmCDqy.s:11207  .text._Z17printVehicleStatePKcmS0_:00000034 $d
     /tmp/cclmCDqy.s:11215  .text._Z18reportVehicleStatev:00000000 $t
     /tmp/cclmCDqy.s:11220  .text._Z18reportVehicleStatev:00000000 _Z18reportVehicleStatev
     /tmp/cclmCDqy.s:11339  .text._Z18reportVehicleStatev:000000d8 $d
     /tmp/cclmCDqy.s:11365  .text._Z19sendSerialTelemetryv:00000000 $t
     /tmp/cclmCDqy.s:11370  .text._Z19sendSerialTelemetryv:00000000 _Z19sendSerialTelemetryv
     /tmp/cclmCDqy.s:11753  .text._Z19sendSerialTelemetryv:000002a8 $d
     /tmp/cclmCDqy.s:11776  .text._Z19sendSerialTelemetryv:000002fc $t
     /tmp/cclmCDqy.s:12115  .text._Z19sendSerialTelemetryv:000004e0 $d
     /tmp/cclmCDqy.s:12139  .text._Z5setupv:00000000 $t
     /tmp/cclmCDqy.s:12144  .text._Z5setupv:00000000 _Z5setupv
     /tmp/cclmCDqy.s:12274  .text._Z5setupv:000000d0 $d
     /tmp/cclmCDqy.s:12286  .text._Z16process100HzTaskv:00000000 $t
     /tmp/cclmCDqy.s:12291  .text._Z16process100HzTaskv:00000000 _Z16process100HzTaskv
     /tmp/cclmCDqy.s:12518  .text._Z16process100HzTaskv:000001c0 $d
     /tmp/cclmCDqy.s:12543  .text._Z15process50HzTaskv:00000000 $t
     /tmp/cclmCDqy.s:12548  .text._Z15process50HzTaskv:00000000 _Z15process50HzTaskv
     /tmp/cclmCDqy.s:12576  .text._Z15process50HzTaskv:00000028 $d
     /tmp/cclmCDqy.s:12584  .text._Z16process10HzTask1v:00000000 $t
     /tmp/cclmCDqy.s:12589  .text._Z16process10HzTask1v:00000000 _Z16process10HzTask1v
     /tmp/cclmCDqy.s:12697  .text._Z16process10HzTask1v:000000a0 $d
     /tmp/cclmCDqy.s:12710  .text._Z16process10HzTask2v:00000000 $t
     /tmp/cclmCDqy.s:12715  .text._Z16process10HzTask2v:00000000 _Z16process10HzTask2v
     /tmp/cclmCDqy.s:12750  .text._Z16process10HzTask2v:00000030 $d
     /tmp/cclmCDqy.s:12758  .text._Z16process10HzTask3v:00000000 $t
     /tmp/cclmCDqy.s:12763  .text._Z16process10HzTask3v:00000000 _Z16process10HzTask3v
     /tmp/cclmCDqy.s:12790  .text._Z16process10HzTask3v:00000024 $d
     /tmp/cclmCDqy.s:12798  .text._Z14process1HzTaskv:00000000 $t
     /tmp/cclmCDqy.s:12803  .text._Z14process1HzTaskv:00000000 _Z14process1HzTaskv
     /tmp/cclmCDqy.s:12816  .text._Z4loopv:00000000 $t
     /tmp/cclmCDqy.s:12821  .text._Z4loopv:00000000 _Z4loopv
     /tmp/cclmCDqy.s:12919  .text._Z4loopv:00000084 $d
     /tmp/cclmCDqy.s:12930  .text.startup.main:00000000 $t
     /tmp/cclmCDqy.s:12935  .text.startup.main:00000000 main
     /tmp/cclmCDqy.s:12956  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 $t
     /tmp/cclmCDqy.s:12960  .text.startup._GLOBAL__sub_I__Z7premainv:00000000 _GLOBAL__sub_I__Z7premainv
     /tmp/cclmCDqy.s:822    .text._ZN14HardwareSPIExtC2Ej:00000000 _ZN14HardwareSPIExtC1Ej
     /tmp/cclmCDqy.s:13004  .text.startup._GLOBAL__sub_I__Z7premainv:00000028 $d
     /tmp/cclmCDqy.s:14307  .data.queryType:00000000 queryType
     /tmp/cclmCDqy.s:13932  .bss.headingTime:00000000 headingTime
     /tmp/cclmCDqy.s:14334  .bss.setHeading:00000000 setHeading
     /tmp/cclmCDqy.s:13800  .bss.motorConfiguratorCommand:00000000 motorConfiguratorCommand
     /tmp/cclmCDqy.s:14287  .bss.motorMinCommand:00000000 motorMinCommand
     /tmp/cclmCDqy.s:14485  .bss.motorMaxCommand:00000000 motorMaxCommand
     /tmp/cclmCDqy.s:14260  .bss.motorAxisCommandYaw:00000000 motorAxisCommandYaw
     /tmp/cclmCDqy.s:13452  .bss.motorAxisCommandPitch:00000000 motorAxisCommandPitch
     /tmp/cclmCDqy.s:13590  .bss.motorAxisCommandRoll:00000000 motorAxisCommandRoll
     /tmp/cclmCDqy.s:13296  .data.pinsArray:00000000 pinsArray
     /tmp/cclmCDqy.s:14032  .data.i2caddress:00000000 i2caddress
     /tmp/cclmCDqy.s:13698  .bss.prev_val:00000000 prev_val
     /tmp/cclmCDqy.s:13744  .bss.myLidarLite:00000000 myLidarLite
     /tmp/cclmCDqy.s:13485  .data.MS5611_first_read:00000000 MS5611_first_read
     /tmp/cclmCDqy.s:14327  .bss.baroStartTime:00000000 baroStartTime
     /tmp/cclmCDqy.s:13472  .bss.baroGroundUpdateDone:00000000 baroGroundUpdateDone
     /tmp/cclmCDqy.s:14340  .bss.rawPressureSumCount:00000000 rawPressureSumCount
     /tmp/cclmCDqy.s:14171  .bss.rawPressureSum:00000000 rawPressureSum
     /tmp/cclmCDqy.s:13651  .bss.isReadPressure:00000000 isReadPressure
     /tmp/cclmCDqy.s:13631  .data.pressureFactor:00000000 pressureFactor
     /tmp/cclmCDqy.s:13263  .bss.pressureCount:00000000 pressureCount
     /tmp/cclmCDqy.s:14138  .bss.rawTemperature:00000000 rawTemperature
     /tmp/cclmCDqy.s:13257  .bss.rawPressure:00000000 rawPressure
     /tmp/cclmCDqy.s:13992  .bss.pressure:00000000 pressure
     /tmp/cclmCDqy.s:13786  .bss.MS5611_offset:00000000 MS5611_offset
     /tmp/cclmCDqy.s:14027  .bss.MS5611_sens:00000000 MS5611_sens
     /tmp/cclmCDqy.s:14426  .bss.MS5611lastRawPressure:00000000 MS5611lastRawPressure
     /tmp/cclmCDqy.s:13244  .bss.MS5611lastRawTemperature:00000000 MS5611lastRawTemperature
     /tmp/cclmCDqy.s:14226  .bss.MS5611Prom:00000000 MS5611Prom
     /tmp/cclmCDqy.s:13251  .data.baroSmoothFactor:00000000 baroSmoothFactor
     /tmp/cclmCDqy.s:13438  .bss.baroGroundAltitude:00000000 baroGroundAltitude
     /tmp/cclmCDqy.s:13890  .bss.baroRawAltitude:00000000 baroRawAltitude
     /tmp/cclmCDqy.s:13418  .bss.baroAltitude:00000000 baroAltitude
     /tmp/cclmCDqy.s:13459  .bss.motorCommand:00000000 motorCommand
     /tmp/cclmCDqy.s:13503  .data.numberOfMotors:00000000 numberOfMotors
     /tmp/cclmCDqy.s:13304  .data.PWM_in_handler:00000000 PWM_in_handler
     /tmp/cclmCDqy.s:13332  .bss.FrqData:00000000 FrqData
     /tmp/cclmCDqy.s:13624  .bss.previousEz:00000000 previousEz
     /tmp/cclmCDqy.s:13617  .bss.previousEy:00000000 previousEy
     /tmp/cclmCDqy.s:13610  .bss.previousEx:00000000 previousEx
     /tmp/cclmCDqy.s:13498  .bss.ezInt:00000000 ezInt
     /tmp/cclmCDqy.s:13603  .bss.eyInt:00000000 eyInt
     /tmp/cclmCDqy.s:14157  .bss.exInt:00000000 exInt
     /tmp/cclmCDqy.s:13779  .bss.q3:00000000 q3
     /tmp/cclmCDqy.s:13772  .bss.q2:00000000 q2
     /tmp/cclmCDqy.s:13351  .bss.q1:00000000 q1
     /tmp/cclmCDqy.s:13583  .bss.q0:00000000 q0
     /tmp/cclmCDqy.s:13828  .bss.halfT:00000000 halfT
     /tmp/cclmCDqy.s:13869  .bss.Ki:00000000 Ki
     /tmp/cclmCDqy.s:13911  .bss.Kp:00000000 Kp
     /tmp/cclmCDqy.s:13724  .bss.accelCutoff:00000000 accelCutoff
     /tmp/cclmCDqy.s:14313  .bss.earthAccel:00000000 earthAccel
     /tmp/cclmCDqy.s:13842  .bss.correctedRateVector:00000000 correctedRateVector
     /tmp/cclmCDqy.s:14301  .bss.gyroAngle:00000000 gyroAngle
     /tmp/cclmCDqy.s:14047  .bss.kinematicsAngle:00000000 kinematicsAngle
     /tmp/cclmCDqy.s:14345  .bss.kinematicsType:00000000 kinematicsType
     /tmp/cclmCDqy.s:14492  .bss.previousMeasureCriticalSensorsTime:00000000 previousMeasureCriticalSensorsTime
     /tmp/cclmCDqy.s:13596  .bss.accelSampleCount:00000000 accelSampleCount
     /tmp/cclmCDqy.s:13793  .bss.accelSample:00000000 accelSample
     /tmp/cclmCDqy.s:14359  .bss.meterPerSecSec:00000000 meterPerSecSec
     /tmp/cclmCDqy.s:14178  .bss.accelOneG:00000000 accelOneG
     /tmp/cclmCDqy.s:14513  .bss.runTimeAccelBias:00000000 runTimeAccelBias
     /tmp/cclmCDqy.s:13814  .bss.accelScaleFactor:00000000 accelScaleFactor
     /tmp/cclmCDqy.s:14212  .bss.gyroSampleCount:00000000 gyroSampleCount
     /tmp/cclmCDqy.s:14206  .bss.gyroLastMesuredTime:00000000 gyroLastMesuredTime
     /tmp/cclmCDqy.s:13277  .bss.gyroHeading:00000000 gyroHeading
     /tmp/cclmCDqy.s:14465  .bss.gyroScaleFactor:00000000 gyroScaleFactor
     /tmp/cclmCDqy.s:13897  .bss.gyroSample:00000000 gyroSample
     /tmp/cclmCDqy.s:14506  .bss.gyroZero:00000000 gyroZero
     /tmp/cclmCDqy.s:14020  .bss.gyroRate:00000000 gyroRate
     /tmp/cclmCDqy.s:13645  .bss.readMPU6000GyroCount:00000000 readMPU6000GyroCount
     /tmp/cclmCDqy.s:13925  .bss.readMPU6000AccelCount:00000000 readMPU6000AccelCount
     /tmp/cclmCDqy.s:13358  .bss.readMPU6000Count:00000000 readMPU6000Count
     /tmp/cclmCDqy.s:13985  .bss.initializeMPU6000SensorsDone:00000000 initializeMPU6000SensorsDone
     /tmp/cclmCDqy.s:14098  .bss.spiMPU6000:00000000 spiMPU6000
     /tmp/cclmCDqy.s:13217  .bss.MPU6000:00000000 MPU6000
     /tmp/cclmCDqy.s:14392  .bss.vehicleState:00000000 vehicleState
     /tmp/cclmCDqy.s:13999  .bss.gyroRaw:00000000 gyroRaw
     /tmp/cclmCDqy.s:13391  .rodata.Serial:00000000 Serial
     /tmp/cclmCDqy.s:14105  .bss.fourthOrder:00000000 fourthOrder
     /tmp/cclmCDqy.s:13712  .bss.windupGuard:00000000 windupGuard
     /tmp/cclmCDqy.s:14352  .bss.PID:00000000 PID
     /tmp/cclmCDqy.s:13657  .bss.fastTransfer:00000000 fastTransfer
     /tmp/cclmCDqy.s:14239  .bss.baroAltitudeToHoldTarget:00000000 baroAltitudeToHoldTarget
     /tmp/cclmCDqy.s:14091  .bss.zDampeningThrottleCorrection:00000000 zDampeningThrottleCorrection
     /tmp/cclmCDqy.s:13398  .bss.runtimeZBias:00000000 runtimeZBias
     /tmp/cclmCDqy.s:14112  .bss.estimatedZVelocity:00000000 estimatedZVelocity
     /tmp/cclmCDqy.s:13524  .bss.zVelocity:00000000 zVelocity
     /tmp/cclmCDqy.s:13203  .bss.runtimaZBiasInitialized:00000000 runtimaZBiasInitialized
     /tmp/cclmCDqy.s:13365  .bss.velocityCompFilter2:00000000 velocityCompFilter2
     /tmp/cclmCDqy.s:13904  .data.velocityCompFilter1:00000000 velocityCompFilter1
     /tmp/cclmCDqy.s:14199  .bss.LidarHoldThrottle:00000000 LidarHoldThrottle
     /tmp/cclmCDqy.s:14232  .bss.zDirection:00000000 zDirection
     /tmp/cclmCDqy.s:13918  .bss.prevAltitude:00000000 prevAltitude
     /tmp/cclmCDqy.s:13385  .bss.estimatedAltitude:00000000 estimatedAltitude
     /tmp/cclmCDqy.s:14365  .bss.isAltitudeHoldInitialized:00000000 isAltitudeHoldInitialized
     /tmp/cclmCDqy.s:14406  .data.altitudeHoldThrottle:00000000 altitudeHoldThrottle
     /tmp/cclmCDqy.s:14192  .data.maxThrottleAdjust:00000000 maxThrottleAdjust
     /tmp/cclmCDqy.s:13821  .data.minThrottleAdjust:00000000 minThrottleAdjust
     /tmp/cclmCDqy.s:13318  .data.altitudeHoldPanicStickMovement:00000000 altitudeHoldPanicStickMovement
     /tmp/cclmCDqy.s:13431  .data.altitudeHoldBump:00000000 altitudeHoldBump
     /tmp/cclmCDqy.s:13862  .bss.altitudeHoldState:00000000 altitudeHoldState
     /tmp/cclmCDqy.s:13537  .bss.headingHoldState:00000000 headingHoldState
     /tmp/cclmCDqy.s:13466  .bss.prevPitch:00000000 prevPitch
     /tmp/cclmCDqy.s:13479  .bss.prevRoll:00000000 prevRoll
     /tmp/cclmCDqy.s:14419  .bss.PitchVelocityDirection:00000000 PitchVelocityDirection
     /tmp/cclmCDqy.s:13849  .bss.RollVelocityDirection:00000000 RollVelocityDirection
     /tmp/cclmCDqy.s:13705  .bss.temphokuyoHoldThrottleCorrection_YGLOBAL:00000000 temphokuyoHoldThrottleCorrection_YGLOBAL
     /tmp/cclmCDqy.s:14074  .bss.temphokuyoHoldThrottleCorrection_XGLOBAL:00000000 temphokuyoHoldThrottleCorrection_XGLOBAL
     /tmp/cclmCDqy.s:13731  .bss.hokuyoHoldThrottleCorrection_X:00000000 hokuyoHoldThrottleCorrection_X
     /tmp/cclmCDqy.s:14185  .bss.hokuyoHoldThrottleCorrection_Y:00000000 hokuyoHoldThrottleCorrection_Y
     /tmp/cclmCDqy.s:14040  .bss.LastNonZeroPitch:00000000 LastNonZeroPitch
     /tmp/cclmCDqy.s:13231  .bss.LastNonZeroRoll:00000000 LastNonZeroRoll
     /tmp/cclmCDqy.s:13290  .bss.HokuyoHoldState:00000000 HokuyoHoldState
     /tmp/cclmCDqy.s:14294  .bss.HokuyoPositionToHoldTarget_Y:00000000 HokuyoPositionToHoldTarget_Y
     /tmp/cclmCDqy.s:14006  .bss.HokuyoPositionToHoldTarget_X:00000000 HokuyoPositionToHoldTarget_X
     /tmp/cclmCDqy.s:13424  .bss.isHokuyoHoldInitialized:00000000 isHokuyoHoldInitialized
     /tmp/cclmCDqy.s:14478  .bss.bit_array:00000000 bit_array
     /tmp/cclmCDqy.s:14372  .bss.Hokuyo_str:00000000 Hokuyo_str
     /tmp/cclmCDqy.s:13576  .bss.distance2D:00000000 distance2D
     /tmp/cclmCDqy.s:13543  .bss.meanAltitude:00000000 meanAltitude
     /tmp/cclmCDqy.s:14246  .bss.alt_Sum:00000000 alt_Sum
     /tmp/cclmCDqy.s:14150  .bss.meanFreqCount:00000000 meanFreqCount
     /tmp/cclmCDqy.s:14145  .bss.alt_buffer_pointer:00000000 alt_buffer_pointer
     /tmp/cclmCDqy.s:13531  .bss.alt_buffer:00000000 alt_buffer
     /tmp/cclmCDqy.s:13751  .bss.relativeHeading:00000000 relativeHeading
     /tmp/cclmCDqy.s:13378  .bss.heading:00000000 heading
     /tmp/cclmCDqy.s:13835  .bss.headingHold:00000000 headingHold
     /tmp/cclmCDqy.s:13491  .bss.headingHoldConfig:00000000 headingHoldConfig
     /tmp/cclmCDqy.s:14472  .bss.aref:00000000 aref
     /tmp/cclmCDqy.s:13445  .bss.altitudeHoldThrottleCorrectionGLOBAL:00000000 altitudeHoldThrottleCorrectionGLOBAL
     /tmp/cclmCDqy.s:14440  .bss.hundredHZpreviousTime:00000000 hundredHZpreviousTime
     /tmp/cclmCDqy.s:13856  .bss.fiftyHZpreviousTime:00000000 fiftyHZpreviousTime
     /tmp/cclmCDqy.s:14060  .bss.lowPriorityTenHZpreviousTime2:00000000 lowPriorityTenHZpreviousTime2
     /tmp/cclmCDqy.s:14273  .bss.lowPriorityTenHZpreviousTime:00000000 lowPriorityTenHZpreviousTime
     /tmp/cclmCDqy.s:13371  .bss.tenHZpreviousTime:00000000 tenHZpreviousTime
     /tmp/cclmCDqy.s:14053  .bss.oneHZpreviousTime:00000000 oneHZpreviousTime
     /tmp/cclmCDqy.s:13685  .bss.deltaTime:00000000 deltaTime
     /tmp/cclmCDqy.s:14452  .bss.currentTime:00000000 currentTime
     /tmp/cclmCDqy.s:13678  .bss.previousTime:00000000 previousTime
     /tmp/cclmCDqy.s:13517  .data.rotationSpeedFactor:00000000 rotationSpeedFactor
     /tmp/cclmCDqy.s:14132  .bss.inFlight:00000000 inFlight
     /tmp/cclmCDqy.s:13664  .bss.filteredAccel:00000000 filteredAccel
     /tmp/cclmCDqy.s:14085  .bss.minLimit:00000000 minLimit
     /tmp/cclmCDqy.s:14445  .bss.maxLimit:00000000 maxLimit
     /tmp/cclmCDqy.s:14412  .bss.safetyCheck:00000000 safetyCheck
     /tmp/cclmCDqy.s:13237  .bss.motorArmed:00000000 motorArmed
     /tmp/cclmCDqy.s:14013  .data.throttle:00000000 throttle
     /tmp/cclmCDqy.s:14433  .data.G_Dt:00000000 G_Dt
     /tmp/cclmCDqy.s:13671  .bss.minArmedThrottle:00000000 minArmedThrottle
     /tmp/cclmCDqy.s:14067  .bss.frameCounter:00000000 frameCounter
     /tmp/cclmCDqy.s:13338  .data.flightMode:00000000 flightMode
     /tmp/cclmCDqy.s:14266  .bss.previousFlightMode:00000000 previousFlightMode
     /tmp/cclmCDqy.s:14458  .bss.count:00000000 count
     /tmp/cclmCDqy.s:13876  .bss.hokuyo_YRaw:00000000 hokuyo_YRaw
     /tmp/cclmCDqy.s:13510  .bss.hokuyo_XRaw:00000000 hokuyo_XRaw
     /tmp/cclmCDqy.s:14399  .data.testCommand:00000000 testCommand
     /tmp/cclmCDqy.s:14080  .bss.calibrateESC:00000000 calibrateESC
     /tmp/cclmCDqy.s:14280  .bss.channelCal:00000000 channelCal
     /tmp/cclmCDqy.s:13325  .bss.receiverSmoothFactor:00000000 receiverSmoothFactor
     /tmp/cclmCDqy.s:14320  .bss.receiverOffset:00000000 receiverOffset
     /tmp/cclmCDqy.s:14379  .bss.receiverSlope:00000000 receiverSlope
     /tmp/cclmCDqy.s:13883  .bss.receiverCommandSmooth:00000000 receiverCommandSmooth
     /tmp/cclmCDqy.s:13807  .bss.receiverCommand:00000000 receiverCommand
     /tmp/cclmCDqy.s:14253  .bss.receiverZero:00000000 receiverZero
     /tmp/cclmCDqy.s:13224  .bss.receiverData:00000000 receiverData
     /tmp/cclmCDqy.s:14164  .bss.receiverXmitFactor:00000000 receiverXmitFactor
     /tmp/cclmCDqy.s:14219  .bss.lastReceiverChannel:00000000 lastReceiverChannel
     /tmp/cclmCDqy.s:13718  .bss.pre_value:00000000 pre_value
     /tmp/cclmCDqy.s:14126  .data.est_errY:00000000 est_errY
     /tmp/cclmCDqy.s:13765  .data.est_valY:00000000 est_valY
     /tmp/cclmCDqy.s:14119  .data.est_errX:00000000 est_errX
     /tmp/cclmCDqy.s:13758  .data.est_valX:00000000 est_valX
     /tmp/cclmCDqy.s:13738  .data.est_err:00000000 est_err
     /tmp/cclmCDqy.s:13638  .data.est_val:00000000 est_val
     /tmp/cclmCDqy.s:13692  .bss.kY:00000000 kY
     /tmp/cclmCDqy.s:13210  .bss.kX:00000000 kX
     /tmp/cclmCDqy.s:13344  .bss.out:00000000 out
     /tmp/cclmCDqy.s:13270  .bss.k:00000000 k
     /tmp/cclmCDqy.s:13284  .bss.kal_filt:00000000 kal_filt
     /tmp/cclmCDqy.s:14385  .bss.pulseWidth:00000000 pulseWidth
     /tmp/cclmCDqy.s:5429   .text._ZN9LIDARLiteC2Ev:00000000 _ZN9LIDARLiteC1Ev
     /tmp/cclmCDqy.s:13204  .bss.runtimaZBiasInitialized:00000000 $d
     /tmp/cclmCDqy.s:13206  .bss.kX:00000000 $d
     /tmp/cclmCDqy.s:13213  .bss.MPU6000:00000000 $d
     /tmp/cclmCDqy.s:13220  .bss.receiverData:00000000 $d
     /tmp/cclmCDqy.s:13227  .bss.LastNonZeroRoll:00000000 $d
     /tmp/cclmCDqy.s:13238  .bss.motorArmed:00000000 $d
     /tmp/cclmCDqy.s:13240  .bss.MS5611lastRawTemperature:00000000 $d
     /tmp/cclmCDqy.s:13247  .data.baroSmoothFactor:00000000 $d
     /tmp/cclmCDqy.s:13254  .bss.rawPressure:00000000 $d
     /tmp/cclmCDqy.s:13264  .bss.pressureCount:00000000 $d
     /tmp/cclmCDqy.s:13266  .bss.k:00000000 $d
     /tmp/cclmCDqy.s:13273  .bss.gyroHeading:00000000 $d
     /tmp/cclmCDqy.s:13280  .bss.kal_filt:00000000 $d
     /tmp/cclmCDqy.s:13291  .bss.HokuyoHoldState:00000000 $d
     /tmp/cclmCDqy.s:13293  .data.pinsArray:00000000 $d
     /tmp/cclmCDqy.s:13300  .data.PWM_in_handler:00000000 $d
     /tmp/cclmCDqy.s:13314  .data.altitudeHoldPanicStickMovement:00000000 $d
     /tmp/cclmCDqy.s:13321  .bss.receiverSmoothFactor:00000000 $d
     /tmp/cclmCDqy.s:13328  .bss.FrqData:00000000 $d
     /tmp/cclmCDqy.s:13341  .bss.out:00000000 $d
     /tmp/cclmCDqy.s:13347  .bss.q1:00000000 $d
     /tmp/cclmCDqy.s:13354  .bss.readMPU6000Count:00000000 $d
     /tmp/cclmCDqy.s:13361  .bss.velocityCompFilter2:00000000 $d
     /tmp/cclmCDqy.s:13368  .bss.tenHZpreviousTime:00000000 $d
     /tmp/cclmCDqy.s:13374  .bss.heading:00000000 $d
     /tmp/cclmCDqy.s:13381  .bss.estimatedAltitude:00000000 $d
     /tmp/cclmCDqy.s:13388  .rodata.Serial:00000000 $d
     /tmp/cclmCDqy.s:13394  .bss.runtimeZBias:00000000 $d
     /tmp/cclmCDqy.s:13404  .rodata._ZL11receiverPin:00000000 _ZL11receiverPin
     /tmp/cclmCDqy.s:13414  .bss.baroAltitude:00000000 $d
     /tmp/cclmCDqy.s:13425  .bss.isHokuyoHoldInitialized:00000000 $d
     /tmp/cclmCDqy.s:13427  .data.altitudeHoldBump:00000000 $d
     /tmp/cclmCDqy.s:13434  .bss.baroGroundAltitude:00000000 $d
     /tmp/cclmCDqy.s:13441  .bss.altitudeHoldThrottleCorrectionGLOBAL:00000000 $d
     /tmp/cclmCDqy.s:13448  .bss.motorAxisCommandPitch:00000000 $d
     /tmp/cclmCDqy.s:13455  .bss.motorCommand:00000000 $d
     /tmp/cclmCDqy.s:13462  .bss.prevPitch:00000000 $d
     /tmp/cclmCDqy.s:13473  .bss.baroGroundUpdateDone:00000000 $d
     /tmp/cclmCDqy.s:13475  .bss.prevRoll:00000000 $d
     /tmp/cclmCDqy.s:13492  .bss.headingHoldConfig:00000000 $d
     /tmp/cclmCDqy.s:13494  .bss.ezInt:00000000 $d
     /tmp/cclmCDqy.s:13506  .bss.hokuyo_XRaw:00000000 $d
     /tmp/cclmCDqy.s:13513  .data.rotationSpeedFactor:00000000 $d
     /tmp/cclmCDqy.s:13520  .bss.zVelocity:00000000 $d
     /tmp/cclmCDqy.s:13527  .bss.alt_buffer:00000000 $d
     /tmp/cclmCDqy.s:13538  .bss.headingHoldState:00000000 $d
     /tmp/cclmCDqy.s:13540  .bss.meanAltitude:00000000 $d
     /tmp/cclmCDqy.s:13549  .rodata._ZL18ReceiverChannelMap:00000000 _ZL18ReceiverChannelMap
     /tmp/cclmCDqy.s:13562  .rodata._ZL19stm32_motor_mapping:00000000 _ZL19stm32_motor_mapping
     /tmp/cclmCDqy.s:13572  .bss.distance2D:00000000 $d
     /tmp/cclmCDqy.s:13579  .bss.q0:00000000 $d
     /tmp/cclmCDqy.s:13586  .bss.motorAxisCommandRoll:00000000 $d
     /tmp/cclmCDqy.s:13597  .bss.accelSampleCount:00000000 $d
     /tmp/cclmCDqy.s:13599  .bss.eyInt:00000000 $d
     /tmp/cclmCDqy.s:13606  .bss.previousEx:00000000 $d
     /tmp/cclmCDqy.s:13613  .bss.previousEy:00000000 $d
     /tmp/cclmCDqy.s:13620  .bss.previousEz:00000000 $d
     /tmp/cclmCDqy.s:13627  .data.pressureFactor:00000000 $d
     /tmp/cclmCDqy.s:13634  .data.est_val:00000000 $d
     /tmp/cclmCDqy.s:13641  .bss.readMPU6000GyroCount:00000000 $d
     /tmp/cclmCDqy.s:13652  .bss.isReadPressure:00000000 $d
     /tmp/cclmCDqy.s:13658  .bss.fastTransfer:00000000 $d
     /tmp/cclmCDqy.s:13660  .bss.filteredAccel:00000000 $d
     /tmp/cclmCDqy.s:13667  .bss.minArmedThrottle:00000000 $d
     /tmp/cclmCDqy.s:13674  .bss.previousTime:00000000 $d
     /tmp/cclmCDqy.s:13681  .bss.deltaTime:00000000 $d
     /tmp/cclmCDqy.s:13688  .bss.kY:00000000 $d
     /tmp/cclmCDqy.s:13695  .bss.prev_val:00000000 $d
     /tmp/cclmCDqy.s:13701  .bss.temphokuyoHoldThrottleCorrection_YGLOBAL:00000000 $d
     /tmp/cclmCDqy.s:13708  .bss.windupGuard:00000000 $d
     /tmp/cclmCDqy.s:13715  .bss.pre_value:00000000 $d
     /tmp/cclmCDqy.s:13721  .bss.accelCutoff:00000000 $d
     /tmp/cclmCDqy.s:13727  .bss.hokuyoHoldThrottleCorrection_X:00000000 $d
     /tmp/cclmCDqy.s:13734  .data.est_err:00000000 $d
     /tmp/cclmCDqy.s:13745  .bss.myLidarLite:00000000 $d
     /tmp/cclmCDqy.s:13747  .bss.relativeHeading:00000000 $d
     /tmp/cclmCDqy.s:13754  .data.est_valX:00000000 $d
     /tmp/cclmCDqy.s:13761  .data.est_valY:00000000 $d
     /tmp/cclmCDqy.s:13768  .bss.q2:00000000 $d
     /tmp/cclmCDqy.s:13775  .bss.q3:00000000 $d
     /tmp/cclmCDqy.s:13782  .bss.MS5611_offset:00000000 $d
     /tmp/cclmCDqy.s:13789  .bss.accelSample:00000000 $d
     /tmp/cclmCDqy.s:13796  .bss.motorConfiguratorCommand:00000000 $d
     /tmp/cclmCDqy.s:13803  .bss.receiverCommand:00000000 $d
     /tmp/cclmCDqy.s:13810  .bss.accelScaleFactor:00000000 $d
     /tmp/cclmCDqy.s:13817  .data.minThrottleAdjust:00000000 $d
     /tmp/cclmCDqy.s:13824  .bss.halfT:00000000 $d
     /tmp/cclmCDqy.s:13831  .bss.headingHold:00000000 $d
     /tmp/cclmCDqy.s:13838  .bss.correctedRateVector:00000000 $d
     /tmp/cclmCDqy.s:13845  .bss.RollVelocityDirection:00000000 $d
     /tmp/cclmCDqy.s:13852  .bss.fiftyHZpreviousTime:00000000 $d
     /tmp/cclmCDqy.s:13863  .bss.altitudeHoldState:00000000 $d
     /tmp/cclmCDqy.s:13865  .bss.Ki:00000000 $d
     /tmp/cclmCDqy.s:13872  .bss.hokuyo_YRaw:00000000 $d
     /tmp/cclmCDqy.s:13879  .bss.receiverCommandSmooth:00000000 $d
     /tmp/cclmCDqy.s:13886  .bss.baroRawAltitude:00000000 $d
     /tmp/cclmCDqy.s:13893  .bss.gyroSample:00000000 $d
     /tmp/cclmCDqy.s:13900  .data.velocityCompFilter1:00000000 $d
     /tmp/cclmCDqy.s:13907  .bss.Kp:00000000 $d
     /tmp/cclmCDqy.s:13914  .bss.prevAltitude:00000000 $d
     /tmp/cclmCDqy.s:13921  .bss.readMPU6000AccelCount:00000000 $d
     /tmp/cclmCDqy.s:13928  .bss.headingTime:00000000 $d
     /tmp/cclmCDqy.s:13986  .bss.initializeMPU6000SensorsDone:00000000 $d
     /tmp/cclmCDqy.s:13988  .bss.pressure:00000000 $d
     /tmp/cclmCDqy.s:13995  .bss.gyroRaw:00000000 $d
     /tmp/cclmCDqy.s:14002  .bss.HokuyoPositionToHoldTarget_X:00000000 $d
     /tmp/cclmCDqy.s:14009  .data.throttle:00000000 $d
     /tmp/cclmCDqy.s:14016  .bss.gyroRate:00000000 $d
     /tmp/cclmCDqy.s:14023  .bss.MS5611_sens:00000000 $d
     /tmp/cclmCDqy.s:14036  .bss.LastNonZeroPitch:00000000 $d
     /tmp/cclmCDqy.s:14043  .bss.kinematicsAngle:00000000 $d
     /tmp/cclmCDqy.s:14050  .bss.oneHZpreviousTime:00000000 $d
     /tmp/cclmCDqy.s:14056  .bss.lowPriorityTenHZpreviousTime2:00000000 $d
     /tmp/cclmCDqy.s:14063  .bss.frameCounter:00000000 $d
     /tmp/cclmCDqy.s:14070  .bss.temphokuyoHoldThrottleCorrection_XGLOBAL:00000000 $d
     /tmp/cclmCDqy.s:14081  .bss.calibrateESC:00000000 $d
     /tmp/cclmCDqy.s:14086  .bss.minLimit:00000000 $d
     /tmp/cclmCDqy.s:14088  .bss.zDampeningThrottleCorrection:00000000 $d
     /tmp/cclmCDqy.s:14094  .bss.spiMPU6000:00000000 $d
     /tmp/cclmCDqy.s:14101  .bss.fourthOrder:00000000 $d
     /tmp/cclmCDqy.s:14108  .bss.estimatedZVelocity:00000000 $d
     /tmp/cclmCDqy.s:14115  .data.est_errX:00000000 $d
     /tmp/cclmCDqy.s:14122  .data.est_errY:00000000 $d
     /tmp/cclmCDqy.s:14133  .bss.inFlight:00000000 $d
     /tmp/cclmCDqy.s:14135  .bss.rawTemperature:00000000 $d
     /tmp/cclmCDqy.s:14141  .bss.alt_buffer_pointer:00000000 $d
     /tmp/cclmCDqy.s:14151  .bss.meanFreqCount:00000000 $d
     /tmp/cclmCDqy.s:14153  .bss.exInt:00000000 $d
     /tmp/cclmCDqy.s:14160  .bss.receiverXmitFactor:00000000 $d
     /tmp/cclmCDqy.s:14167  .bss.rawPressureSum:00000000 $d
     /tmp/cclmCDqy.s:14174  .bss.accelOneG:00000000 $d
     /tmp/cclmCDqy.s:14181  .bss.hokuyoHoldThrottleCorrection_Y:00000000 $d
     /tmp/cclmCDqy.s:14188  .data.maxThrottleAdjust:00000000 $d
     /tmp/cclmCDqy.s:14195  .bss.LidarHoldThrottle:00000000 $d
     /tmp/cclmCDqy.s:14202  .bss.gyroLastMesuredTime:00000000 $d
     /tmp/cclmCDqy.s:14213  .bss.gyroSampleCount:00000000 $d
     /tmp/cclmCDqy.s:14215  .bss.lastReceiverChannel:00000000 $d
     /tmp/cclmCDqy.s:14222  .bss.MS5611Prom:00000000 $d
     /tmp/cclmCDqy.s:14233  .bss.zDirection:00000000 $d
     /tmp/cclmCDqy.s:14235  .bss.baroAltitudeToHoldTarget:00000000 $d
     /tmp/cclmCDqy.s:14242  .bss.alt_Sum:00000000 $d
     /tmp/cclmCDqy.s:14249  .bss.receiverZero:00000000 $d
     /tmp/cclmCDqy.s:14256  .bss.motorAxisCommandYaw:00000000 $d
     /tmp/cclmCDqy.s:14267  .bss.previousFlightMode:00000000 $d
     /tmp/cclmCDqy.s:14269  .bss.lowPriorityTenHZpreviousTime:00000000 $d
     /tmp/cclmCDqy.s:14276  .bss.channelCal:00000000 $d
     /tmp/cclmCDqy.s:14283  .bss.motorMinCommand:00000000 $d
     /tmp/cclmCDqy.s:14290  .bss.HokuyoPositionToHoldTarget_Y:00000000 $d
     /tmp/cclmCDqy.s:14297  .bss.gyroAngle:00000000 $d
     /tmp/cclmCDqy.s:14310  .bss.earthAccel:00000000 $d
     /tmp/cclmCDqy.s:14316  .bss.receiverOffset:00000000 $d
     /tmp/cclmCDqy.s:14323  .bss.baroStartTime:00000000 $d
     /tmp/cclmCDqy.s:14330  .bss.setHeading:00000000 $d
     /tmp/cclmCDqy.s:14341  .bss.rawPressureSumCount:00000000 $d
     /tmp/cclmCDqy.s:14346  .bss.kinematicsType:00000000 $d
     /tmp/cclmCDqy.s:14348  .bss.PID:00000000 $d
     /tmp/cclmCDqy.s:14355  .bss.meterPerSecSec:00000000 $d
     /tmp/cclmCDqy.s:14366  .bss.isAltitudeHoldInitialized:00000000 $d
     /tmp/cclmCDqy.s:14368  .bss.Hokuyo_str:00000000 $d
     /tmp/cclmCDqy.s:14375  .bss.receiverSlope:00000000 $d
     /tmp/cclmCDqy.s:14382  .bss.pulseWidth:00000000 $d
     /tmp/cclmCDqy.s:14388  .bss.vehicleState:00000000 $d
     /tmp/cclmCDqy.s:14395  .data.testCommand:00000000 $d
     /tmp/cclmCDqy.s:14402  .data.altitudeHoldThrottle:00000000 $d
     /tmp/cclmCDqy.s:14413  .bss.safetyCheck:00000000 $d
     /tmp/cclmCDqy.s:14415  .bss.PitchVelocityDirection:00000000 $d
     /tmp/cclmCDqy.s:14422  .bss.MS5611lastRawPressure:00000000 $d
     /tmp/cclmCDqy.s:14429  .data.G_Dt:00000000 $d
     /tmp/cclmCDqy.s:14436  .bss.hundredHZpreviousTime:00000000 $d
     /tmp/cclmCDqy.s:14446  .bss.maxLimit:00000000 $d
     /tmp/cclmCDqy.s:14448  .bss.currentTime:00000000 $d
     /tmp/cclmCDqy.s:14455  .bss.count:00000000 $d
     /tmp/cclmCDqy.s:14461  .bss.gyroScaleFactor:00000000 $d
     /tmp/cclmCDqy.s:14468  .bss.aref:00000000 $d
     /tmp/cclmCDqy.s:14479  .bss.bit_array:00000000 $d
     /tmp/cclmCDqy.s:14481  .bss.motorMaxCommand:00000000 $d
     /tmp/cclmCDqy.s:14488  .bss.previousMeasureCriticalSensorsTime:00000000 $d
     /tmp/cclmCDqy.s:14495  .bss._ZL19_stm32_motor_number:00000000 $d
     /tmp/cclmCDqy.s:14499  .bss._ZL19_stm32_motor_number:00000000 _ZL19_stm32_motor_number
     /tmp/cclmCDqy.s:14502  .bss.gyroZero:00000000 $d
     /tmp/cclmCDqy.s:14509  .bss.runTimeAccelBias:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 _ZN14HardwareSPIExtC5Ej

UNDEFINED SYMBOLS
systick_uptime_millis
_Z4initv
_ZN7TwoWire7receiveEv
_ZN7TwoWire4sendEi
_ZN11HardwareSPIC2Ej
_ZN11HardwareSPI6nssPinEv
_Z12digitalWritehh
_Z7pinModeh13WiringPinMode
_ZN11HardwareSPI5beginE12SPIFrequencyjj
_ZN11HardwareSPI8transferEh
_ZN11HardwareSPI3endEv
_Z5delaym
_Z21findMedianIntWithDiffPiiS_
_Z17delayMicrosecondsj
_ZN7TwoWire5beginEhh
_ZN9USBSerial5beginEv
Wire
SerialUSB
__aeabi_f2d
__aeabi_d2f
sqrt
_Z10isSwitchedff
atan2
asin
rcc_dev_timer_clk_speed
gpio_set_mode
timer_attach_interrupt
PIN_MAP
_Z12filterSmoothfff
_Z11sendByteI2Cih
_ZN7TwoWire11requestFromEii
_Z11readWordI2Cv
_ZN7TwoWire9availableEv
_Z11readByteI2Cv
__aeabi_l2f
__aeabi_dsub
__aeabi_dmul
pow
_ZN7TwoWire17beginTransmissionEi
_ZN7TwoWire15endTransmissionEv
_ZN5Print7printlnEPKc
Serial1
_ZN5Print5printEii
_ZN5Print5printEc
_ZN14HardwareSerial5beginEj
Serial2
_ZN14HardwareSerial9availableEv
_ZN14HardwareSerial4readEv
_ZN11EEPROMClass4readEt
EEPROM
_ZN11EEPROMClass5writeEtt
memset
atof
atol
_ZN5Print5printEli
_ZN5Print5printEhi
_ZN5Print5printEmi
_ZN5Print5printEdi
_ZN5Print5printEPKc
_ZN5Print7printlnEii
_ZN5Print7printlnEdi
_ZN5Print7printlnEv
_ZN5Print7printlnEmi
_Z3isql
_Z7invSqrtf
